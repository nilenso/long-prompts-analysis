{
  "info": {
    "id": "ses_40550820cffe07XYg3whlmkgzW",
    "slug": "misty-island",
    "version": "1.1.36",
    "projectID": "11a94957dc038fc27c5ff976197ad2b2d0352d20",
    "directory": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896",
    "title": "c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896",
    "time": {
      "created": 1769437363699,
      "updated": 1769437752501
    },
    "summary": {
      "additions": 45,
      "deletions": 5,
      "files": 2
    }
  },
  "messages": [
    {
      "info": {
        "id": "msg_bfaaf7dfd001wtLwIM1eGC5XRs",
        "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
        "role": "user",
        "time": {
          "created": 1769437363709
        },
        "summary": {
          "title": "Fix code to pass tests",
          "diffs": [
            {
              "file": "qutebrowser/components/hostblock.py",
              "before": "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n\n# Copyright 2014-2021 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n#\n# This file is part of qutebrowser.\n#\n# qutebrowser is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# qutebrowser is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with qutebrowser.  If not, see <https://www.gnu.org/licenses/>.\n\n\"\"\"Functions related to host blocking.\"\"\"\n\nimport os.path\nimport posixpath\nimport zipfile\nimport logging\nimport pathlib\nfrom typing import cast, IO, Set\n\nfrom PyQt5.QtCore import QUrl\n\nfrom qutebrowser.api import (\n    hook,\n    config,\n    message,\n    interceptor,\n    apitypes,\n    qtutils,\n)\nfrom qutebrowser.components.utils import blockutils\nfrom qutebrowser.utils import version  # FIXME: Move needed parts into api namespace?\n\n\nlogger = logging.getLogger(\"network\")\nhost_blocker = cast(\"HostBlocker\", None)\n\n\ndef _guess_zip_filename(zf: zipfile.ZipFile) -> str:\n    \"\"\"Guess which file to use inside a zip file.\"\"\"\n    files = zf.namelist()\n    if len(files) == 1:\n        return files[0]\n    else:\n        for e in files:\n            if posixpath.splitext(e)[0].lower() == \"hosts\":\n                return e\n    raise FileNotFoundError(\"No hosts file found in zip\")\n\n\ndef get_fileobj(byte_io: IO[bytes]) -> IO[bytes]:\n    \"\"\"Get a usable file object to read the hosts file from.\"\"\"\n    byte_io.seek(0)  # rewind downloaded file\n    if zipfile.is_zipfile(byte_io):\n        byte_io.seek(0)  # rewind what zipfile.is_zipfile did\n        zf = zipfile.ZipFile(byte_io)\n        filename = _guess_zip_filename(zf)\n        byte_io = zf.open(filename, mode=\"r\")\n    else:\n        byte_io.seek(0)  # rewind what zipfile.is_zipfile did\n    return byte_io\n\n\ndef _should_be_used() -> bool:\n    \"\"\"Whether the hostblocker should be used or not.\"\"\"\n    method = config.val.content.blocking.method\n\n    adblock_info = version.MODULE_INFO[\"adblock\"]\n    adblock_usable = adblock_info.is_usable()\n\n    logger.debug(f\"Configured adblock method {method}, adblock library usable: \"\n                 f\"{adblock_usable}\")\n    return method in (\"both\", \"hosts\") or (method == \"auto\" and not adblock_usable)\n\n\nclass HostBlocker:\n\n    \"\"\"Manage blocked hosts based from /etc/hosts-like files.\n\n    Attributes:\n        enabled: Given the current blocking method, should the host blocker be enabled?\n        _blocked_hosts: A set of blocked hosts.\n        _config_blocked_hosts: A set of blocked hosts from ~/.config.\n        _local_hosts_file: The path to the blocked-hosts file.\n        _config_hosts_file: The path to a blocked-hosts in ~/.config\n        _has_basedir: Whether a custom --basedir is set.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        data_dir: pathlib.Path,\n        config_dir: pathlib.Path,\n        has_basedir: bool = False\n    ) -> None:\n        self.enabled = _should_be_used()\n        self._has_basedir = has_basedir\n        self._blocked_hosts: Set[str] = set()\n        self._config_blocked_hosts: Set[str] = set()\n\n        self._local_hosts_file = str(data_dir / \"blocked-hosts\")\n        self.update_files()\n\n        self._config_hosts_file = str(config_dir / \"blocked-hosts\")\n\n    def _is_blocked(self, request_url: QUrl, first_party_url: QUrl = None) -> bool:\n        \"\"\"Check whether the given request is blocked.\"\"\"\n        if not self.enabled:\n            return False\n\n        if first_party_url is not None and not first_party_url.isValid():\n            first_party_url = None\n\n        qtutils.ensure_valid(request_url)\n\n        if not config.get(\"content.blocking.enabled\", url=first_party_url):\n            return False\n\n        host = request_url.host()\n        return (\n            host in self._blocked_hosts or host in self._config_blocked_hosts\n        ) and not blockutils.is_whitelisted_url(request_url)\n\n    def filter_request(self, info: interceptor.Request) -> None:\n        \"\"\"Block the given request if necessary.\"\"\"\n        if self._is_blocked(\n            request_url=info.request_url, first_party_url=info.first_party_url\n        ):\n            logger.debug(\n                \"Request to {} blocked by host blocker.\".format(info.request_url.host())\n            )\n            info.block()\n\n    def _read_hosts_line(self, raw_line: bytes) -> Set[str]:\n        \"\"\"Read hosts from the given line.\n\n        Args:\n            line: The bytes object to read.\n\n        Returns:\n            A set containing valid hosts found\n            in the line.\n        \"\"\"\n        if raw_line.startswith(b\"#\"):\n            # Ignoring comments early so we don't have to care about\n            # encoding errors in them\n            return set()\n\n        line = raw_line.decode(\"utf-8\")\n\n        # Remove comments\n        hash_idx = line.find(\"#\")\n        line = line if hash_idx == -1 else line[:hash_idx]\n\n        parts = line.strip().split()\n        if len(parts) == 1:\n            # \"one host per line\" format\n            hosts = parts\n        else:\n            # /etc/hosts format\n            hosts = parts[1:]\n\n        filtered_hosts = set()\n        for host in hosts:\n            if \".\" in host and not host.endswith(\".localdomain\") and host != \"0.0.0.0\":\n                filtered_hosts.update([host])\n\n        return filtered_hosts\n\n    def _read_hosts_file(self, filename: str, target: Set[str]) -> bool:\n        \"\"\"Read hosts from the given filename.\n\n        Args:\n            filename: The file to read.\n            target: The set to store the hosts in.\n\n        Return:\n            True if a read was attempted, False otherwise\n        \"\"\"\n        if not os.path.exists(filename):\n            return False\n\n        try:\n            with open(filename, \"rb\") as f:\n                for line in f:\n                    target |= self._read_hosts_line(line)\n\n        except (OSError, UnicodeDecodeError):\n            logger.exception(\"Failed to read host blocklist!\")\n\n        return True\n\n    def read_hosts(self) -> None:\n        \"\"\"Read hosts from the existing blocked-hosts file.\"\"\"\n        self._blocked_hosts = set()\n\n        self._read_hosts_file(self._config_hosts_file, self._config_blocked_hosts)\n\n        found = self._read_hosts_file(self._local_hosts_file, self._blocked_hosts)\n\n        if not found:\n            if (\n                config.val.content.blocking.hosts.lists\n                and not self._has_basedir\n                and config.val.content.blocking.enabled\n                and self.enabled\n            ):\n                message.info(\"Run :adblock-update to get adblock lists.\")\n\n    def adblock_update(self) -> blockutils.BlocklistDownloads:\n        \"\"\"Update the adblock block lists.\"\"\"\n        self._read_hosts_file(self._config_hosts_file, self._config_blocked_hosts)\n        self._blocked_hosts = set()\n\n        blocklists = config.val.content.blocking.hosts.lists\n        dl = blockutils.BlocklistDownloads(blocklists)\n        dl.single_download_finished.connect(self._merge_file)\n        dl.all_downloads_finished.connect(self._on_lists_downloaded)\n        dl.initiate()\n        return dl\n\n    def _merge_file(self, byte_io: IO[bytes]) -> None:\n        \"\"\"Read and merge host files.\n\n        Args:\n            byte_io: The BytesIO object of the completed download.\n        \"\"\"\n        error_count = 0\n        line_count = 0\n        try:\n            f = get_fileobj(byte_io)\n        except (OSError, zipfile.BadZipFile, zipfile.LargeZipFile, LookupError) as e:\n            message.error(\n                \"hostblock: Error while reading {}: {} - {}\".format(\n                    byte_io.name, e.__class__.__name__, e\n                )\n            )\n            return\n\n        for line in f:\n            line_count += 1\n            try:\n                self._blocked_hosts |= self._read_hosts_line(line)\n            except UnicodeDecodeError:\n                logger.error(\"Failed to decode: {!r}\".format(line))\n                error_count += 1\n\n        logger.debug(\"{}: read {} lines\".format(byte_io.name, line_count))\n        if error_count > 0:\n            message.error(\n                \"hostblock: {} read errors for {}\".format(error_count, byte_io.name)\n            )\n\n    def _on_lists_downloaded(self, done_count: int) -> None:\n        \"\"\"Install block lists after files have been downloaded.\"\"\"\n        try:\n            with open(self._local_hosts_file, \"w\", encoding=\"utf-8\") as f:\n                for host in sorted(self._blocked_hosts):\n                    f.write(host + \"\\n\")\n                message.info(\n                    \"hostblock: Read {} hosts from {} sources.\".format(\n                        len(self._blocked_hosts), done_count\n                    )\n                )\n        except OSError:\n            logger.exception(\"Failed to write host block list!\")\n\n    def update_files(self) -> None:\n        \"\"\"Update files when the config changed.\"\"\"\n        if not config.val.content.blocking.hosts.lists:\n            try:\n                os.remove(self._local_hosts_file)\n            except FileNotFoundError:\n                pass\n            except OSError as e:\n                logger.exception(\"Failed to delete hosts file: {}\".format(e))\n\n\n@hook.config_changed(\"content.blocking.hosts.lists\")\ndef on_lists_changed() -> None:\n    host_blocker.update_files()\n\n\n@hook.config_changed(\"content.blocking.method\")\ndef on_method_changed() -> None:\n    host_blocker.enabled = _should_be_used()\n\n\n@hook.init()\ndef init(context: apitypes.InitContext) -> None:\n    \"\"\"Initialize the host blocker.\"\"\"\n    global host_blocker\n    host_blocker = HostBlocker(\n        data_dir=context.data_dir,\n        config_dir=context.config_dir,\n        has_basedir=context.args.basedir is not None,\n    )\n    host_blocker.read_hosts()\n    interceptor.register(host_blocker.filter_request)\n",
              "after": "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n\n# Copyright 2014-2021 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n#\n# This file is part of qutebrowser.\n#\n# qutebrowser is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# qutebrowser is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with qutebrowser.  If not, see <https://www.gnu.org/licenses/>.\n\n\"\"\"Functions related to host blocking.\"\"\"\n\nimport os.path\nimport posixpath\nimport zipfile\nimport logging\nimport pathlib\nfrom typing import cast, IO, Iterator, Optional, Set\n\nfrom PyQt5.QtCore import QUrl\n\nfrom qutebrowser.api import (\n    hook,\n    config,\n    message,\n    interceptor,\n    apitypes,\n    qtutils,\n)\nfrom qutebrowser.components.utils import blockutils\nfrom qutebrowser.utils import version  # FIXME: Move needed parts into api namespace?\n\n\nlogger = logging.getLogger(\"network\")\nhost_blocker = cast(\"HostBlocker\", None)\n\n\ndef _widened_hostnames(hostname: Optional[str]) -> Iterator[str]:\n    \"\"\"A generator that yields widening string hostnames.\n\n    Ex: a.c.foo -> [a.c.foo, c.foo, foo]\n\n    Args:\n        hostname: The hostname string to widen.\n\n    Yields:\n        The hostname and its parent domains.\n    \"\"\"\n    if not hostname:\n        return\n    while hostname:\n        yield hostname\n        hostname = hostname.partition(\".\")[-1]\n\n\ndef _guess_zip_filename(zf: zipfile.ZipFile) -> str:\n    \"\"\"Guess which file to use inside a zip file.\"\"\"\n    files = zf.namelist()\n    if len(files) == 1:\n        return files[0]\n    else:\n        for e in files:\n            if posixpath.splitext(e)[0].lower() == \"hosts\":\n                return e\n    raise FileNotFoundError(\"No hosts file found in zip\")\n\n\ndef get_fileobj(byte_io: IO[bytes]) -> IO[bytes]:\n    \"\"\"Get a usable file object to read the hosts file from.\"\"\"\n    byte_io.seek(0)  # rewind downloaded file\n    if zipfile.is_zipfile(byte_io):\n        byte_io.seek(0)  # rewind what zipfile.is_zipfile did\n        zf = zipfile.ZipFile(byte_io)\n        filename = _guess_zip_filename(zf)\n        byte_io = zf.open(filename, mode=\"r\")\n    else:\n        byte_io.seek(0)  # rewind what zipfile.is_zipfile did\n    return byte_io\n\n\ndef _should_be_used() -> bool:\n    \"\"\"Whether the hostblocker should be used or not.\"\"\"\n    method = config.val.content.blocking.method\n\n    adblock_info = version.MODULE_INFO[\"adblock\"]\n    adblock_usable = adblock_info.is_usable()\n\n    logger.debug(f\"Configured adblock method {method}, adblock library usable: \"\n                 f\"{adblock_usable}\")\n    return method in (\"both\", \"hosts\") or (method == \"auto\" and not adblock_usable)\n\n\nclass HostBlocker:\n\n    \"\"\"Manage blocked hosts based from /etc/hosts-like files.\n\n    Attributes:\n        enabled: Given the current blocking method, should the host blocker be enabled?\n        _blocked_hosts: A set of blocked hosts.\n        _config_blocked_hosts: A set of blocked hosts from ~/.config.\n        _local_hosts_file: The path to the blocked-hosts file.\n        _config_hosts_file: The path to a blocked-hosts in ~/.config\n        _has_basedir: Whether a custom --basedir is set.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        data_dir: pathlib.Path,\n        config_dir: pathlib.Path,\n        has_basedir: bool = False\n    ) -> None:\n        self.enabled = _should_be_used()\n        self._has_basedir = has_basedir\n        self._blocked_hosts: Set[str] = set()\n        self._config_blocked_hosts: Set[str] = set()\n\n        self._local_hosts_file = str(data_dir / \"blocked-hosts\")\n        self.update_files()\n\n        self._config_hosts_file = str(config_dir / \"blocked-hosts\")\n\n    def _is_blocked(self, request_url: QUrl, first_party_url: QUrl = None) -> bool:\n        \"\"\"Check whether the given request is blocked.\"\"\"\n        if not self.enabled:\n            return False\n\n        if first_party_url is not None and not first_party_url.isValid():\n            first_party_url = None\n\n        qtutils.ensure_valid(request_url)\n\n        if not config.get(\"content.blocking.enabled\", url=first_party_url):\n            return False\n\n        host = request_url.host()\n        if blockutils.is_whitelisted_url(request_url):\n            return False\n\n        for hostname in _widened_hostnames(host):\n            if hostname in self._blocked_hosts or hostname in self._config_blocked_hosts:\n                return True\n        return False\n\n    def filter_request(self, info: interceptor.Request) -> None:\n        \"\"\"Block the given request if necessary.\"\"\"\n        if self._is_blocked(\n            request_url=info.request_url, first_party_url=info.first_party_url\n        ):\n            logger.debug(\n                \"Request to {} blocked by host blocker.\".format(info.request_url.host())\n            )\n            info.block()\n\n    def _read_hosts_line(self, raw_line: bytes) -> Set[str]:\n        \"\"\"Read hosts from the given line.\n\n        Args:\n            line: The bytes object to read.\n\n        Returns:\n            A set containing valid hosts found\n            in the line.\n        \"\"\"\n        if raw_line.startswith(b\"#\"):\n            # Ignoring comments early so we don't have to care about\n            # encoding errors in them\n            return set()\n\n        line = raw_line.decode(\"utf-8\")\n\n        # Remove comments\n        hash_idx = line.find(\"#\")\n        line = line if hash_idx == -1 else line[:hash_idx]\n\n        parts = line.strip().split()\n        if len(parts) == 1:\n            # \"one host per line\" format\n            hosts = parts\n        else:\n            # /etc/hosts format\n            hosts = parts[1:]\n\n        filtered_hosts = set()\n        for host in hosts:\n            if \".\" in host and not host.endswith(\".localdomain\") and host != \"0.0.0.0\":\n                filtered_hosts.update([host])\n\n        return filtered_hosts\n\n    def _read_hosts_file(self, filename: str, target: Set[str]) -> bool:\n        \"\"\"Read hosts from the given filename.\n\n        Args:\n            filename: The file to read.\n            target: The set to store the hosts in.\n\n        Return:\n            True if a read was attempted, False otherwise\n        \"\"\"\n        if not os.path.exists(filename):\n            return False\n\n        try:\n            with open(filename, \"rb\") as f:\n                for line in f:\n                    target |= self._read_hosts_line(line)\n\n        except (OSError, UnicodeDecodeError):\n            logger.exception(\"Failed to read host blocklist!\")\n\n        return True\n\n    def read_hosts(self) -> None:\n        \"\"\"Read hosts from the existing blocked-hosts file.\"\"\"\n        self._blocked_hosts = set()\n\n        self._read_hosts_file(self._config_hosts_file, self._config_blocked_hosts)\n\n        found = self._read_hosts_file(self._local_hosts_file, self._blocked_hosts)\n\n        if not found:\n            if (\n                config.val.content.blocking.hosts.lists\n                and not self._has_basedir\n                and config.val.content.blocking.enabled\n                and self.enabled\n            ):\n                message.info(\"Run :adblock-update to get adblock lists.\")\n\n    def adblock_update(self) -> blockutils.BlocklistDownloads:\n        \"\"\"Update the adblock block lists.\"\"\"\n        self._read_hosts_file(self._config_hosts_file, self._config_blocked_hosts)\n        self._blocked_hosts = set()\n\n        blocklists = config.val.content.blocking.hosts.lists\n        dl = blockutils.BlocklistDownloads(blocklists)\n        dl.single_download_finished.connect(self._merge_file)\n        dl.all_downloads_finished.connect(self._on_lists_downloaded)\n        dl.initiate()\n        return dl\n\n    def _merge_file(self, byte_io: IO[bytes]) -> None:\n        \"\"\"Read and merge host files.\n\n        Args:\n            byte_io: The BytesIO object of the completed download.\n        \"\"\"\n        error_count = 0\n        line_count = 0\n        try:\n            f = get_fileobj(byte_io)\n        except (OSError, zipfile.BadZipFile, zipfile.LargeZipFile, LookupError) as e:\n            message.error(\n                \"hostblock: Error while reading {}: {} - {}\".format(\n                    byte_io.name, e.__class__.__name__, e\n                )\n            )\n            return\n\n        for line in f:\n            line_count += 1\n            try:\n                self._blocked_hosts |= self._read_hosts_line(line)\n            except UnicodeDecodeError:\n                logger.error(\"Failed to decode: {!r}\".format(line))\n                error_count += 1\n\n        logger.debug(\"{}: read {} lines\".format(byte_io.name, line_count))\n        if error_count > 0:\n            message.error(\n                \"hostblock: {} read errors for {}\".format(error_count, byte_io.name)\n            )\n\n    def _on_lists_downloaded(self, done_count: int) -> None:\n        \"\"\"Install block lists after files have been downloaded.\"\"\"\n        try:\n            with open(self._local_hosts_file, \"w\", encoding=\"utf-8\") as f:\n                for host in sorted(self._blocked_hosts):\n                    f.write(host + \"\\n\")\n                message.info(\n                    \"hostblock: Read {} hosts from {} sources.\".format(\n                        len(self._blocked_hosts), done_count\n                    )\n                )\n        except OSError:\n            logger.exception(\"Failed to write host block list!\")\n\n    def update_files(self) -> None:\n        \"\"\"Update files when the config changed.\"\"\"\n        if not config.val.content.blocking.hosts.lists:\n            try:\n                os.remove(self._local_hosts_file)\n            except FileNotFoundError:\n                pass\n            except OSError as e:\n                logger.exception(\"Failed to delete hosts file: {}\".format(e))\n\n\n@hook.config_changed(\"content.blocking.hosts.lists\")\ndef on_lists_changed() -> None:\n    host_blocker.update_files()\n\n\n@hook.config_changed(\"content.blocking.method\")\ndef on_method_changed() -> None:\n    host_blocker.enabled = _should_be_used()\n\n\n@hook.init()\ndef init(context: apitypes.InitContext) -> None:\n    \"\"\"Initialize the host blocker.\"\"\"\n    global host_blocker\n    host_blocker = HostBlocker(\n        data_dir=context.data_dir,\n        config_dir=context.config_dir,\n        has_basedir=context.args.basedir is not None,\n    )\n    host_blocker.read_hosts()\n    interceptor.register(host_blocker.filter_request)\n",
              "additions": 26,
              "deletions": 4
            },
            {
              "file": "qutebrowser/utils/urlutils.py",
              "before": "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n\n# Copyright 2014-2021 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n#\n# This file is part of qutebrowser.\n#\n# qutebrowser is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# qutebrowser is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with qutebrowser.  If not, see <https://www.gnu.org/licenses/>.\n\n\"\"\"Utils regarding URL handling.\"\"\"\n\nimport re\nimport base64\nimport os.path\nimport ipaddress\nimport posixpath\nimport urllib.parse\nimport mimetypes\nfrom typing import Optional, Tuple, Union\n\nfrom PyQt5.QtCore import QUrl\nfrom PyQt5.QtNetwork import QHostInfo, QHostAddress, QNetworkProxy\n\nfrom qutebrowser.api import cmdutils\nfrom qutebrowser.config import config\nfrom qutebrowser.utils import log, qtutils, message, utils\nfrom qutebrowser.browser.network import pac\n\n\n# FIXME: we probably could raise some exceptions on invalid URLs\n# https://github.com/qutebrowser/qutebrowser/issues/108\n\n\n# URL schemes supported by QtWebEngine\nWEBENGINE_SCHEMES = [\n    'about',\n    'data',\n    'file',\n    'filesystem',\n    'ftp',\n    'http',\n    'https',\n    'javascript',\n    'ws',\n    'wss',\n]\n\n\nclass Error(Exception):\n\n    \"\"\"Base class for errors in this module.\"\"\"\n\n\nclass InvalidUrlError(Error):\n\n    \"\"\"Error raised if a function got an invalid URL.\"\"\"\n\n    def __init__(self, url: QUrl) -> None:\n        if url.isValid():\n            raise ValueError(\"Got valid URL {}!\".format(url.toDisplayString()))\n        self.url = url\n        self.msg = get_errstring(url)\n        super().__init__(self.msg)\n\n\ndef _parse_search_term(s: str) -> Tuple[Optional[str], Optional[str]]:\n    \"\"\"Get a search engine name and search term from a string.\n\n    Args:\n        s: The string to get a search engine for.\n\n    Return:\n        A (engine, term) tuple, where engine is None for the default engine.\n    \"\"\"\n    s = s.strip()\n    split = s.split(maxsplit=1)\n    if not split:\n        raise ValueError(\"Empty search term!\")\n\n    if len(split) == 2:\n        if split[0] in config.val.url.searchengines:\n            engine: Optional[str] = split[0]\n            term: Optional[str] = split[1]\n        else:\n            engine = None\n            term = s\n    else:\n        if config.val.url.open_base_url and s in config.val.url.searchengines:\n            engine = s\n            term = None\n        else:\n            engine = None\n            term = s\n\n    log.url.debug(\"engine {}, term {!r}\".format(engine, term))\n    return (engine, term)\n\n\ndef _get_search_url(txt: str) -> QUrl:\n    \"\"\"Get a search engine URL for a text.\n\n    Args:\n        txt: Text to search for.\n\n    Return:\n        The search URL as a QUrl.\n    \"\"\"\n    log.url.debug(\"Finding search engine for {!r}\".format(txt))\n    engine, term = _parse_search_term(txt)\n    if not engine:\n        engine = 'DEFAULT'\n    if term:\n        template = config.val.url.searchengines[engine]\n        semiquoted_term = urllib.parse.quote(term)\n        quoted_term = urllib.parse.quote(term, safe='')\n        evaluated = template.format(semiquoted_term,\n                                    unquoted=term,\n                                    quoted=quoted_term,\n                                    semiquoted=semiquoted_term)\n        url = QUrl.fromUserInput(evaluated)\n    else:\n        url = QUrl.fromUserInput(config.val.url.searchengines[engine])\n        url.setPath(None)  # type: ignore[arg-type]\n        url.setFragment(None)  # type: ignore[arg-type]\n        url.setQuery(None)  # type: ignore[call-overload]\n    qtutils.ensure_valid(url)\n    return url\n\n\ndef _is_url_naive(urlstr: str) -> bool:\n    \"\"\"Naive check if given URL is really a URL.\n\n    Args:\n        urlstr: The URL to check for, as string.\n\n    Return:\n        True if the URL really is a URL, False otherwise.\n    \"\"\"\n    url = QUrl.fromUserInput(urlstr)\n    assert url.isValid()\n    host = url.host()\n\n    # Valid IPv4/IPv6 address. Qt converts things like \"23.42\" or \"1337\" or\n    # \"0xDEAD\" to IP addresses, which we don't like, so we check if the host\n    # from Qt is part of the input.\n    if (not utils.raises(ValueError, ipaddress.ip_address, host) and\n            host in urlstr):\n        return True\n\n    tld = r'\\.([^.0-9_-]+|xn--[a-z0-9-]+)$'\n    forbidden = r'[\\u0000-\\u002c\\u002f\\u003a-\\u0060\\u007b-\\u00b6]'\n    return bool(re.search(tld, host) and not re.search(forbidden, host))\n\n\ndef _is_url_dns(urlstr: str) -> bool:\n    \"\"\"Check if a URL is really a URL via DNS.\n\n    Args:\n        url: The URL to check for as a string.\n\n    Return:\n        True if the URL really is a URL, False otherwise.\n    \"\"\"\n    url = QUrl.fromUserInput(urlstr)\n    assert url.isValid()\n\n    if (utils.raises(ValueError, ipaddress.ip_address, urlstr) and\n            not QHostAddress(urlstr).isNull()):\n        log.url.debug(\"Bogus IP URL -> False\")\n        # Qt treats things like \"23.42\" or \"1337\" or \"0xDEAD\" as valid URLs\n        # which we don't want to.\n        return False\n\n    host = url.host()\n    if not host:\n        log.url.debug(\"URL has no host -> False\")\n        return False\n    log.url.debug(\"Doing DNS request for {}\".format(host))\n    info = QHostInfo.fromName(host)\n    return not info.error()\n\n\ndef fuzzy_url(urlstr: str,\n              cwd: str = None,\n              relative: bool = False,\n              do_search: bool = True,\n              force_search: bool = False) -> QUrl:\n    \"\"\"Get a QUrl based on a user input which is URL or search term.\n\n    Args:\n        urlstr: URL to load as a string.\n        cwd: The current working directory, or None.\n        relative: Whether to resolve relative files.\n        do_search: Whether to perform a search on non-URLs.\n        force_search: Whether to force a search even if the content can be\n                      interpreted as a URL or a path.\n\n    Return:\n        A target QUrl to a search page or the original URL.\n    \"\"\"\n    urlstr = urlstr.strip()\n    path = get_path_if_valid(urlstr, cwd=cwd, relative=relative,\n                             check_exists=True)\n\n    if not force_search and path is not None:\n        url = QUrl.fromLocalFile(path)\n    elif force_search or (do_search and not is_url(urlstr)):\n        # probably a search term\n        log.url.debug(\"URL is a fuzzy search term\")\n        try:\n            url = _get_search_url(urlstr)\n        except ValueError:  # invalid search engine\n            url = QUrl.fromUserInput(urlstr)\n    else:  # probably an address\n        log.url.debug(\"URL is a fuzzy address\")\n        url = QUrl.fromUserInput(urlstr)\n    log.url.debug(\"Converting fuzzy term {!r} to URL -> {}\".format(\n        urlstr, url.toDisplayString()))\n    ensure_valid(url)\n    return url\n\n\ndef _has_explicit_scheme(url: QUrl) -> bool:\n    \"\"\"Check if a url has an explicit scheme given.\n\n    Args:\n        url: The URL as QUrl.\n    \"\"\"\n    # Note that generic URI syntax actually would allow a second colon\n    # after the scheme delimiter. Since we don't know of any URIs\n    # using this and want to support e.g. searching for scoped C++\n    # symbols, we treat this as not a URI anyways.\n    return bool(url.isValid() and url.scheme() and\n                (url.host() or url.path()) and\n                not url.path().startswith(':'))\n\n\ndef is_special_url(url: QUrl) -> bool:\n    \"\"\"Return True if url is an about:... or other special URL.\n\n    Args:\n        url: The URL as QUrl.\n    \"\"\"\n    if not url.isValid():\n        return False\n    special_schemes = ('about', 'qute', 'file')\n    return url.scheme() in special_schemes\n\n\ndef is_url(urlstr: str) -> bool:\n    \"\"\"Check if url seems to be a valid URL.\n\n    Args:\n        urlstr: The URL as string.\n\n    Return:\n        True if it is a valid URL, False otherwise.\n    \"\"\"\n    autosearch = config.val.url.auto_search\n\n    log.url.debug(\"Checking if {!r} is a URL (autosearch={}).\".format(\n        urlstr, autosearch))\n\n    urlstr = urlstr.strip()\n    qurl = QUrl(urlstr)\n    qurl_userinput = QUrl.fromUserInput(urlstr)\n\n    if autosearch == 'never':\n        # no autosearch, so everything is a URL unless it has an explicit\n        # search engine.\n        try:\n            engine, _term = _parse_search_term(urlstr)\n        except ValueError:\n            return False\n        else:\n            return engine is None\n\n    if not qurl_userinput.isValid():\n        # This will also catch non-URLs containing spaces.\n        return False\n\n    if _has_explicit_scheme(qurl) and ' ' not in urlstr:\n        # URLs with explicit schemes are always URLs\n        log.url.debug(\"Contains explicit scheme\")\n        url = True\n    elif (autosearch == 'schemeless' and\n          (not _has_explicit_scheme(qurl) or ' ' in urlstr)):\n        # When autosearch=schemeless, URLs must contain schemes to be valid\n        log.url.debug(\"No explicit scheme in given URL, treating as non-URL\")\n        url = False\n    elif qurl_userinput.host() in ['localhost', '127.0.0.1', '::1']:\n        log.url.debug(\"Is localhost.\")\n        url = True\n    elif is_special_url(qurl):\n        # Special URLs are always URLs, even with autosearch=never\n        log.url.debug(\"Is a special URL.\")\n        url = True\n    elif autosearch == 'dns':\n        log.url.debug(\"Checking via DNS check\")\n        # We want to use QUrl.fromUserInput here, as the user might enter\n        # \"foo.de\" and that should be treated as URL here.\n        url = ' ' not in qurl_userinput.userName() and _is_url_dns(urlstr)\n    elif autosearch == 'naive':\n        log.url.debug(\"Checking via naive check\")\n        url = ' ' not in qurl_userinput.userName() and _is_url_naive(urlstr)\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid autosearch value\")\n    log.url.debug(\"url = {}\".format(url))\n    return url\n\n\ndef ensure_valid(url: QUrl) -> None:\n    if not url.isValid():\n        raise InvalidUrlError(url)\n\n\ndef invalid_url_error(url: QUrl, action: str) -> None:\n    \"\"\"Display an error message for a URL.\n\n    Args:\n        action: The action which was interrupted by the error.\n    \"\"\"\n    if url.isValid():\n        raise ValueError(\"Calling invalid_url_error with valid URL {}\".format(\n            url.toDisplayString()))\n    errstring = get_errstring(\n        url, \"Trying to {} with invalid URL\".format(action))\n    message.error(errstring)\n\n\ndef raise_cmdexc_if_invalid(url: QUrl) -> None:\n    \"\"\"Check if the given QUrl is invalid, and if so, raise a CommandError.\"\"\"\n    try:\n        ensure_valid(url)\n    except InvalidUrlError as e:\n        raise cmdutils.CommandError(str(e))\n\n\ndef get_path_if_valid(pathstr: str,\n                      cwd: str = None,\n                      relative: bool = False,\n                      check_exists: bool = False) -> Optional[str]:\n    \"\"\"Check if path is a valid path.\n\n    Args:\n        pathstr: The path as string.\n        cwd: The current working directory, or None.\n        relative: Whether to resolve relative files.\n        check_exists: Whether to check if the file\n                      actually exists of filesystem.\n\n    Return:\n        The path if it is a valid path, None otherwise.\n    \"\"\"\n    pathstr = pathstr.strip()\n    log.url.debug(\"Checking if {!r} is a path\".format(pathstr))\n    expanded = os.path.expanduser(pathstr)\n\n    if os.path.isabs(expanded):\n        path: Optional[str] = expanded\n    elif relative and cwd:\n        path = os.path.join(cwd, expanded)\n    elif relative:\n        try:\n            path = os.path.abspath(expanded)\n        except OSError:\n            path = None\n    else:\n        path = None\n\n    if check_exists:\n        if path is not None:\n            try:\n                if os.path.exists(path):\n                    log.url.debug(\"URL is a local file\")\n                else:\n                    path = None\n            except UnicodeEncodeError:\n                log.url.debug(\n                    \"URL contains characters which are not present in the \"\n                    \"current locale\")\n                path = None\n\n    return path\n\n\ndef filename_from_url(url: QUrl, fallback: str = None) -> Optional[str]:\n    \"\"\"Get a suitable filename from a URL.\n\n    Args:\n        url: The URL to parse, as a QUrl.\n        fallback: Value to use if no name can be determined.\n\n    Return:\n        The suggested filename as a string, or None.\n    \"\"\"\n    if not url.isValid():\n        return fallback\n\n    if url.scheme().lower() == 'data':\n        mimetype, _encoding = mimetypes.guess_type(url.toString())\n        if not mimetype:\n            return fallback\n\n        ext = utils.mimetype_extension(mimetype) or ''\n        return 'download' + ext\n\n    pathname = posixpath.basename(url.path())\n    if pathname:\n        return pathname\n    elif url.host():\n        return url.host() + '.html'\n    else:\n        return fallback\n\n\nHostTupleType = Tuple[str, str, int]\n\n\ndef host_tuple(url: QUrl) -> HostTupleType:\n    \"\"\"Get a (scheme, host, port) tuple from a QUrl.\n\n    This is suitable to identify a connection, e.g. for SSL errors.\n    \"\"\"\n    ensure_valid(url)\n    scheme, host, port = url.scheme(), url.host(), url.port()\n    assert scheme\n    if not host:\n        raise ValueError(\"Got URL {} without host.\".format(\n            url.toDisplayString()))\n    if port == -1:\n        port_mapping = {\n            'http': 80,\n            'https': 443,\n            'ftp': 21,\n        }\n        try:\n            port = port_mapping[scheme]\n        except KeyError:\n            raise ValueError(\"Got URL {} with unknown port.\".format(\n                url.toDisplayString()))\n    return scheme, host, port\n\n\ndef get_errstring(url: QUrl, base: str = \"Invalid URL\") -> str:\n    \"\"\"Get an error string for a URL.\n\n    Args:\n        url: The URL as a QUrl.\n        base: The base error string.\n\n    Return:\n        A new string with url.errorString() is appended if available.\n    \"\"\"\n    url_error = url.errorString()\n    if url_error:\n        return base + \" - {}\".format(url_error)\n    else:\n        return base\n\n\ndef same_domain(url1: QUrl, url2: QUrl) -> bool:\n    \"\"\"Check if url1 and url2 belong to the same website.\n\n    This will use a \"public suffix list\" to determine what a \"top level domain\"\n    is. All further domains are ignored.\n\n    For example example.com and www.example.com are considered the same. but\n    example.co.uk and test.co.uk are not.\n\n    If the URL's schemes or ports are different, they are always treated as not equal.\n\n    Return:\n        True if the domains are the same, False otherwise.\n    \"\"\"\n    ensure_valid(url1)\n    ensure_valid(url2)\n\n    if url1.scheme() != url2.scheme():\n        return False\n    if url1.port() != url2.port():\n        return False\n\n    suffix1 = url1.topLevelDomain()\n    suffix2 = url2.topLevelDomain()\n    if not suffix1:\n        return url1.host() == url2.host()\n\n    if suffix1 != suffix2:\n        return False\n\n    domain1 = url1.host()[:-len(suffix1)].split('.')[-1]\n    domain2 = url2.host()[:-len(suffix2)].split('.')[-1]\n    return domain1 == domain2\n\n\ndef encoded_url(url: QUrl) -> str:\n    \"\"\"Return the fully encoded url as string.\n\n    Args:\n        url: The url to encode as QUrl.\n    \"\"\"\n    return url.toEncoded().data().decode('ascii')\n\n\ndef file_url(path: str) -> str:\n    \"\"\"Return a file:// url (as string) to the given local path.\n\n    Arguments:\n        path: The absolute path to the local file\n    \"\"\"\n    url = QUrl.fromLocalFile(path)\n    return url.toString(QUrl.FullyEncoded)  # type: ignore[arg-type]\n\n\ndef data_url(mimetype: str, data: bytes) -> QUrl:\n    \"\"\"Get a data: QUrl for the given data.\"\"\"\n    b64 = base64.b64encode(data).decode('ascii')\n    url = QUrl('data:{};base64,{}'.format(mimetype, b64))\n    qtutils.ensure_valid(url)\n    return url\n\n\ndef safe_display_string(qurl: QUrl) -> str:\n    \"\"\"Get a IDN-homograph phishing safe form of the given QUrl.\n\n    If we're dealing with a Punycode-encoded URL, this prepends the hostname in\n    its encoded form, to make sure those URLs are distinguishable.\n\n    See https://github.com/qutebrowser/qutebrowser/issues/2547\n    and https://bugreports.qt.io/browse/QTBUG-60365\n    \"\"\"\n    ensure_valid(qurl)\n\n    host = qurl.host(QUrl.FullyEncoded)\n    assert '..' not in host, qurl  # https://bugreports.qt.io/browse/QTBUG-60364\n\n    for part in host.split('.'):\n        url_host = qurl.host(QUrl.FullyDecoded)\n        if part.startswith('xn--') and host != url_host:\n            return '({}) {}'.format(host, qurl.toDisplayString())\n\n    return qurl.toDisplayString()\n\n\nclass InvalidProxyTypeError(Exception):\n\n    \"\"\"Error raised when proxy_from_url gets an unknown proxy type.\"\"\"\n\n    def __init__(self, typ: str) -> None:\n        super().__init__(\"Invalid proxy type {}!\".format(typ))\n\n\ndef proxy_from_url(url: QUrl) -> Union[QNetworkProxy, pac.PACFetcher]:\n    \"\"\"Create a QNetworkProxy from QUrl and a proxy type.\n\n    Args:\n        url: URL of a proxy (possibly with credentials).\n\n    Return:\n        New QNetworkProxy.\n    \"\"\"\n    ensure_valid(url)\n\n    scheme = url.scheme()\n    if scheme in ['pac+http', 'pac+https', 'pac+file']:\n        fetcher = pac.PACFetcher(url)\n        fetcher.fetch()\n        return fetcher\n\n    types = {\n        'http': QNetworkProxy.HttpProxy,\n        'socks': QNetworkProxy.Socks5Proxy,\n        'socks5': QNetworkProxy.Socks5Proxy,\n        'direct': QNetworkProxy.NoProxy,\n    }\n    if scheme not in types:\n        raise InvalidProxyTypeError(scheme)\n\n    proxy = QNetworkProxy(types[scheme], url.host())\n\n    if url.port() != -1:\n        proxy.setPort(url.port())\n    if url.userName():\n        proxy.setUser(url.userName())\n    if url.password():\n        proxy.setPassword(url.password())\n    return proxy\n\n\ndef parse_javascript_url(url: QUrl) -> str:\n    \"\"\"Get JavaScript source from the given URL.\n\n    See https://wiki.whatwg.org/wiki/URL_schemes#javascript:_URLs\n    and https://github.com/whatwg/url/issues/385\n    \"\"\"\n    ensure_valid(url)\n    if url.scheme() != 'javascript':\n        raise Error(\"Expected a javascript:... URL\")\n    if url.authority():\n        raise Error(\"URL contains unexpected components: {}\"\n                    .format(url.authority()))\n\n    urlstr = url.toString(QUrl.FullyEncoded)  # type: ignore[arg-type]\n    urlstr = urllib.parse.unquote(urlstr)\n\n    code = urlstr[len('javascript:'):]\n    if not code:\n        raise Error(\"Resulted in empty JavaScript code\")\n\n    return code\n",
              "after": "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n\n# Copyright 2014-2021 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n#\n# This file is part of qutebrowser.\n#\n# qutebrowser is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# qutebrowser is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with qutebrowser.  If not, see <https://www.gnu.org/licenses/>.\n\n\"\"\"Utils regarding URL handling.\"\"\"\n\nimport re\nimport base64\nimport os.path\nimport ipaddress\nimport posixpath\nimport urllib.parse\nimport mimetypes\nfrom typing import Iterator, Optional, Tuple, Union\n\nfrom PyQt5.QtCore import QUrl\nfrom PyQt5.QtNetwork import QHostInfo, QHostAddress, QNetworkProxy\n\nfrom qutebrowser.api import cmdutils\nfrom qutebrowser.config import config\nfrom qutebrowser.utils import log, qtutils, message, utils\nfrom qutebrowser.browser.network import pac\n\n\n# FIXME: we probably could raise some exceptions on invalid URLs\n# https://github.com/qutebrowser/qutebrowser/issues/108\n\n\n# URL schemes supported by QtWebEngine\nWEBENGINE_SCHEMES = [\n    'about',\n    'data',\n    'file',\n    'filesystem',\n    'ftp',\n    'http',\n    'https',\n    'javascript',\n    'ws',\n    'wss',\n]\n\n\nclass Error(Exception):\n\n    \"\"\"Base class for errors in this module.\"\"\"\n\n\nclass InvalidUrlError(Error):\n\n    \"\"\"Error raised if a function got an invalid URL.\"\"\"\n\n    def __init__(self, url: QUrl) -> None:\n        if url.isValid():\n            raise ValueError(\"Got valid URL {}!\".format(url.toDisplayString()))\n        self.url = url\n        self.msg = get_errstring(url)\n        super().__init__(self.msg)\n\n\ndef _parse_search_term(s: str) -> Tuple[Optional[str], Optional[str]]:\n    \"\"\"Get a search engine name and search term from a string.\n\n    Args:\n        s: The string to get a search engine for.\n\n    Return:\n        A (engine, term) tuple, where engine is None for the default engine.\n    \"\"\"\n    s = s.strip()\n    split = s.split(maxsplit=1)\n    if not split:\n        raise ValueError(\"Empty search term!\")\n\n    if len(split) == 2:\n        if split[0] in config.val.url.searchengines:\n            engine: Optional[str] = split[0]\n            term: Optional[str] = split[1]\n        else:\n            engine = None\n            term = s\n    else:\n        if config.val.url.open_base_url and s in config.val.url.searchengines:\n            engine = s\n            term = None\n        else:\n            engine = None\n            term = s\n\n    log.url.debug(\"engine {}, term {!r}\".format(engine, term))\n    return (engine, term)\n\n\ndef _get_search_url(txt: str) -> QUrl:\n    \"\"\"Get a search engine URL for a text.\n\n    Args:\n        txt: Text to search for.\n\n    Return:\n        The search URL as a QUrl.\n    \"\"\"\n    log.url.debug(\"Finding search engine for {!r}\".format(txt))\n    engine, term = _parse_search_term(txt)\n    if not engine:\n        engine = 'DEFAULT'\n    if term:\n        template = config.val.url.searchengines[engine]\n        semiquoted_term = urllib.parse.quote(term)\n        quoted_term = urllib.parse.quote(term, safe='')\n        evaluated = template.format(semiquoted_term,\n                                    unquoted=term,\n                                    quoted=quoted_term,\n                                    semiquoted=semiquoted_term)\n        url = QUrl.fromUserInput(evaluated)\n    else:\n        url = QUrl.fromUserInput(config.val.url.searchengines[engine])\n        url.setPath(None)  # type: ignore[arg-type]\n        url.setFragment(None)  # type: ignore[arg-type]\n        url.setQuery(None)  # type: ignore[call-overload]\n    qtutils.ensure_valid(url)\n    return url\n\n\ndef _is_url_naive(urlstr: str) -> bool:\n    \"\"\"Naive check if given URL is really a URL.\n\n    Args:\n        urlstr: The URL to check for, as string.\n\n    Return:\n        True if the URL really is a URL, False otherwise.\n    \"\"\"\n    url = QUrl.fromUserInput(urlstr)\n    assert url.isValid()\n    host = url.host()\n\n    # Valid IPv4/IPv6 address. Qt converts things like \"23.42\" or \"1337\" or\n    # \"0xDEAD\" to IP addresses, which we don't like, so we check if the host\n    # from Qt is part of the input.\n    if (not utils.raises(ValueError, ipaddress.ip_address, host) and\n            host in urlstr):\n        return True\n\n    tld = r'\\.([^.0-9_-]+|xn--[a-z0-9-]+)$'\n    forbidden = r'[\\u0000-\\u002c\\u002f\\u003a-\\u0060\\u007b-\\u00b6]'\n    return bool(re.search(tld, host) and not re.search(forbidden, host))\n\n\ndef _is_url_dns(urlstr: str) -> bool:\n    \"\"\"Check if a URL is really a URL via DNS.\n\n    Args:\n        url: The URL to check for as a string.\n\n    Return:\n        True if the URL really is a URL, False otherwise.\n    \"\"\"\n    url = QUrl.fromUserInput(urlstr)\n    assert url.isValid()\n\n    if (utils.raises(ValueError, ipaddress.ip_address, urlstr) and\n            not QHostAddress(urlstr).isNull()):\n        log.url.debug(\"Bogus IP URL -> False\")\n        # Qt treats things like \"23.42\" or \"1337\" or \"0xDEAD\" as valid URLs\n        # which we don't want to.\n        return False\n\n    host = url.host()\n    if not host:\n        log.url.debug(\"URL has no host -> False\")\n        return False\n    log.url.debug(\"Doing DNS request for {}\".format(host))\n    info = QHostInfo.fromName(host)\n    return not info.error()\n\n\ndef fuzzy_url(urlstr: str,\n              cwd: str = None,\n              relative: bool = False,\n              do_search: bool = True,\n              force_search: bool = False) -> QUrl:\n    \"\"\"Get a QUrl based on a user input which is URL or search term.\n\n    Args:\n        urlstr: URL to load as a string.\n        cwd: The current working directory, or None.\n        relative: Whether to resolve relative files.\n        do_search: Whether to perform a search on non-URLs.\n        force_search: Whether to force a search even if the content can be\n                      interpreted as a URL or a path.\n\n    Return:\n        A target QUrl to a search page or the original URL.\n    \"\"\"\n    urlstr = urlstr.strip()\n    path = get_path_if_valid(urlstr, cwd=cwd, relative=relative,\n                             check_exists=True)\n\n    if not force_search and path is not None:\n        url = QUrl.fromLocalFile(path)\n    elif force_search or (do_search and not is_url(urlstr)):\n        # probably a search term\n        log.url.debug(\"URL is a fuzzy search term\")\n        try:\n            url = _get_search_url(urlstr)\n        except ValueError:  # invalid search engine\n            url = QUrl.fromUserInput(urlstr)\n    else:  # probably an address\n        log.url.debug(\"URL is a fuzzy address\")\n        url = QUrl.fromUserInput(urlstr)\n    log.url.debug(\"Converting fuzzy term {!r} to URL -> {}\".format(\n        urlstr, url.toDisplayString()))\n    ensure_valid(url)\n    return url\n\n\ndef _has_explicit_scheme(url: QUrl) -> bool:\n    \"\"\"Check if a url has an explicit scheme given.\n\n    Args:\n        url: The URL as QUrl.\n    \"\"\"\n    # Note that generic URI syntax actually would allow a second colon\n    # after the scheme delimiter. Since we don't know of any URIs\n    # using this and want to support e.g. searching for scoped C++\n    # symbols, we treat this as not a URI anyways.\n    return bool(url.isValid() and url.scheme() and\n                (url.host() or url.path()) and\n                not url.path().startswith(':'))\n\n\ndef is_special_url(url: QUrl) -> bool:\n    \"\"\"Return True if url is an about:... or other special URL.\n\n    Args:\n        url: The URL as QUrl.\n    \"\"\"\n    if not url.isValid():\n        return False\n    special_schemes = ('about', 'qute', 'file')\n    return url.scheme() in special_schemes\n\n\ndef is_url(urlstr: str) -> bool:\n    \"\"\"Check if url seems to be a valid URL.\n\n    Args:\n        urlstr: The URL as string.\n\n    Return:\n        True if it is a valid URL, False otherwise.\n    \"\"\"\n    autosearch = config.val.url.auto_search\n\n    log.url.debug(\"Checking if {!r} is a URL (autosearch={}).\".format(\n        urlstr, autosearch))\n\n    urlstr = urlstr.strip()\n    qurl = QUrl(urlstr)\n    qurl_userinput = QUrl.fromUserInput(urlstr)\n\n    if autosearch == 'never':\n        # no autosearch, so everything is a URL unless it has an explicit\n        # search engine.\n        try:\n            engine, _term = _parse_search_term(urlstr)\n        except ValueError:\n            return False\n        else:\n            return engine is None\n\n    if not qurl_userinput.isValid():\n        # This will also catch non-URLs containing spaces.\n        return False\n\n    if _has_explicit_scheme(qurl) and ' ' not in urlstr:\n        # URLs with explicit schemes are always URLs\n        log.url.debug(\"Contains explicit scheme\")\n        url = True\n    elif (autosearch == 'schemeless' and\n          (not _has_explicit_scheme(qurl) or ' ' in urlstr)):\n        # When autosearch=schemeless, URLs must contain schemes to be valid\n        log.url.debug(\"No explicit scheme in given URL, treating as non-URL\")\n        url = False\n    elif qurl_userinput.host() in ['localhost', '127.0.0.1', '::1']:\n        log.url.debug(\"Is localhost.\")\n        url = True\n    elif is_special_url(qurl):\n        # Special URLs are always URLs, even with autosearch=never\n        log.url.debug(\"Is a special URL.\")\n        url = True\n    elif autosearch == 'dns':\n        log.url.debug(\"Checking via DNS check\")\n        # We want to use QUrl.fromUserInput here, as the user might enter\n        # \"foo.de\" and that should be treated as URL here.\n        url = ' ' not in qurl_userinput.userName() and _is_url_dns(urlstr)\n    elif autosearch == 'naive':\n        log.url.debug(\"Checking via naive check\")\n        url = ' ' not in qurl_userinput.userName() and _is_url_naive(urlstr)\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid autosearch value\")\n    log.url.debug(\"url = {}\".format(url))\n    return url\n\n\ndef ensure_valid(url: QUrl) -> None:\n    if not url.isValid():\n        raise InvalidUrlError(url)\n\n\ndef invalid_url_error(url: QUrl, action: str) -> None:\n    \"\"\"Display an error message for a URL.\n\n    Args:\n        action: The action which was interrupted by the error.\n    \"\"\"\n    if url.isValid():\n        raise ValueError(\"Calling invalid_url_error with valid URL {}\".format(\n            url.toDisplayString()))\n    errstring = get_errstring(\n        url, \"Trying to {} with invalid URL\".format(action))\n    message.error(errstring)\n\n\ndef raise_cmdexc_if_invalid(url: QUrl) -> None:\n    \"\"\"Check if the given QUrl is invalid, and if so, raise a CommandError.\"\"\"\n    try:\n        ensure_valid(url)\n    except InvalidUrlError as e:\n        raise cmdutils.CommandError(str(e))\n\n\ndef get_path_if_valid(pathstr: str,\n                      cwd: str = None,\n                      relative: bool = False,\n                      check_exists: bool = False) -> Optional[str]:\n    \"\"\"Check if path is a valid path.\n\n    Args:\n        pathstr: The path as string.\n        cwd: The current working directory, or None.\n        relative: Whether to resolve relative files.\n        check_exists: Whether to check if the file\n                      actually exists of filesystem.\n\n    Return:\n        The path if it is a valid path, None otherwise.\n    \"\"\"\n    pathstr = pathstr.strip()\n    log.url.debug(\"Checking if {!r} is a path\".format(pathstr))\n    expanded = os.path.expanduser(pathstr)\n\n    if os.path.isabs(expanded):\n        path: Optional[str] = expanded\n    elif relative and cwd:\n        path = os.path.join(cwd, expanded)\n    elif relative:\n        try:\n            path = os.path.abspath(expanded)\n        except OSError:\n            path = None\n    else:\n        path = None\n\n    if check_exists:\n        if path is not None:\n            try:\n                if os.path.exists(path):\n                    log.url.debug(\"URL is a local file\")\n                else:\n                    path = None\n            except UnicodeEncodeError:\n                log.url.debug(\n                    \"URL contains characters which are not present in the \"\n                    \"current locale\")\n                path = None\n\n    return path\n\n\ndef filename_from_url(url: QUrl, fallback: str = None) -> Optional[str]:\n    \"\"\"Get a suitable filename from a URL.\n\n    Args:\n        url: The URL to parse, as a QUrl.\n        fallback: Value to use if no name can be determined.\n\n    Return:\n        The suggested filename as a string, or None.\n    \"\"\"\n    if not url.isValid():\n        return fallback\n\n    if url.scheme().lower() == 'data':\n        mimetype, _encoding = mimetypes.guess_type(url.toString())\n        if not mimetype:\n            return fallback\n\n        ext = utils.mimetype_extension(mimetype) or ''\n        return 'download' + ext\n\n    pathname = posixpath.basename(url.path())\n    if pathname:\n        return pathname\n    elif url.host():\n        return url.host() + '.html'\n    else:\n        return fallback\n\n\nHostTupleType = Tuple[str, str, int]\n\n\ndef host_tuple(url: QUrl) -> HostTupleType:\n    \"\"\"Get a (scheme, host, port) tuple from a QUrl.\n\n    This is suitable to identify a connection, e.g. for SSL errors.\n    \"\"\"\n    ensure_valid(url)\n    scheme, host, port = url.scheme(), url.host(), url.port()\n    assert scheme\n    if not host:\n        raise ValueError(\"Got URL {} without host.\".format(\n            url.toDisplayString()))\n    if port == -1:\n        port_mapping = {\n            'http': 80,\n            'https': 443,\n            'ftp': 21,\n        }\n        try:\n            port = port_mapping[scheme]\n        except KeyError:\n            raise ValueError(\"Got URL {} with unknown port.\".format(\n                url.toDisplayString()))\n    return scheme, host, port\n\n\ndef get_errstring(url: QUrl, base: str = \"Invalid URL\") -> str:\n    \"\"\"Get an error string for a URL.\n\n    Args:\n        url: The URL as a QUrl.\n        base: The base error string.\n\n    Return:\n        A new string with url.errorString() is appended if available.\n    \"\"\"\n    url_error = url.errorString()\n    if url_error:\n        return base + \" - {}\".format(url_error)\n    else:\n        return base\n\n\ndef same_domain(url1: QUrl, url2: QUrl) -> bool:\n    \"\"\"Check if url1 and url2 belong to the same website.\n\n    This will use a \"public suffix list\" to determine what a \"top level domain\"\n    is. All further domains are ignored.\n\n    For example example.com and www.example.com are considered the same. but\n    example.co.uk and test.co.uk are not.\n\n    If the URL's schemes or ports are different, they are always treated as not equal.\n\n    Return:\n        True if the domains are the same, False otherwise.\n    \"\"\"\n    ensure_valid(url1)\n    ensure_valid(url2)\n\n    if url1.scheme() != url2.scheme():\n        return False\n    if url1.port() != url2.port():\n        return False\n\n    suffix1 = url1.topLevelDomain()\n    suffix2 = url2.topLevelDomain()\n    if not suffix1:\n        return url1.host() == url2.host()\n\n    if suffix1 != suffix2:\n        return False\n\n    domain1 = url1.host()[:-len(suffix1)].split('.')[-1]\n    domain2 = url2.host()[:-len(suffix2)].split('.')[-1]\n    return domain1 == domain2\n\n\ndef encoded_url(url: QUrl) -> str:\n    \"\"\"Return the fully encoded url as string.\n\n    Args:\n        url: The url to encode as QUrl.\n    \"\"\"\n    return url.toEncoded().data().decode('ascii')\n\n\ndef file_url(path: str) -> str:\n    \"\"\"Return a file:// url (as string) to the given local path.\n\n    Arguments:\n        path: The absolute path to the local file\n    \"\"\"\n    url = QUrl.fromLocalFile(path)\n    return url.toString(QUrl.FullyEncoded)  # type: ignore[arg-type]\n\n\ndef data_url(mimetype: str, data: bytes) -> QUrl:\n    \"\"\"Get a data: QUrl for the given data.\"\"\"\n    b64 = base64.b64encode(data).decode('ascii')\n    url = QUrl('data:{};base64,{}'.format(mimetype, b64))\n    qtutils.ensure_valid(url)\n    return url\n\n\ndef safe_display_string(qurl: QUrl) -> str:\n    \"\"\"Get a IDN-homograph phishing safe form of the given QUrl.\n\n    If we're dealing with a Punycode-encoded URL, this prepends the hostname in\n    its encoded form, to make sure those URLs are distinguishable.\n\n    See https://github.com/qutebrowser/qutebrowser/issues/2547\n    and https://bugreports.qt.io/browse/QTBUG-60365\n    \"\"\"\n    ensure_valid(qurl)\n\n    host = qurl.host(QUrl.FullyEncoded)\n    assert '..' not in host, qurl  # https://bugreports.qt.io/browse/QTBUG-60364\n\n    for part in host.split('.'):\n        url_host = qurl.host(QUrl.FullyDecoded)\n        if part.startswith('xn--') and host != url_host:\n            return '({}) {}'.format(host, qurl.toDisplayString())\n\n    return qurl.toDisplayString()\n\n\nclass InvalidProxyTypeError(Exception):\n\n    \"\"\"Error raised when proxy_from_url gets an unknown proxy type.\"\"\"\n\n    def __init__(self, typ: str) -> None:\n        super().__init__(\"Invalid proxy type {}!\".format(typ))\n\n\ndef proxy_from_url(url: QUrl) -> Union[QNetworkProxy, pac.PACFetcher]:\n    \"\"\"Create a QNetworkProxy from QUrl and a proxy type.\n\n    Args:\n        url: URL of a proxy (possibly with credentials).\n\n    Return:\n        New QNetworkProxy.\n    \"\"\"\n    ensure_valid(url)\n\n    scheme = url.scheme()\n    if scheme in ['pac+http', 'pac+https', 'pac+file']:\n        fetcher = pac.PACFetcher(url)\n        fetcher.fetch()\n        return fetcher\n\n    types = {\n        'http': QNetworkProxy.HttpProxy,\n        'socks': QNetworkProxy.Socks5Proxy,\n        'socks5': QNetworkProxy.Socks5Proxy,\n        'direct': QNetworkProxy.NoProxy,\n    }\n    if scheme not in types:\n        raise InvalidProxyTypeError(scheme)\n\n    proxy = QNetworkProxy(types[scheme], url.host())\n\n    if url.port() != -1:\n        proxy.setPort(url.port())\n    if url.userName():\n        proxy.setUser(url.userName())\n    if url.password():\n        proxy.setPassword(url.password())\n    return proxy\n\n\ndef parse_javascript_url(url: QUrl) -> str:\n    \"\"\"Get JavaScript source from the given URL.\n\n    See https://wiki.whatwg.org/wiki/URL_schemes#javascript:_URLs\n    and https://github.com/whatwg/url/issues/385\n    \"\"\"\n    ensure_valid(url)\n    if url.scheme() != 'javascript':\n        raise Error(\"Expected a javascript:... URL\")\n    if url.authority():\n        raise Error(\"URL contains unexpected components: {}\"\n                    .format(url.authority()))\n\n    urlstr = url.toString(QUrl.FullyEncoded)  # type: ignore[arg-type]\n    urlstr = urllib.parse.unquote(urlstr)\n\n    code = urlstr[len('javascript:'):]\n    if not code:\n        raise Error(\"Resulted in empty JavaScript code\")\n\n    return code\n\n\ndef widened_hostnames(hostname: Optional[str]) -> Iterator[str]:\n    \"\"\"A generator that yields widening string hostnames.\n\n    Ex: a.c.foo -> [a.c.foo, c.foo, foo]\n\n    Args:\n        hostname: The hostname string to widen.\n\n    Yields:\n        The hostname and its parent domains.\n    \"\"\"\n    if not hostname:\n        return\n    while hostname:\n        yield hostname\n        hostname = hostname.partition(\".\")[-1]\n",
              "additions": 19,
              "deletions": 1
            }
          ]
        },
        "agent": "opus-codex",
        "model": {
          "providerID": "anthropic",
          "modelID": "claude-opus-4-5"
        }
      },
      "parts": [
        {
          "id": "prt_bfaaf7dfd002sMJeFro4XgDT9v",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfaaf7dfd001wtLwIM1eGC5XRs",
          "type": "text",
          "text": "\"Read TASK.md for the task description. Fix the code to make all the tests pass. The test files and run command are in TASK.md.\"\n"
        }
      ]
    },
    {
      "info": {
        "id": "msg_bfaaf7e17001IJg9kFv9jr3AAA",
        "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
        "role": "assistant",
        "time": {
          "created": 1769437363735,
          "completed": 1769437366762
        },
        "parentID": "msg_bfaaf7dfd001wtLwIM1eGC5XRs",
        "modelID": "claude-opus-4-5",
        "providerID": "anthropic",
        "mode": "opus-codex",
        "agent": "opus-codex",
        "path": {
          "cwd": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896",
          "root": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896"
        },
        "cost": 0,
        "tokens": {
          "input": 2,
          "output": 113,
          "reasoning": 0,
          "cache": {
            "read": 0,
            "write": 15510
          }
        },
        "finish": "tool-calls"
      },
      "parts": [
        {
          "id": "prt_bfaaf8552001SHY1blAnCUzsft",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfaaf7e17001IJg9kFv9jr3AAA",
          "type": "step-start",
          "snapshot": "ac68fec4510681d5231e5a43ca746d43c6f4812b"
        },
        {
          "id": "prt_bfaaf865f001gljPJxyWna0Ijx",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfaaf7e17001IJg9kFv9jr3AAA",
          "type": "tool",
          "callID": "toolu_01XAgu5d5Rjys2WnTTfJmfRG",
          "tool": "read",
          "state": {
            "status": "completed",
            "input": {
              "filePath": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/TASK.md"
            },
            "output": "<file>\n00001| # SWE-bench Task: Host Blocking Subdomains\n00002| \n00003| ## Problem Statement\n00004| \n00005| Host blocking does not apply to subdomains when only the parent domain is listed.\n00006| \n00007| In the hosts-based blocking method, requests are only blocked if the exact request hostname matches an entry in either the dynamically loaded blocked hosts set or the config-defined blocked hosts. As a result, adding example.com to the blocklist does not block sub.example.com, a.b.example.com, etc.\n00008| \n00009| ## Current behavior\n00010| \n00011| With content.blocking.enabled turned on, and example.com present in the blocklist:\n00012| - https://example.com is blocked.\n00013| - https://sub.example.com and deeper subdomains are NOT blocked.\n00014| \n00015| ## Expected behavior\n00016| \n00017| - If a parent domain is blocked, all of its subdomains should also be blocked unless explicitly whitelisted.\n00018| - Blocking example.com should block example.com, sub.example.com, and a.b.example.com.\n00019| - Whitelist rules should take precedence: if a request URL is whitelisted, it must not be blocked.\n00020| \n00021| ## Test Files\n00022| \n00023| These tests must pass:\n00024| - tests/unit/components/test_hostblock.py\n00025| - tests/unit/config/test_configutils.py\n00026| - tests/unit/utils/test_urlutils.py\n00027| \n00028| ## Run Tests\n00029| \n00030| ```bash\n00031| source .venv/bin/activate\n00032| QT_QPA_PLATFORM=offscreen pytest tests/unit/components/test_hostblock.py tests/unit/utils/test_urlutils.py tests/unit/config/test_configutils.py -v\n00033| ```\n00034| \n\n(End of file - total 34 lines)\n</file>",
            "title": "TASK.md",
            "metadata": {
              "preview": "# SWE-bench Task: Host Blocking Subdomains\n\n## Problem Statement\n\nHost blocking does not apply to subdomains when only the parent domain is listed.\n\nIn the hosts-based blocking method, requests are only blocked if the exact request hostname matches an entry in either the dynamically loaded blocked hosts set or the config-defined blocked hosts. As a result, adding example.com to the blocklist does not block sub.example.com, a.b.example.com, etc.\n\n## Current behavior\n\nWith content.blocking.enabled turned on, and example.com present in the blocklist:\n- https://example.com is blocked.\n- https://sub.example.com and deeper subdomains are NOT blocked.\n\n## Expected behavior\n\n- If a parent domain is blocked, all of its subdomains should also be blocked unless explicitly whitelisted.\n- Blocking example.com should block example.com, sub.example.com, and a.b.example.com.\n- Whitelist rules should take precedence: if a request URL is whitelisted, it must not be blocked.\n",
              "truncated": false
            },
            "time": {
              "start": 1769437366615,
              "end": 1769437366617
            }
          }
        },
        {
          "id": "prt_bfaaf89860012j12ds3yHgh1UN",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfaaf7e17001IJg9kFv9jr3AAA",
          "type": "step-finish",
          "reason": "tool-calls",
          "snapshot": "",
          "cost": 0,
          "tokens": {
            "input": 2,
            "output": 113,
            "reasoning": 0,
            "cache": {
              "read": 0,
              "write": 15510
            }
          }
        },
        {
          "id": "prt_bfaaf89e9001zJZ5ZMYLaf4iX7",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfaaf7e17001IJg9kFv9jr3AAA",
          "type": "patch",
          "hash": "ac68fec4510681d5231e5a43ca746d43c6f4812b",
          "files": [
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/icons/qutebrowser-128x128.png",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/icons/qutebrowser-16x16.png",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/icons/qutebrowser-24x24.png",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/icons/qutebrowser-256x256.png",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/icons/qutebrowser-32x32.png",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/icons/qutebrowser-48x48.png",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/icons/qutebrowser-512x512.png",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/icons/qutebrowser-64x64.png",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/icons/qutebrowser-96x96.png",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/icons/qutebrowser-all.svg",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/icons/qutebrowser-favicon.svg",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/icons/qutebrowser.icns",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/icons/qutebrowser.ico",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/icons/qutebrowser.svg",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/icons/qutebrowser.xpm",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/misc/qutebrowser.rcc",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/misc/requirements/requirements-pip.txt",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/misc/requirements/requirements-pyqt-5.12.txt",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/misc/requirements/requirements-pyqt-5.12.txt-raw",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/misc/requirements/requirements-pyqt-5.13.txt",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/misc/requirements/requirements-pyqt-5.13.txt-raw",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/misc/requirements/requirements-pyqt-5.14.txt",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/misc/requirements/requirements-pyqt-5.14.txt-raw",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/misc/requirements/requirements-pyqt-5.15.0.txt",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/misc/requirements/requirements-pyqt-5.15.0.txt-raw",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/misc/requirements/requirements-pyqt-pyinstaller.txt",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/misc/requirements/requirements-pyqt-pyinstaller.txt-raw",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/javascript/quirks/globalthis.user.js",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/javascript/quirks/object_fromentries.user.js",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/qt.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/resources.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/scripts/dev/gen_resources.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/scripts/dev/pylint_checkers/qute_pylint/modeline.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/scripts/dev/pylint_checkers/qute_pylint/openencoding.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/darkmode/mathml.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/hints/invisible.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/browser/webkit/test_webview.py"
          ]
        }
      ]
    },
    {
      "info": {
        "id": "msg_bfaaf89ec001CTMUkv3VT0awN5",
        "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
        "role": "assistant",
        "time": {
          "created": 1769437366764,
          "completed": 1769437371233
        },
        "parentID": "msg_bfaaf7dfd001wtLwIM1eGC5XRs",
        "modelID": "claude-opus-4-5",
        "providerID": "anthropic",
        "mode": "opus-codex",
        "agent": "opus-codex",
        "path": {
          "cwd": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896",
          "root": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896"
        },
        "cost": 0,
        "tokens": {
          "input": 0,
          "output": 347,
          "reasoning": 0,
          "cache": {
            "read": 15510,
            "write": 634
          }
        },
        "finish": "tool-calls"
      },
      "parts": [
        {
          "id": "prt_bfaaf908500191MGrwFkHAotz8",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfaaf89ec001CTMUkv3VT0awN5",
          "type": "step-start",
          "snapshot": "ac68fec4510681d5231e5a43ca746d43c6f4812b"
        },
        {
          "id": "prt_bfaaf90860015NC7cCdX9clGS2",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfaaf89ec001CTMUkv3VT0awN5",
          "type": "text",
          "text": "Let me explore the codebase to understand the structure and find the relevant files.",
          "time": {
            "start": 1769437368938,
            "end": 1769437368938
          }
        },
        {
          "id": "prt_bfaaf926b001vz23T6q7Nevbmf",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfaaf89ec001CTMUkv3VT0awN5",
          "type": "tool",
          "callID": "toolu_01XCoryFnKz264vNB1SCnY8F",
          "tool": "read",
          "state": {
            "status": "completed",
            "input": {
              "filePath": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/components/test_hostblock.py"
            },
            "output": "<file>\n00001| # vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n00002| #!/usr/bin/env python3\n00003| \n00004| # Copyright 2015 Corentin Jul <corentinjule@gmail.com>\n00005| #\n00006| # This file is part of qutebrowser.\n00007| #\n00008| # qutebrowser is free software: you can redistribute it and/or modify\n00009| # it under the terms of the GNU General Public License as published by\n00010| # the Free Software Foundation, either version 3 of the License, or\n00011| # (at your option) any later version.\n00012| #\n00013| # qutebrowser is distributed in the hope that it will be useful,\n00014| # but WITHOUT ANY WARRANTY; without even the implied warranty of\n00015| # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n00016| # GNU General Public License for more details.\n00017| #\n00018| # You should have received a copy of the GNU General Public License\n00019| # along with qutebrowser.  If not, see <https://www.gnu.org/licenses/>.\n00020| \n00021| import pathlib\n00022| import zipfile\n00023| import logging\n00024| \n00025| import pytest\n00026| \n00027| from PyQt5.QtCore import QUrl\n00028| \n00029| from qutebrowser.components import hostblock\n00030| from qutebrowser.utils import urlmatch\n00031| from helpers import testutils\n00032| \n00033| \n00034| pytestmark = pytest.mark.usefixtures(\"qapp\")\n00035| \n00036| # TODO See ../utils/test_standarddirutils for OSError and caplog assertion\n00037| \n00038| WHITELISTED_HOSTS = (\"qutebrowser.org\", \"mediumhost.io\", \"http://*.edu\")\n00039| \n00040| BLOCKLIST_HOSTS = (\n00041|     \"localhost\",\n00042|     \"mediumhost.io\",\n00043|     \"malware.badhost.org\",\n00044|     \"4-verybadhost.com\",\n00045|     \"ads.worsthostever.net\",\n00046| )\n00047| \n00048| CLEAN_HOSTS = (\"goodhost.gov\", \"verygoodhost.com\")\n00049| \n00050| URLS_TO_CHECK = (\n00051|     \"http://localhost\",\n00052|     \"http://mediumhost.io\",\n00053|     \"ftp://malware.badhost.org\",\n00054|     \"http://4-verybadhost.com\",\n00055|     \"http://ads.worsthostever.net\",\n00056|     \"http://goodhost.gov\",\n00057|     \"ftp://verygoodhost.com\",\n00058|     \"http://qutebrowser.org\",\n00059|     \"http://veryverygoodhost.edu\",\n00060| )\n00061| \n00062| \n00063| @pytest.fixture\n00064| def host_blocker_factory(config_tmpdir, data_tmpdir, download_stub, config_stub):\n00065|     def factory():\n00066|         return hostblock.HostBlocker(config_dir=config_tmpdir, data_dir=data_tmpdir)\n00067| \n00068|     return factory\n00069| \n00070| \n00071| def create_zipfile(directory, files, zipname=\"test\"):\n00072|     \"\"\"Return a path to a newly created zip file.\n00073| \n00074|     Args:\n00075|         directory: path object where to create the zip file.\n00076|         files: list of pathlib.Paths (relative to directory) to each file to add.\n00077|         zipname: name to give to the zip file.\n00078|     \"\"\"\n00079|     zipfile_path = (directory / zipname).with_suffix(\".zip\")\n00080|     with zipfile.ZipFile(zipfile_path, \"w\") as new_zipfile:\n00081|         for file_path in files:\n00082|             new_zipfile.write(directory / file_path, arcname=file_path.name)\n00083|             # Removes path from file name\n00084|     return pathlib.Path(zipname + \".zip\")\n00085| \n00086| \n00087| def create_blocklist(\n00088|     directory, blocked_hosts=BLOCKLIST_HOSTS, name=\"hosts\", line_format=\"one_per_line\"\n00089| ):\n00090|     \"\"\"Return a path to a blocklist file.\n00091| \n00092|     Args:\n00093|         directory: path object where to create the blocklist file\n00094|         blocked_hosts: an iterable of string hosts to add to the blocklist\n00095|         name: name to give to the blocklist file\n00096|         line_format: 'etc_hosts'  -->  /etc/hosts format\n00097|                     'one_per_line'  -->  one host per line format\n00098|                     'not_correct'  -->  Not a correct hosts file format.\n00099|     \"\"\"\n00100|     blocklist_file = directory / name\n00101|     with blocklist_file.open(\"w\", encoding=\"UTF-8\") as blocklist:\n00102|         # ensure comments are ignored when processing blocklist\n00103|         blocklist.write(\"# Blocked Hosts List #\\n\\n\")\n00104|         if line_format == \"etc_hosts\":  # /etc/hosts like format\n00105|             for host in blocked_hosts:\n00106|                 blocklist.write(\"127.0.0.1  \" + host + \"\\n\")\n00107|         elif line_format == \"one_per_line\":\n00108|             for host in blocked_hosts:\n00109|                 blocklist.write(host + \"\\n\")\n00110|         elif line_format == \"not_correct\":\n00111|             for host in blocked_hosts:\n00112|                 blocklist.write(host + \" This is not a correct hosts file\\n\")\n00113|         else:\n00114|             raise ValueError(\"Incorrect line_format argument\")\n00115|     return pathlib.Path(name)\n00116| \n00117| \n00118| def assert_urls(\n00119|     host_blocker,\n00120|     blocked=BLOCKLIST_HOSTS,\n00121|     whitelisted=WHITELISTED_HOSTS,\n00122|     urls_to_check=URLS_TO_CHECK,\n00123| ):\n00124|     \"\"\"Test if Urls to check are blocked or not by HostBlocker.\n00125| \n00126|     Ensure URLs in 'blocked' and not in 'whitelisted' are blocked.\n00127|     All other URLs must not be blocked.\n00128| \n00129|     localhost is an example of a special case that shouldn't be blocked.\n00130|     \"\"\"\n00131|     whitelisted = list(whitelisted) + [\"localhost\"]\n00132|     for str_url in urls_to_check:\n00133|         url = QUrl(str_url)\n00134|         host = url.host()\n00135|         if host in blocked and host not in whitelisted:\n00136|             assert host_blocker._is_blocked(url)\n00137|         else:\n00138|             assert not host_blocker._is_blocked(url)\n00139| \n00140| \n00141| def blocklist_to_url(path):\n00142|     \"\"\"Get an example.com-URL with the given filename as path.\"\"\"\n00143|     assert not path.is_absolute(), path\n00144|     url = QUrl(\"http://example.com/\")\n00145|     url.setPath(\"/\" + str(path))\n00146|     assert url.isValid(), url.errorString()\n00147|     return url\n00148| \n00149| \n00150| def generic_blocklists(directory):\n00151|     \"\"\"Return a generic list of files to be used in hosts-block-lists option.\n00152| \n00153|     This list contains :\n00154|     - a remote zip file with 1 hosts file and 2 useless files\n00155|     - a remote zip file with only useless files\n00156|         (Should raise a FileNotFoundError)\n00157|     - a remote zip file with only one valid hosts file\n00158|     - a local text file with valid hosts\n00159|     - a remote text file without valid hosts format.\n00160|     \"\"\"\n00161|     # remote zip file with 1 hosts file and 2 useless files\n00162|     file1 = create_blocklist(\n00163|         directory, blocked_hosts=CLEAN_HOSTS, name=\"README\", line_format=\"not_correct\"\n00164|     )\n00165|     file2 = create_blocklist(\n00166|         directory,\n00167|         blocked_hosts=BLOCKLIST_HOSTS[:3],\n00168|         name=\"hosts\",\n00169|         line_format=\"etc_hosts\",\n00170|     )\n00171|     file3 = create_blocklist(\n00172|         directory,\n00173|         blocked_hosts=CLEAN_HOSTS,\n00174|         name=\"false_positive\",\n00175|         line_format=\"one_per_line\",\n00176|     )\n00177|     files_to_zip = [file1, file2, file3]\n00178|     blocklist1 = blocklist_to_url(create_zipfile(directory, files_to_zip, \"block1\"))\n00179| \n00180|     # remote zip file without file named hosts\n00181|     # (Should raise a FileNotFoundError)\n00182|     file1 = create_blocklist(\n00183|         directory, blocked_hosts=CLEAN_HOSTS, name=\"md5sum\", line_format=\"etc_hosts\"\n00184|     )\n00185|     file2 = create_blocklist(\n00186|         directory, blocked_hosts=CLEAN_HOSTS, name=\"README\", line_format=\"not_correct\"\n00187|     )\n00188|     file3 = create_blocklist(\n00189|         directory,\n00190|         blocked_hosts=CLEAN_HOSTS,\n00191|         name=\"false_positive\",\n00192|         line_format=\"one_per_line\",\n00193|     )\n00194|     files_to_zip = [file1, file2, file3]\n00195|     blocklist2 = blocklist_to_url(create_zipfile(directory, files_to_zip, \"block2\"))\n00196| \n00197|     # remote zip file with only one valid hosts file inside\n00198|     file1 = create_blocklist(\n00199|         directory,\n00200|         blocked_hosts=[BLOCKLIST_HOSTS[3]],\n00201|         name=\"malwarelist\",\n00202|         line_format=\"etc_hosts\",\n00203|     )\n00204|     blocklist3 = blocklist_to_url(create_zipfile(directory, [file1], \"block3\"))\n00205| \n00206|     # local text file with valid hosts\n00207|     blocklist4 = QUrl.fromLocalFile(\n00208|         str(\n00209|             directory\n00210|             / create_blocklist(\n00211|                 directory,\n00212|                 blocked_hosts=[BLOCKLIST_HOSTS[4]],\n00213|                 name=\"mycustomblocklist\",\n00214|                 line_format=\"one_per_line\",\n00215|             )\n00216|         )\n00217|     )\n00218|     assert blocklist4.isValid(), blocklist4.errorString()\n00219| \n00220|     # remote text file without valid hosts format\n00221|     blocklist5 = blocklist_to_url(\n00222|         create_blocklist(\n00223|             directory,\n00224|             blocked_hosts=CLEAN_HOSTS,\n00225|             name=\"notcorrectlist\",\n00226|             line_format=\"not_correct\",\n00227|         )\n00228|     )\n00229| \n00230|     return [\n00231|         blocklist1.toString(),\n00232|         blocklist2.toString(),\n00233|         blocklist3.toString(),\n00234|         blocklist4.toString(),\n00235|         blocklist5.toString(),\n00236|     ]\n00237| \n00238| \n00239| @pytest.mark.parametrize(\n00240|     \"blocking_enabled, method\",\n00241|     [\n00242|         # Assuming the adblock dependency is installed\n00243|         (True, \"auto\"),\n00244|         (True, \"adblock\"),\n00245|         (False, \"auto\"),\n00246|         (False, \"adblock\"),\n00247|         (False, \"both\"),\n00248|         (False, \"hosts\"),\n00249|     ],\n00250| )\n00251| def test_disabled_blocking_update(\n00252|     config_stub, tmp_path, caplog, host_blocker_factory, blocking_enabled, method\n00253| ):\n00254|     \"\"\"Ensure no URL is blocked when host blocking should be disabled.\"\"\"\n00255|     if blocking_enabled and method == 'auto':\n00256|         pytest.importorskip('adblock')\n00257| \n00258|     config_stub.val.content.blocking.hosts.lists = generic_blocklists(tmp_path)\n00259|     config_stub.val.content.blocking.enabled = blocking_enabled\n00260|     config_stub.val.content.blocking.method = method\n00261| \n00262|     host_blocker = host_blocker_factory()\n00263|     downloads = host_blocker.adblock_update()\n00264|     while downloads._in_progress:\n00265|         current_download = downloads._in_progress[0]\n00266|         with caplog.at_level(logging.ERROR):\n00267|             current_download.successful = True\n00268|             current_download.finished.emit()\n00269|     host_blocker.read_hosts()\n00270|     for str_url in URLS_TO_CHECK:\n00271|         assert not host_blocker._is_blocked(QUrl(str_url))\n00272| \n00273| \n00274| def test_disabled_blocking_per_url(config_stub, host_blocker_factory):\n00275|     example_com = \"https://www.example.com/\"\n00276| \n00277|     config_stub.val.content.blocking.method = \"hosts\"\n00278|     config_stub.val.content.blocking.hosts.lists = []\n00279|     pattern = urlmatch.UrlPattern(example_com)\n00280|     config_stub.set_obj(\"content.blocking.enabled\", False, pattern=pattern)\n00281| \n00282|     url = QUrl(\"https://blocked.example.com\")\n00283| \n00284|     host_blocker = host_blocker_factory()\n00285|     host_blocker._blocked_hosts.add(url.host())\n00286| \n00287|     assert host_blocker._is_blocked(url)\n00288|     assert not host_blocker._is_blocked(url, first_party_url=QUrl(example_com))\n00289| \n00290| \n00291| def test_no_blocklist_update(config_stub, download_stub, host_blocker_factory):\n00292|     \"\"\"Ensure no URL is blocked when no block list exists.\"\"\"\n00293|     config_stub.val.content.blocking.hosts.lists = None\n00294|     config_stub.val.content.blocking.method = \"hosts\"\n00295|     config_stub.val.content.blocking.enabled = True\n00296| \n00297|     host_blocker = host_blocker_factory()\n00298|     host_blocker.adblock_update()\n00299|     host_blocker.read_hosts()\n00300|     for dl in download_stub.downloads:\n00301|         dl.successful = True\n00302|     for str_url in URLS_TO_CHECK:\n00303|         assert not host_blocker._is_blocked(QUrl(str_url))\n00304| \n00305| \n00306| def test_successful_update(config_stub, tmp_path, caplog, host_blocker_factory):\n00307|     \"\"\"Ensure hosts from host_blocking.lists are blocked after an update.\"\"\"\n00308|     config_stub.val.content.blocking.hosts.lists = generic_blocklists(tmp_path)\n00309|     config_stub.val.content.blocking.method = \"hosts\"\n00310|     config_stub.val.content.blocking.enabled = True\n00311|     config_stub.val.content.blocking.whitelist = None\n00312| \n00313|     host_blocker = host_blocker_factory()\n00314|     downloads = host_blocker.adblock_update()\n00315|     # Simulate download is finished\n00316|     while downloads._in_progress:\n00317|         current_download = downloads._in_progress[0]\n00318|         with caplog.at_level(logging.ERROR):\n00319|             current_download.successful = True\n00320|             current_download.finished.emit()\n00321|     host_blocker.read_hosts()\n00322|     assert_urls(host_blocker, whitelisted=[])\n00323| \n00324| \n00325| def test_parsing_multiple_hosts_on_line(config_stub, host_blocker_factory):\n00326|     \"\"\"Ensure multiple hosts on a line get parsed correctly.\"\"\"\n00327|     config_stub.val.content.blocking.method = \"hosts\"\n00328|     config_stub.val.content.blocking.enabled = True\n00329| \n00330|     host_blocker = host_blocker_factory()\n00331|     bytes_host_line = \" \".join(BLOCKLIST_HOSTS).encode(\"utf-8\")\n00332|     parsed_hosts = host_blocker._read_hosts_line(bytes_host_line)\n00333|     host_blocker._blocked_hosts |= parsed_hosts\n00334|     assert_urls(host_blocker, whitelisted=[])\n00335| \n00336| \n00337| @pytest.mark.parametrize(\n00338|     \"ip, host\",\n00339|     [\n00340|         (\"127.0.0.1\", \"localhost\"),\n00341|         (\"27.0.0.1\", \"localhost.localdomain\"),\n00342|         (\"27.0.0.1\", \"local\"),\n00343|         (\"55.255.255.255\", \"broadcasthost\"),\n00344|         (\":1\", \"localhost\"),\n00345|         (\":1\", \"ip6-localhost\"),\n00346|         (\":1\", \"ip6-loopback\"),\n00347|         (\"e80::1%lo0\", \"localhost\"),\n00348|         (\"f00::0\", \"ip6-localnet\"),\n00349|         (\"f00::0\", \"ip6-mcastprefix\"),\n00350|         (\"f02::1\", \"ip6-allnodes\"),\n00351|         (\"f02::2\", \"ip6-allrouters\"),\n00352|         (\"ff02::3\", \"ip6-allhosts\"),\n00353|         (\".0.0.0\", \"0.0.0.0\"),\n00354|         (\"127.0.1.1\", \"myhostname\"),\n00355|         (\"127.0.0.53\", \"myhostname\"),\n00356|     ],\n00357| )\n00358| def test_whitelisted_lines(host_blocker_factory, ip, host):\n00359|     \"\"\"Make sure we don't block hosts we don't want to.\"\"\"\n00360|     host_blocker = host_blocker_factory()\n00361|     line = (\"{} {}\".format(ip, host)).encode(\"ascii\")\n00362|     parsed_hosts = host_blocker._read_hosts_line(line)\n00363|     assert host not in parsed_hosts\n00364| \n00365| \n00366| def test_failed_dl_update(config_stub, tmp_path, caplog, host_blocker_factory):\n00367|     \"\"\"One blocklist fails to download.\n00368| \n00369|     Ensure hosts from this list are not blocked.\n00370|     \"\"\"\n00371|     dl_fail_blocklist = blocklist_to_url(\n00372|         create_blocklist(\n00373|             tmp_path,\n00374|             blocked_hosts=CLEAN_HOSTS,\n00375|             name=\"download_will_fail\",\n00376|             line_format=\"one_per_line\",\n00377|         )\n00378|     )\n00379|     hosts_to_block = generic_blocklists(tmp_path) + [dl_fail_blocklist.toString()]\n00380|     config_stub.val.content.blocking.hosts.lists = hosts_to_block\n00381|     config_stub.val.content.blocking.enabled = True\n00382|     config_stub.val.content.blocking.method = \"hosts\"\n00383|     config_stub.val.content.blocking.whitelist = None\n00384| \n00385|     host_blocker = host_blocker_factory()\n00386|     downloads = host_blocker.adblock_update()\n00387|     while downloads._in_progress:\n00388|         current_download = downloads._in_progress[0]\n00389|         # if current download is the file we want to fail, make it fail\n00390|         if current_download.name == dl_fail_blocklist.path():\n00391|             current_download.successful = False\n00392|         else:\n00393|             current_download.successful = True\n00394|         with caplog.at_level(logging.ERROR):\n00395|             current_download.finished.emit()\n00396|     host_blocker.read_hosts()\n00397|     assert_urls(host_blocker, whitelisted=[])\n00398| \n00399| \n00400| @pytest.mark.parametrize(\"location\", [\"content\", \"comment\"])\n00401| def test_invalid_utf8(config_stub, tmp_path, caplog, host_blocker_factory, location):\n00402|     \"\"\"Make sure invalid UTF-8 is handled correctly.\n00403| \n00404|     See https://github.com/qutebrowser/qutebrowser/issues/2301\n00405|     \"\"\"\n00406|     blocklist = tmp_path / \"blocklist\"\n00407|     if location == \"comment\":\n00408|         blocklist.write_bytes(b\"# nbsp: \\xa0\\n\")\n00409|     else:\n00410|         assert location == \"content\"\n00411|         blocklist.write_bytes(b\"https://www.example.org/\\xa0\")\n00412|     with blocklist.open(\"a\") as f:\n00413|         for url in BLOCKLIST_HOSTS:\n00414|             f.write(url + \"\\n\")\n00415| \n00416|     url = blocklist_to_url(pathlib.Path(\"blocklist\"))\n00417|     config_stub.val.content.blocking.hosts.lists = [url.toString()]\n00418|     config_stub.val.content.blocking.enabled = True\n00419|     config_stub.val.content.blocking.method = \"hosts\"\n00420|     config_stub.val.content.blocking.whitelist = None\n00421| \n00422|     host_blocker = host_blocker_factory()\n00423|     downloads = host_blocker.adblock_update()\n00424|     current_download = downloads._in_progress[0]\n00425| \n00426|     if location == \"content\":\n00427|         with caplog.at_level(logging.ERROR):\n00428|             current_download.successful = True\n00429|             current_download.finished.emit()\n00430|         expected = r\"Failed to decode: \" r\"b'https://www.example.org/\\xa0localhost\"\n00431|         assert caplog.messages[-2].startswith(expected)\n00432|     else:\n00433|         current_download.successful = True\n00434|         current_download.finished.emit()\n00435| \n00436|     host_blocker.read_hosts()\n00437|     assert_urls(host_blocker, whitelisted=[])\n00438| \n00439| \n00440| def test_invalid_utf8_compiled(\n00441|     config_stub, config_tmpdir, data_tmpdir, monkeypatch, caplog, host_blocker_factory\n00442| ):\n00443|     \"\"\"Make sure invalid UTF-8 in the compiled file is handled.\"\"\"\n00444|     config_stub.val.content.blocking.hosts.lists = []\n00445| \n00446|     # Make sure the HostBlocker doesn't delete blocked-hosts in __init__\n00447|     monkeypatch.setattr(hostblock.HostBlocker, \"update_files\", lambda _self: None)\n00448| \n00449|     (config_tmpdir / \"blocked-hosts\").write_binary(b\"https://www.example.org/\\xa0\")\n00450|     (data_tmpdir / \"blocked-hosts\").ensure()\n00451| \n00452|     host_blocker = host_blocker_factory()\n00453|     with caplog.at_level(logging.ERROR):\n00454|         host_blocker.read_hosts()\n00455|     assert caplog.messages[-1] == \"Failed to read host blocklist!\"\n00456| \n00457| \n00458| def test_blocking_with_whitelist(config_stub, data_tmpdir, host_blocker_factory):\n00459|     \"\"\"Ensure hosts in content.blocking.whitelist are never blocked.\"\"\"\n00460|     # Simulate adblock_update has already been run\n00461|     # by creating a file named blocked-hosts,\n00462|     # Exclude localhost from it as localhost is never blocked via list\n00463|     filtered_blocked_hosts = BLOCKLIST_HOSTS[1:]\n00464|     blocklist = create_blocklist(\n00465|         data_tmpdir,\n00466|         blocked_hosts=filtered_blocked_hosts,\n00467|         name=\"blocked-hosts\",\n00468|         line_format=\"one_per_line\",\n00469|     )\n00470|     config_stub.val.content.blocking.hosts.lists = [str(blocklist)]\n00471|     config_stub.val.content.blocking.enabled = True\n00472|     config_stub.val.content.blocking.method = \"hosts\"\n00473|     config_stub.val.content.blocking.whitelist = list(WHITELISTED_HOSTS)\n00474| \n00475|     host_blocker = host_blocker_factory()\n00476|     host_blocker.read_hosts()\n00477|     assert_urls(host_blocker)\n00478| \n00479| \n00480| def test_config_change_initial(config_stub, tmp_path, host_blocker_factory):\n00481|     \"\"\"Test emptying host_blocking.lists with existing blocked_hosts.\n00482| \n00483|     - A blocklist is present in host_blocking.lists and blocked_hosts is\n00484|       populated\n00485|     - User quits qutebrowser, empties host_blocking.lists from his config\n00486|     - User restarts qutebrowser, does adblock-update\n00487|     \"\"\"\n00488|     create_blocklist(\n00489|         tmp_path,\n00490|         blocked_hosts=BLOCKLIST_HOSTS,\n00491|         name=\"blocked-hosts\",\n00492|         line_format=\"one_per_line\",\n00493|     )\n00494|     config_stub.val.content.blocking.hosts.lists = None\n00495|     config_stub.val.content.blocking.enabled = True\n00496|     config_stub.val.content.blocking.method = \"hosts\"\n00497|     config_stub.val.content.blocking.whitelist = None\n00498| \n00499|     host_blocker = host_blocker_factory()\n00500|     host_blocker.read_hosts()\n00501|     for str_url in URLS_TO_CHECK:\n00502|         assert not host_blocker._is_blocked(QUrl(str_url))\n00503| \n00504| \n00505| def test_config_change(config_stub, tmp_path, host_blocker_factory):\n00506|     \"\"\"Ensure blocked-hosts resets if host-block-list is changed to None.\"\"\"\n00507|     filtered_blocked_hosts = BLOCKLIST_HOSTS[1:]  # Exclude localhost\n00508|     blocklist = blocklist_to_url(\n00509|         create_blocklist(\n00510|             tmp_path,\n00511|             blocked_hosts=filtered_blocked_hosts,\n00512|             name=\"blocked-hosts\",\n00513|             line_format=\"one_per_line\",\n00514|         )\n00515|     )\n00516|     config_stub.val.content.blocking.hosts.lists = [blocklist.toString()]\n00517|     config_stub.val.content.blocking.enabled = True\n00518|     config_stub.val.content.blocking.method = \"hosts\"\n00519|     config_stub.val.content.blocking.whitelist = None\n00520| \n00521|     host_blocker = host_blocker_factory()\n00522|     host_blocker.read_hosts()\n00523|     config_stub.val.content.blocking.hosts.lists = None\n00524|     host_blocker.read_hosts()\n00525|     for str_url in URLS_TO_CHECK:\n00526|         assert not host_blocker._is_blocked(QUrl(str_url))\n00527| \n00528| \n00529| def test_add_directory(config_stub, tmp_path, host_blocker_factory):\n00530|     \"\"\"Ensure adblocker can import all files in a directory.\"\"\"\n00531|     blocklist_hosts2 = []\n00532|     for i in BLOCKLIST_HOSTS[1:]:\n00533|         blocklist_hosts2.append(\"1\" + i)\n00534| \n00535|     create_blocklist(\n00536|         tmp_path,\n00537|         blocked_hosts=BLOCKLIST_HOSTS,\n00538|         name=\"blocked-hosts\",\n00539|         line_format=\"one_per_line\",\n00540|     )\n00541|     create_blocklist(\n00542|         tmp_path,\n00543|         blocked_hosts=blocklist_hosts2,\n00544|         name=\"blocked-hosts2\",\n00545|         line_format=\"one_per_line\",\n00546|     )\n00547| \n00548|     config_stub.val.content.blocking.hosts.lists = [str(tmp_path)]\n00549|     config_stub.val.content.blocking.enabled = True\n00550|     config_stub.val.content.blocking.method = \"hosts\"\n00551|     host_blocker = host_blocker_factory()\n00552|     host_blocker.adblock_update()\n00553|     assert len(host_blocker._blocked_hosts) == len(blocklist_hosts2) * 2\n00554| \n00555| \n00556| def test_adblock_benchmark(data_tmpdir, benchmark, host_blocker_factory):\n00557|     blocked_hosts = data_tmpdir / \"blocked-hosts\"\n00558|     blocked_hosts.write_text(\"\\n\".join(testutils.blocked_hosts()), encoding=\"utf-8\")\n00559| \n00560|     url = QUrl(\"https://www.example.org/\")\n00561|     blocker = host_blocker_factory()\n00562|     blocker.read_hosts()\n00563|     assert blocker._blocked_hosts\n00564| \n00565|     benchmark(lambda: blocker._is_blocked(url))\n00566| \n00567| \n00568| def test_subdomain_blocking(config_stub, host_blocker_factory):\n00569|     config_stub.val.content.blocking.method = \"hosts\"\n00570|     config_stub.val.content.blocking.hosts.lists = None\n00571|     host_blocker = host_blocker_factory()\n00572|     host_blocker._blocked_hosts.add(\"example.com\")\n00573|     assert host_blocker._is_blocked(QUrl(\"https://subdomain.example.com\"))\n00574| \n\n(End of file - total 574 lines)\n</file>",
            "title": "tests/unit/components/test_hostblock.py",
            "metadata": {
              "preview": "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n#!/usr/bin/env python3\n\n# Copyright 2015 Corentin Jul <corentinjule@gmail.com>\n#\n# This file is part of qutebrowser.\n#\n# qutebrowser is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# qutebrowser is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with qutebrowser.  If not, see <https://www.gnu.org/licenses/>.\n",
              "truncated": false
            },
            "time": {
              "start": 1769437369869,
              "end": 1769437369871
            }
          }
        },
        {
          "id": "prt_bfaaf960f001QZFqkOIjOcFheM",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfaaf89ec001CTMUkv3VT0awN5",
          "type": "tool",
          "callID": "toolu_01Aq2uyssFhYJeWCDVLTbnAN",
          "tool": "read",
          "state": {
            "status": "completed",
            "input": {
              "filePath": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/utils/test_urlutils.py"
            },
            "output": "<file>\n00001| # vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n00002| \n00003| # Copyright 2014-2021 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n00004| #\n00005| # This file is part of qutebrowser.\n00006| #\n00007| # qutebrowser is free software: you can redistribute it and/or modify\n00008| # it under the terms of the GNU General Public License as published by\n00009| # the Free Software Foundation, either version 3 of the License, or\n00010| # (at your option) any later version.\n00011| #\n00012| # qutebrowser is distributed in the hope that it will be useful,\n00013| # but WITHOUT ANY WARRANTY; without even the implied warranty of\n00014| # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n00015| # GNU General Public License for more details.\n00016| #\n00017| # You should have received a copy of the GNU General Public License\n00018| # along with qutebrowser.  If not, see <https://www.gnu.org/licenses/>.\n00019| \n00020| \"\"\"Tests for qutebrowser.utils.urlutils.\"\"\"\n00021| \n00022| import os.path\n00023| import logging\n00024| import dataclasses\n00025| import urllib.parse\n00026| \n00027| from PyQt5.QtCore import QUrl\n00028| from PyQt5.QtNetwork import QNetworkProxy\n00029| import pytest\n00030| import hypothesis\n00031| import hypothesis.strategies\n00032| \n00033| from qutebrowser.api import cmdutils\n00034| from qutebrowser.browser.network import pac\n00035| from qutebrowser.utils import utils, urlutils, usertypes\n00036| \n00037| \n00038| class FakeDNS:\n00039| \n00040|     \"\"\"Helper class for the fake_dns fixture.\n00041| \n00042|     Class attributes:\n00043|         FakeDNSAnswer: Helper class imitating a QHostInfo object\n00044|                        (used by fromname_mock).\n00045| \n00046|     Attributes:\n00047|         used: Whether the fake DNS server was used since it was\n00048|               created/reset.\n00049|         answer: What to return for the given host(True/False). Needs to be set\n00050|                 when fromname_mock is called.\n00051|     \"\"\"\n00052| \n00053|     @dataclasses.dataclass\n00054|     class FakeDNSAnswer:\n00055| \n00056|         error: bool\n00057| \n00058|     def __init__(self):\n00059|         self.used = False\n00060|         self.answer = None\n00061| \n00062|     def __repr__(self):\n00063|         return utils.get_repr(self, used=self.used, answer=self.answer)\n00064| \n00065|     def reset(self):\n00066|         \"\"\"Reset used/answer as if the FakeDNS was freshly created.\"\"\"\n00067|         self.used = False\n00068|         self.answer = None\n00069| \n00070|     def _get_error(self):\n00071|         return not self.answer\n00072| \n00073|     def fromname_mock(self, _host):\n00074|         \"\"\"Simple mock for QHostInfo::fromName returning a FakeDNSAnswer.\"\"\"\n00075|         if self.answer is None:\n00076|             raise ValueError(\"Got called without answer being set. This means \"\n00077|                              \"something tried to make an unexpected DNS \"\n00078|                              \"request (QHostInfo::fromName).\")\n00079|         if self.used:\n00080|             raise ValueError(\"Got used twice!.\")\n00081|         self.used = True\n00082|         return self.FakeDNSAnswer(error=self._get_error)\n00083| \n00084| \n00085| @pytest.fixture(autouse=True)\n00086| def fake_dns(monkeypatch):\n00087|     \"\"\"Patched QHostInfo.fromName to catch DNS requests.\n00088| \n00089|     With autouse=True so accidental DNS requests get discovered because the\n00090|     fromname_mock will be called without answer being set.\n00091|     \"\"\"\n00092|     dns = FakeDNS()\n00093|     monkeypatch.setattr(urlutils.QHostInfo, 'fromName', dns.fromname_mock)\n00094|     return dns\n00095| \n00096| \n00097| @pytest.fixture(autouse=True)\n00098| def init_config(config_stub):\n00099|     config_stub.val.url.searchengines = {\n00100|         'test': 'http://www.qutebrowser.org/?q={}',\n00101|         'test-with-dash': 'http://www.example.org/?q={}',\n00102|         'path-search': 'http://www.example.org/{}',\n00103|         'quoted-path': 'http://www.example.org/{quoted}',\n00104|         'unquoted': 'http://www.example.org/?{unquoted}',\n00105|         'DEFAULT': 'http://www.example.com/?q={}',\n00106|     }\n00107| \n00108| \n00109| class TestFuzzyUrl:\n00110| \n00111|     \"\"\"Tests for urlutils.fuzzy_url().\"\"\"\n00112| \n00113|     @pytest.fixture\n00114|     def os_mock(self, mocker):\n00115|         \"\"\"Mock the os module and some os.path functions.\"\"\"\n00116|         m = mocker.patch('qutebrowser.utils.urlutils.os')\n00117|         # Using / to get the same behavior across OS'\n00118|         m.path.join.side_effect = lambda *args: '/'.join(args)\n00119|         m.path.expanduser.side_effect = os.path.expanduser\n00120|         return m\n00121| \n00122|     @pytest.fixture\n00123|     def is_url_mock(self, mocker):\n00124|         return mocker.patch('qutebrowser.utils.urlutils.is_url')\n00125| \n00126|     @pytest.fixture\n00127|     def get_search_url_mock(self, mocker):\n00128|         return mocker.patch('qutebrowser.utils.urlutils._get_search_url')\n00129| \n00130|     def test_file_relative_cwd(self, os_mock):\n00131|         \"\"\"Test with relative=True, cwd set, and an existing file.\"\"\"\n00132|         os_mock.path.exists.return_value = True\n00133|         os_mock.path.isabs.return_value = False\n00134| \n00135|         url = urlutils.fuzzy_url('foo', cwd='cwd', relative=True)\n00136| \n00137|         os_mock.path.exists.assert_called_once_with('cwd/foo')\n00138|         assert url == QUrl('file:cwd/foo')\n00139| \n00140|     def test_file_relative(self, os_mock):\n00141|         \"\"\"Test with relative=True and cwd unset.\"\"\"\n00142|         os_mock.path.exists.return_value = True\n00143|         os_mock.path.abspath.return_value = 'abs_path'\n00144|         os_mock.path.isabs.return_value = False\n00145| \n00146|         url = urlutils.fuzzy_url('foo', relative=True)\n00147| \n00148|         os_mock.path.exists.assert_called_once_with('abs_path')\n00149|         assert url == QUrl('file:abs_path')\n00150| \n00151|     def test_file_relative_os_error(self, os_mock, is_url_mock):\n00152|         \"\"\"Test with relative=True, cwd unset and abspath raising OSError.\"\"\"\n00153|         os_mock.path.abspath.side_effect = OSError\n00154|         os_mock.path.exists.return_value = True\n00155|         os_mock.path.isabs.return_value = False\n00156|         is_url_mock.return_value = True\n00157| \n00158|         url = urlutils.fuzzy_url('foo', relative=True)\n00159|         assert not os_mock.path.exists.called\n00160|         assert url == QUrl('http://foo')\n00161| \n00162|     @pytest.mark.parametrize('path, expected', [\n00163|         ('/foo', QUrl('file:///foo')),\n00164|         ('/bar\\n', QUrl('file:///bar')),\n00165|     ])\n00166|     def test_file_absolute(self, path, expected, os_mock):\n00167|         \"\"\"Test with an absolute path.\"\"\"\n00168|         os_mock.path.exists.return_value = True\n00169|         os_mock.path.isabs.return_value = True\n00170| \n00171|         url = urlutils.fuzzy_url(path)\n00172|         assert url == expected\n00173| \n00174|     @pytest.mark.posix\n00175|     def test_file_absolute_expanded(self, os_mock):\n00176|         \"\"\"Make sure ~ gets expanded correctly.\"\"\"\n00177|         os_mock.path.exists.return_value = True\n00178|         os_mock.path.isabs.return_value = True\n00179| \n00180|         url = urlutils.fuzzy_url('~/foo')\n00181|         assert url == QUrl('file://' + os.path.expanduser('~/foo'))\n00182| \n00183|     def test_address(self, os_mock, is_url_mock):\n00184|         \"\"\"Test passing something with relative=False.\"\"\"\n00185|         os_mock.path.isabs.return_value = False\n00186|         is_url_mock.return_value = True\n00187| \n00188|         url = urlutils.fuzzy_url('foo')\n00189|         assert url == QUrl('http://foo')\n00190| \n00191|     def test_search_term(self, os_mock, is_url_mock, get_search_url_mock):\n00192|         \"\"\"Test passing something with do_search=True.\"\"\"\n00193|         os_mock.path.isabs.return_value = False\n00194|         is_url_mock.return_value = False\n00195|         get_search_url_mock.return_value = QUrl('search_url')\n00196| \n00197|         url = urlutils.fuzzy_url('foo', do_search=True)\n00198|         assert url == QUrl('search_url')\n00199| \n00200|     def test_search_term_value_error(self, os_mock, is_url_mock,\n00201|                                      get_search_url_mock):\n00202|         \"\"\"Test with do_search=True and ValueError in _get_search_url.\"\"\"\n00203|         os_mock.path.isabs.return_value = False\n00204|         is_url_mock.return_value = False\n00205|         get_search_url_mock.side_effect = ValueError\n00206| \n00207|         url = urlutils.fuzzy_url('foo', do_search=True)\n00208|         assert url == QUrl('http://foo')\n00209| \n00210|     def test_no_do_search(self, is_url_mock):\n00211|         \"\"\"Test with do_search = False.\"\"\"\n00212|         is_url_mock.return_value = False\n00213| \n00214|         url = urlutils.fuzzy_url('foo', do_search=False)\n00215|         assert url == QUrl('http://foo')\n00216| \n00217|     @pytest.mark.parametrize('do_search', [True, False])\n00218|     def test_invalid_url(self, do_search, caplog):\n00219|         \"\"\"Test with an invalid URL.\"\"\"\n00220|         with pytest.raises(urlutils.InvalidUrlError):\n00221|             with caplog.at_level(logging.ERROR):\n00222|                 urlutils.fuzzy_url('', do_search=do_search)\n00223| \n00224|     @pytest.mark.parametrize('url', ['', ' '])\n00225|     def test_empty(self, url):\n00226|         with pytest.raises(urlutils.InvalidUrlError):\n00227|             urlutils.fuzzy_url(url, do_search=True)\n00228| \n00229|     @pytest.mark.parametrize('urlstring', [\n00230|         'http://www.qutebrowser.org/',\n00231|         '/foo',\n00232|         'test'\n00233|     ])\n00234|     def test_force_search(self, urlstring, get_search_url_mock):\n00235|         \"\"\"Test the force search option.\"\"\"\n00236|         get_search_url_mock.return_value = QUrl('search_url')\n00237| \n00238|         url = urlutils.fuzzy_url(urlstring, force_search=True)\n00239| \n00240|         assert url == QUrl('search_url')\n00241| \n00242|     @pytest.mark.parametrize('path, check_exists', [\n00243|         ('/foo', False),\n00244|         ('/bar', True),\n00245|     ])\n00246|     def test_get_path_existing(self, path, check_exists, os_mock, caplog):\n00247|         \"\"\"Test with an absolute path.\"\"\"\n00248|         os_mock.path.exists.return_value = False\n00249|         expected = None if check_exists else path\n00250| \n00251|         url = urlutils.get_path_if_valid(path, check_exists=check_exists)\n00252|         assert url == expected\n00253| \n00254|     def test_get_path_unicode_encode_error(self, os_mock, caplog):\n00255|         \"\"\"Make sure LC_ALL=C is handled correctly.\"\"\"\n00256|         err = UnicodeEncodeError('ascii', '', 0, 2, 'foo')\n00257|         os_mock.path.exists.side_effect = err\n00258| \n00259|         url = urlutils.get_path_if_valid('/', check_exists=True)\n00260|         assert url is None\n00261| \n00262|         msg = (\"URL contains characters which are not present in the current \"\n00263|                \"locale\")\n00264|         assert caplog.messages[-1] == msg\n00265| \n00266| \n00267| @pytest.mark.parametrize('url, special', [\n00268|     ('file:///tmp/foo', True),\n00269|     ('about:blank', True),\n00270|     ('qute:version', True),\n00271|     ('qute://version', True),\n00272|     ('http://www.qutebrowser.org/', False),\n00273|     ('www.qutebrowser.org', False),\n00274| ])\n00275| def test_special_urls(url, special):\n00276|     assert urlutils.is_special_url(QUrl(url)) == special\n00277| \n00278| \n00279| @pytest.mark.parametrize('open_base_url', [True, False])\n00280| @pytest.mark.parametrize('url, host, query', [\n00281|     ('testfoo', 'www.example.com', 'q=testfoo'),\n00282|     ('test testfoo', 'www.qutebrowser.org', 'q=testfoo'),\n00283|     ('test testfoo bar foo', 'www.qutebrowser.org', 'q=testfoo bar foo'),\n00284|     ('test testfoo ', 'www.qutebrowser.org', 'q=testfoo'),\n00285|     ('!python testfoo', 'www.example.com', 'q=%21python testfoo'),\n00286|     ('blub testfoo', 'www.example.com', 'q=blub testfoo'),\n00287|     ('stripped ', 'www.example.com', 'q=stripped'),\n00288|     ('test-with-dash testfoo', 'www.example.org', 'q=testfoo'),\n00289|     ('test/with/slashes', 'www.example.com', 'q=test/with/slashes'),\n00290|     ('test path-search', 'www.qutebrowser.org', 'q=path-search'),\n00291|     ('slash/and&amp', 'www.example.com', 'q=slash/and%26amp'),\n00292|     ('unquoted one=1&two=2', 'www.example.org', 'one=1&two=2'),\n00293| ])\n00294| def test_get_search_url(config_stub, url, host, query, open_base_url):\n00295|     \"\"\"Test _get_search_url().\n00296| \n00297|     Args:\n00298|         url: The \"URL\" to enter.\n00299|         host: The expected search machine host.\n00300|         query: The expected search query.\n00301|     \"\"\"\n00302|     config_stub.val.url.open_base_url = open_base_url\n00303|     url = urlutils._get_search_url(url)\n00304|     assert url.host() == host\n00305|     assert url.query() == query\n00306| \n00307| \n00308| @pytest.mark.parametrize('open_base_url', [True, False])\n00309| @pytest.mark.parametrize('url, host, path', [\n00310|     ('path-search t/w/s', 'www.example.org', 't/w/s'),\n00311|     ('quoted-path t/w/s', 'www.example.org', 't%2Fw%2Fs'),\n00312| ])\n00313| def test_get_search_url_for_path_search(config_stub, url, host, path, open_base_url):\n00314|     \"\"\"Test _get_search_url_for_path_search().\n00315| \n00316|     Args:\n00317|         url: The \"URL\" to enter.\n00318|         host: The expected search machine host.\n00319|         path: The expected path on that host that is requested.\n00320|     \"\"\"\n00321|     config_stub.val.url.open_base_url = open_base_url\n00322|     url = urlutils._get_search_url(url)\n00323|     assert url.host() == host\n00324|     assert url.path(options=QUrl.PrettyDecoded) == '/' + path\n00325| \n00326| \n00327| @pytest.mark.parametrize('url, host', [\n00328|     ('test', 'www.qutebrowser.org'),\n00329|     ('test-with-dash', 'www.example.org'),\n00330| ])\n00331| def test_get_search_url_open_base_url(config_stub, url, host):\n00332|     \"\"\"Test _get_search_url() with url.open_base_url_enabled.\n00333| \n00334|     Args:\n00335|         url: The \"URL\" to enter.\n00336|         host: The expected search machine host.\n00337|         query: The expected search query.\n00338|     \"\"\"\n00339|     config_stub.val.url.open_base_url = True\n00340|     url = urlutils._get_search_url(url)\n00341|     assert not url.path()\n00342|     assert not url.fragment()\n00343|     assert not url.query()\n00344|     assert url.host() == host\n00345| \n00346| \n00347| @pytest.mark.parametrize('url', ['\\n', ' ', '\\n '])\n00348| def test_get_search_url_invalid(url):\n00349|     with pytest.raises(ValueError):\n00350|         urlutils._get_search_url(url)\n00351| \n00352| \n00353| @dataclasses.dataclass\n00354| class UrlParams:\n00355| \n00356|     url: QUrl\n00357|     is_url: bool = True\n00358|     is_url_no_autosearch: bool = True\n00359|     use_dns: bool = True\n00360|     is_url_in_schemeless: bool = False\n00361| \n00362| \n00363| @pytest.mark.parametrize('auto_search',\n00364|                          ['dns', 'naive', 'schemeless', 'never'])\n00365| @pytest.mark.parametrize('url_params', [\n00366|     # Normal hosts\n00367|     UrlParams('http://foobar', use_dns=False, is_url_in_schemeless=True),\n00368|     UrlParams('localhost:8080', use_dns=False, is_url_in_schemeless=True),\n00369|     UrlParams('qutebrowser.org'),\n00370|     UrlParams(' qutebrowser.org '),\n00371|     UrlParams('http://user:password@example.com/foo?bar=baz#fish',\n00372|               use_dns=False, is_url_in_schemeless=True),\n00373|     UrlParams('existing-tld.domains'),\n00374|     # Internationalized domain names\n00375|     UrlParams('\\u4E2D\\u56FD.\\u4E2D\\u56FD'),  # Chinese TLD\n00376|     UrlParams('xn--fiqs8s.xn--fiqs8s'),  # The same in punycode\n00377|     # Encoded space in explicit url\n00378|     UrlParams('http://sharepoint/sites/it/IT%20Documentation/Forms/AllItems.aspx', use_dns=False, is_url_in_schemeless=True),\n00379|     # IPs\n00380|     UrlParams('127.0.0.1', use_dns=False),\n00381|     UrlParams('::1', use_dns=False),\n00382|     UrlParams('2001:41d0:2:6c11::1'),\n00383|     UrlParams('[2001:41d0:2:6c11::1]:8000'),\n00384|     UrlParams('94.23.233.17'),\n00385|     UrlParams('94.23.233.17:8000'),\n00386|     # Special URLs\n00387|     UrlParams('file:///tmp/foo', use_dns=False, is_url_in_schemeless=True),\n00388|     UrlParams('about:blank', use_dns=False, is_url_in_schemeless=True),\n00389|     UrlParams('qute:version', use_dns=False, is_url_in_schemeless=True),\n00390|     UrlParams('qute://version', use_dns=False, is_url_in_schemeless=True),\n00391|     UrlParams('localhost', use_dns=False),\n00392|     # _has_explicit_scheme False, special_url True\n00393|     UrlParams('qute::foo', use_dns=False),\n00394|     UrlParams('qute:://foo', use_dns=False),\n00395|     # Invalid URLs\n00396|     UrlParams('', is_url=False, is_url_no_autosearch=False, use_dns=False),\n00397|     UrlParams('onlyscheme:', is_url=False, use_dns=False),\n00398|     UrlParams('http:foo:0', is_url=False, use_dns=False),\n00399|     # Not URLs\n00400|     UrlParams('foo bar', is_url=False, use_dns=False),  # no DNS b/c of space\n00401|     UrlParams('localhost test', is_url=False, use_dns=False),  # no DNS b/c spc\n00402|     UrlParams('another . test', is_url=False, use_dns=False),  # no DNS b/c spc\n00403|     UrlParams('foo', is_url=False),\n00404|     UrlParams('this is: not a URL', is_url=False, use_dns=False),  # no DNS spc\n00405|     UrlParams('foo user@host.tld', is_url=False, use_dns=False),  # no DNS, spc\n00406|     UrlParams('23.42', is_url=False, use_dns=False),  # no DNS b/c bogus-IP\n00407|     UrlParams('1337', is_url=False, use_dns=False),  # no DNS b/c bogus-IP\n00408|     UrlParams('deadbeef', is_url=False),\n00409|     UrlParams('hello.', is_url=False),\n00410|     UrlParams('site:cookies.com oatmeal raisin', is_url=False, use_dns=False),\n00411|     UrlParams('example.search_string', is_url=False),\n00412|     UrlParams('example_search.string', is_url=False),\n00413|     # no DNS because there is no host\n00414|     UrlParams('foo::bar', is_url=False, use_dns=False),\n00415|     # Valid search term with autosearch\n00416|     UrlParams('test foo', is_url=False,\n00417|               is_url_no_autosearch=False, use_dns=False),\n00418|     UrlParams('test user@host.tld', is_url=False,\n00419|               is_url_no_autosearch=False, use_dns=False),\n00420|     # autosearch = False\n00421|     UrlParams('This is a URL without autosearch', is_url=False, use_dns=False),\n00422| ], ids=lambda param: 'URL: ' + param.url)\n00423| def test_is_url(config_stub, fake_dns, auto_search, url_params):\n00424|     \"\"\"Test is_url().\n00425| \n00426|     Args:\n00427|         auto_search: With which auto_search setting to test\n00428|         url_params: instance of UrlParams; each containing the following attrs\n00429|         * url: The URL to test, as a string.\n00430|         * is_url: Whether the given string is considered a URL when auto_search\n00431|                   is either dns or naive. [default: True]\n00432|         * is_url_no_autosearch: Whether the given string is a URL with\n00433|                                 auto_search false. [default: True]\n00434|         * use_dns: Whether the given string should fire a DNS request for the\n00435|                    given URL. [default: True]\n00436|         * is_url_in_schemeless: Whether the given string is treated as a URL\n00437|                                 when auto_search=schemeless. [default: False]\n00438|     \"\"\"\n00439|     url = url_params.url\n00440|     is_url = url_params.is_url\n00441|     is_url_no_autosearch = url_params.is_url_no_autosearch\n00442|     use_dns = url_params.use_dns\n00443|     is_url_in_schemeless = url_params.is_url_in_schemeless\n00444| \n00445|     config_stub.val.url.auto_search = auto_search\n00446|     if auto_search == 'dns':\n00447|         if use_dns:\n00448|             fake_dns.answer = True\n00449|             result = urlutils.is_url(url)\n00450|             assert fake_dns.used\n00451|             assert result\n00452|             fake_dns.reset()\n00453| \n00454|             fake_dns.answer = False\n00455|             result = urlutils.is_url(url)\n00456|             assert fake_dns.used\n00457|             assert not result\n00458|         else:\n00459|             result = urlutils.is_url(url)\n00460|             assert not fake_dns.used\n00461|             assert result == is_url\n00462|     elif auto_search == 'schemeless':\n00463|         assert urlutils.is_url(url) == is_url_in_schemeless\n00464|         assert not fake_dns.used\n00465|     elif auto_search == 'naive':\n00466|         assert urlutils.is_url(url) == is_url\n00467|         assert not fake_dns.used\n00468|     elif auto_search == 'never':\n00469|         assert urlutils.is_url(url) == is_url_no_autosearch\n00470|         assert not fake_dns.used\n00471|     else:\n00472|         raise ValueError(\"Invalid value {!r} for auto_search!\".format(\n00473|             auto_search))\n00474| \n00475| \n00476| @pytest.mark.parametrize('auto_search, open_base_url, is_url', [\n00477|     ('naive', True, False),\n00478|     ('naive', False, False),\n00479|     ('never', True, False),\n00480|     ('never', False, True),\n00481| ])\n00482| def test_searchengine_is_url(config_stub, auto_search, open_base_url, is_url):\n00483|     config_stub.val.url.auto_search = auto_search\n00484|     config_stub.val.url.open_base_url = open_base_url\n00485|     assert urlutils.is_url('test') == is_url\n00486| \n00487| \n00488| @pytest.mark.parametrize('url, valid, has_err_string', [\n00489|     ('http://www.example.com/', True, False),\n00490|     ('', False, False),\n00491|     ('://', False, True),\n00492| ])\n00493| def test_invalid_url_error(message_mock, caplog, url, valid, has_err_string):\n00494|     \"\"\"Test invalid_url_error().\n00495| \n00496|     Args:\n00497|         url: The URL to check.\n00498|         valid: Whether the QUrl is valid (isValid() == True).\n00499|         has_err_string: Whether the QUrl is expected to have errorString set.\n00500|     \"\"\"\n00501|     qurl = QUrl(url)\n00502|     assert qurl.isValid() == valid\n00503|     if valid:\n00504|         with pytest.raises(ValueError):\n00505|             urlutils.invalid_url_error(qurl, '')\n00506|         assert not message_mock.messages\n00507|     else:\n00508|         assert bool(qurl.errorString()) == has_err_string\n00509|         with caplog.at_level(logging.ERROR):\n00510|             urlutils.invalid_url_error(qurl, 'frozzle')\n00511| \n00512|         msg = message_mock.getmsg(usertypes.MessageLevel.error)\n00513|         if has_err_string:\n00514|             expected_text = (\"Trying to frozzle with invalid URL - \" +\n00515|                              qurl.errorString())\n00516|         else:\n00517|             expected_text = \"Trying to frozzle with invalid URL\"\n00518|         assert msg.text == expected_text\n00519| \n00520| \n00521| @pytest.mark.parametrize('url, valid, has_err_string', [\n00522|     ('http://www.example.com/', True, False),\n00523|     ('', False, False),\n00524|     ('://', False, True),\n00525| ])\n00526| def test_raise_cmdexc_if_invalid(url, valid, has_err_string):\n00527|     \"\"\"Test raise_cmdexc_if_invalid.\n00528| \n00529|     Args:\n00530|         url: The URL to check.\n00531|         valid: Whether the QUrl is valid (isValid() == True).\n00532|         has_err_string: Whether the QUrl is expected to have errorString set.\n00533|     \"\"\"\n00534|     qurl = QUrl(url)\n00535|     assert qurl.isValid() == valid\n00536|     if valid:\n00537|         urlutils.raise_cmdexc_if_invalid(qurl)\n00538|     else:\n00539|         assert bool(qurl.errorString()) == has_err_string\n00540|         if has_err_string:\n00541|             expected_text = \"Invalid URL - \" + qurl.errorString()\n00542|         else:\n00543|             expected_text = \"Invalid URL\"\n00544|         with pytest.raises(cmdutils.CommandError, match=expected_text):\n00545|             urlutils.raise_cmdexc_if_invalid(qurl)\n00546| \n00547| \n00548| @pytest.mark.parametrize('qurl, output', [\n00549|     (QUrl(), None),\n00550|     (QUrl('http://qutebrowser.org/test.html'), 'test.html'),\n00551|     (QUrl('http://qutebrowser.org/foo.html#bar'), 'foo.html'),\n00552|     (QUrl('http://user:password@qutebrowser.org/foo?bar=baz#fish'), 'foo'),\n00553|     (QUrl('http://qutebrowser.org/'), 'qutebrowser.org.html'),\n00554|     (QUrl('qute://'), None),\n00555|     # data URL support\n00556|     (QUrl('data:text/plain,'), 'download.txt'),\n00557|     (QUrl('data:application/pdf,'), 'download.pdf'),\n00558|     (QUrl('data:foo/bar,'), 'download'),  # unknown extension\n00559|     (QUrl('data:text/xul,'), 'download.xul'),  # strict=False\n00560|     (QUrl('data:'), None),  # invalid data URL\n00561| ])\n00562| def test_filename_from_url(qurl, output):\n00563|     assert urlutils.filename_from_url(qurl) == output\n00564| \n00565| \n00566| @pytest.mark.parametrize('qurl', [QUrl(), QUrl('qute://'), QUrl('data:')])\n00567| def test_filename_from_url_fallback(qurl):\n00568|     assert urlutils.filename_from_url(qurl, fallback='fallback') == 'fallback'\n00569| \n00570| \n00571| @pytest.mark.parametrize('qurl, expected', [\n00572|     (QUrl('ftp://example.com/'), ('ftp', 'example.com', 21)),\n00573|     (QUrl('ftp://example.com:2121/'), ('ftp', 'example.com', 2121)),\n00574|     (QUrl('http://qutebrowser.org:8010/waterfall'),\n00575|      ('http', 'qutebrowser.org', 8010)),\n00576|     (QUrl('https://example.com/'), ('https', 'example.com', 443)),\n00577|     (QUrl('https://example.com:4343/'), ('https', 'example.com', 4343)),\n00578|     (QUrl('http://user:password@qutebrowser.org/foo?bar=baz#fish'),\n00579|      ('http', 'qutebrowser.org', 80)),\n00580| ])\n00581| def test_host_tuple_valid(qurl, expected):\n00582|     assert urlutils.host_tuple(qurl) == expected\n00583| \n00584| \n00585| @pytest.mark.parametrize('qurl, expected', [\n00586|     (QUrl(), urlutils.InvalidUrlError),\n00587|     (QUrl('qute://'), ValueError),\n00588|     (QUrl('qute://foobar'), ValueError),\n00589|     (QUrl('mailto:nobody'), ValueError),\n00590| ])\n00591| def test_host_tuple_invalid(qurl, expected):\n00592|     with pytest.raises(expected):\n00593|         urlutils.host_tuple(qurl)\n00594| \n00595| \n00596| class TestInvalidUrlError:\n00597| \n00598|     @pytest.mark.parametrize('url, raising, has_err_string', [\n00599|         (QUrl(), False, False),\n00600|         (QUrl('http://www.example.com/'), True, False),\n00601|         (QUrl('://'), False, True),\n00602|     ])\n00603|     def test_invalid_url_error(self, url, raising, has_err_string):\n00604|         \"\"\"Test InvalidUrlError.\n00605| \n00606|         Args:\n00607|             url: The URL to pass to InvalidUrlError.\n00608|             raising; True if the InvalidUrlError should raise itself.\n00609|             has_err_string: Whether the QUrl is expected to have errorString\n00610|                             set.\n00611|         \"\"\"\n00612|         if raising:\n00613|             expected_exc = ValueError\n00614|         else:\n00615|             expected_exc = urlutils.InvalidUrlError\n00616| \n00617|         with pytest.raises(expected_exc) as excinfo:\n00618|             raise urlutils.InvalidUrlError(url)\n00619| \n00620|         if not raising:\n00621|             expected_text = \"Invalid URL\"\n00622|             if has_err_string:\n00623|                 expected_text += \" - \" + url.errorString()\n00624|             assert str(excinfo.value) == expected_text\n00625| \n00626| \n00627| @pytest.mark.parametrize('are_same, url1, url2', [\n00628|     (True, 'http://example.com', 'http://www.example.com'),\n00629|     (True, 'http://bbc.co.uk', 'http://www.bbc.co.uk'),\n00630|     (True, 'http://many.levels.of.domains.example.com', 'http://www.example.com'),\n00631|     (True, 'http://idn..museum', 'http://idn2..museum'),\n00632|     (True, 'http://one.not_a_valid_tld', 'http://one.not_a_valid_tld'),\n00633| \n00634|     (False, 'http://bbc.co.uk', 'http://example.co.uk'),\n00635|     (False, 'https://example.kids.museum', 'http://example.kunst.museum'),\n00636|     (False, 'http://idn..museum', 'http://idn..museum'),\n00637|     (False, 'http://one.not_a_valid_tld', 'http://two.not_a_valid_tld'),\n00638| \n00639|     (False, 'http://example.org', 'https://example.org'),  # different scheme\n00640|     (False, 'http://example.org:80', 'http://example.org:8080'),  # different port\n00641| ])\n00642| def test_same_domain(are_same, url1, url2):\n00643|     \"\"\"Test same_domain.\"\"\"\n00644|     assert urlutils.same_domain(QUrl(url1), QUrl(url2)) == are_same\n00645|     assert urlutils.same_domain(QUrl(url2), QUrl(url1)) == are_same\n00646| \n00647| \n00648| @pytest.mark.parametrize('url1, url2', [\n00649|     ('http://example.com', ''),\n00650|     ('', 'http://example.com'),\n00651| ])\n00652| def test_same_domain_invalid_url(url1, url2):\n00653|     \"\"\"Test same_domain with invalid URLs.\"\"\"\n00654|     with pytest.raises(urlutils.InvalidUrlError):\n00655|         urlutils.same_domain(QUrl(url1), QUrl(url2))\n00656| \n00657| \n00658| @pytest.mark.parametrize('url, expected', [\n00659|     ('http://example.com', 'http://example.com'),\n00660|     ('http://nicode.com', 'http://xn--nicode-2ya.com'),\n00661|     ('http://foo.bar/?header=text/plin',\n00662|      'http://foo.bar/?header=text/pl%C3%A4in'),\n00663| ])\n00664| def test_encoded_url(url, expected):\n00665|     url = QUrl(url)\n00666|     assert urlutils.encoded_url(url) == expected\n00667| \n00668| \n00669| def test_file_url():\n00670|     assert urlutils.file_url('/foo/bar') == 'file:///foo/bar'\n00671| \n00672| \n00673| def test_data_url():\n00674|     url = urlutils.data_url('text/plain', b'foo')\n00675|     assert url == QUrl('data:text/plain;base64,Zm9v')\n00676| \n00677| \n00678| @pytest.mark.parametrize('url, expected', [\n00679|     # No IDN\n00680|     (QUrl('http://www.example.com'), 'http://www.example.com'),\n00681|     # IDN in domain\n00682|     (QUrl('http://www..com'), '(www.xn--4ca.com) http://www..com'),\n00683|     # IDN with non-whitelisted TLD\n00684|     (QUrl('http://www..foo'), 'http://www.xn--4ca.foo'),\n00685|     # Unicode only in path\n00686|     (QUrl('http://www.example.com/'), 'http://www.example.com/'),\n00687|     # Unicode only in TLD (looks like Qt shows Punycode with ...)\n00688|     (QUrl('http://www.example.xn--p1ai'),\n00689|      '(www.example.xn--p1ai) http://www.example.'),\n00690|     # https://bugreports.qt.io/browse/QTBUG-60364\n00691|     (QUrl('http://www.xn--80ak6aa92e.com'),\n00692|      'http://www.xn--80ak6aa92e.com'),\n00693| ])\n00694| def test_safe_display_string(url, expected):\n00695|     assert urlutils.safe_display_string(url) == expected\n00696| \n00697| \n00698| def test_safe_display_string_invalid():\n00699|     with pytest.raises(urlutils.InvalidUrlError):\n00700|         urlutils.safe_display_string(QUrl())\n00701| \n00702| \n00703| class TestProxyFromUrl:\n00704| \n00705|     @pytest.mark.parametrize('url, expected', [\n00706|         ('socks://example.com/',\n00707|          QNetworkProxy(QNetworkProxy.Socks5Proxy, 'example.com')),\n00708|         ('socks5://example.com',\n00709|          QNetworkProxy(QNetworkProxy.Socks5Proxy, 'example.com')),\n00710|         ('socks5://example.com:2342',\n00711|          QNetworkProxy(QNetworkProxy.Socks5Proxy, 'example.com', 2342)),\n00712|         ('socks5://foo@example.com',\n00713|          QNetworkProxy(QNetworkProxy.Socks5Proxy, 'example.com', 0, 'foo')),\n00714|         ('socks5://foo:bar@example.com',\n00715|          QNetworkProxy(QNetworkProxy.Socks5Proxy, 'example.com', 0, 'foo',\n00716|                        'bar')),\n00717|         ('socks5://foo:bar@example.com:2323',\n00718|          QNetworkProxy(QNetworkProxy.Socks5Proxy, 'example.com', 2323,\n00719|                        'foo', 'bar')),\n00720|         ('direct://', QNetworkProxy(QNetworkProxy.NoProxy)),\n00721|     ])\n00722|     def test_proxy_from_url_valid(self, url, expected):\n00723|         assert urlutils.proxy_from_url(QUrl(url)) == expected\n00724| \n00725|     @pytest.mark.parametrize('scheme', ['pac+http', 'pac+https'])\n00726|     def test_proxy_from_url_pac(self, scheme, qapp):\n00727|         fetcher = urlutils.proxy_from_url(QUrl('{}://foo'.format(scheme)))\n00728|         assert isinstance(fetcher, pac.PACFetcher)\n00729| \n00730|     @pytest.mark.parametrize('url, exception', [\n00731|         ('blah', urlutils.InvalidProxyTypeError),\n00732|         (':', urlutils.InvalidUrlError),  # invalid URL\n00733|         # Invalid/unsupported scheme\n00734|         ('ftp://example.com/', urlutils.InvalidProxyTypeError),\n00735|         ('socks4://example.com/', urlutils.InvalidProxyTypeError),\n00736|     ])\n00737|     def test_invalid(self, url, exception):\n00738|         with pytest.raises(exception):\n00739|             urlutils.proxy_from_url(QUrl(url))\n00740| \n00741| \n00742| class TestParseJavascriptUrl:\n00743| \n00744|     @pytest.mark.parametrize('url, message', [\n00745|         (QUrl(), \"\"),\n00746|         (QUrl('https://example.com'), \"Expected a javascript:... URL\"),\n00747|         (QUrl('javascript://example.com'),\n00748|          \"URL contains unexpected components: example.com\"),\n00749|         (QUrl('javascript://foo:bar@example.com:1234'),\n00750|          \"URL contains unexpected components: foo:bar@example.com:1234\"),\n00751|     ])\n00752|     def test_invalid(self, url, message):\n00753|         with pytest.raises(urlutils.Error, match=message):\n00754|             urlutils.parse_javascript_url(url)\n00755| \n00756|     @pytest.mark.parametrize('url, source', [\n00757|         (QUrl('javascript:\"hello\" %0a \"world\"'), '\"hello\" \\n \"world\"'),\n00758|         (QUrl('javascript:/'), '/'),\n00759|         (QUrl('javascript:///'), '///'),\n00760|         # https://github.com/web-platform-tests/wpt/blob/master/html/browsers/browsing-the-web/navigating-across-documents/javascript-url-query-fragment-components.html\n00761|         (QUrl('javascript:\"nope\" ? \"yep\" : \"what\";'), '\"nope\" ? \"yep\" : \"what\";'),\n00762|         (QUrl('javascript:\"wrong\"; // # %0a \"ok\";'), '\"wrong\"; // # \\n \"ok\";'),\n00763|         (QUrl('javascript:\"%252525 ? %252525 # %252525\"'),\n00764|          '\"%2525 ? %2525 # %2525\"'),\n00765|     ])\n00766|     def test_valid(self, url, source):\n00767|         assert urlutils.parse_javascript_url(url) == source\n00768| \n00769|     @hypothesis.given(source=hypothesis.strategies.text())\n00770|     def test_hypothesis(self, source):\n00771|         scheme = 'javascript:'\n00772|         url = QUrl(scheme + urllib.parse.quote(source))\n00773|         hypothesis.assume(url.isValid())\n00774| \n00775|         try:\n00776|             parsed = urlutils.parse_javascript_url(url)\n00777|         except urlutils.Error:\n00778|             pass\n00779|         else:\n00780|             assert parsed == source\n00781| \n00782| \n00783| class TestWiden:\n00784| \n00785|     @pytest.mark.parametrize('hostname, expected', [\n00786|         ('a.b.c', ['a.b.c', 'b.c', 'c']),\n00787|         ('foobarbaz', ['foobarbaz']),\n00788|         ('', []),\n00789|         ('.c', ['.c', 'c']),\n00790|         ('c.', ['c.']),\n00791|         ('.c.', ['.c.', 'c.']),\n00792|         (None, []),\n00793|     ])\n00794|     def test_widen_hostnames(self, hostname, expected):\n00795|         assert list(urlutils.widened_hostnames(hostname)) == expected\n00796| \n00797|     @pytest.mark.parametrize('hostname', [\n00798|         'test.qutebrowser.org',\n00799|         'a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.z.y.z',\n00800|         'qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq.c',\n00801|     ])\n00802|     def test_bench_widen_hostnames(self, hostname, benchmark):\n00803|         benchmark(lambda: list(urlutils.widened_hostnames(hostname)))\n00804| \n\n(End of file - total 804 lines)\n</file>",
            "title": "tests/unit/utils/test_urlutils.py",
            "metadata": {
              "preview": "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n\n# Copyright 2014-2021 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n#\n# This file is part of qutebrowser.\n#\n# qutebrowser is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# qutebrowser is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with qutebrowser.  If not, see <https://www.gnu.org/licenses/>.\n\n\"\"\"Tests for qutebrowser.utils.urlutils.\"\"\"",
              "truncated": false
            },
            "time": {
              "start": 1769437370384,
              "end": 1769437370393
            }
          }
        },
        {
          "id": "prt_bfaaf9818001BJ1s7Vu0y7LMM5",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfaaf89ec001CTMUkv3VT0awN5",
          "type": "tool",
          "callID": "toolu_01PXpQH5guxxRvZfgcswcv2o",
          "tool": "read",
          "state": {
            "status": "completed",
            "input": {
              "filePath": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/config/test_configutils.py"
            },
            "output": "<file>\n00001| # vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n00002| \n00003| # Copyright 2018-2021 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n00004| #\n00005| # This file is part of qutebrowser.\n00006| #\n00007| # qutebrowser is free software: you can redistribute it and/or modify\n00008| # it under the terms of the GNU General Public License as published by\n00009| # the Free Software Foundation, either version 3 of the License, or\n00010| # (at your option) any later version.\n00011| #\n00012| # qutebrowser is distributed in the hope that it will be useful,\n00013| # but WITHOUT ANY WARRANTY; without even the implied warranty of\n00014| # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n00015| # GNU General Public License for more details.\n00016| #\n00017| # You should have received a copy of the GNU General Public License\n00018| # along with qutebrowser.  If not, see <https://www.gnu.org/licenses/>.\n00019| \n00020| import hypothesis\n00021| from hypothesis import strategies\n00022| import pytest\n00023| from PyQt5.QtCore import QUrl\n00024| from PyQt5.QtWidgets import QLabel\n00025| \n00026| from qutebrowser.config import configutils, configdata, configtypes, configexc\n00027| from qutebrowser.utils import urlmatch, usertypes, qtutils\n00028| from tests.helpers import testutils\n00029| \n00030| \n00031| @pytest.fixture\n00032| def opt():\n00033|     return configdata.Option(name='example.option', typ=configtypes.String(),\n00034|                              default='default value', backends=None,\n00035|                              raw_backends=None, description=None,\n00036|                              supports_pattern=True)\n00037| \n00038| \n00039| @pytest.fixture\n00040| def pattern():\n00041|     return urlmatch.UrlPattern('*://www.example.com/')\n00042| \n00043| \n00044| @pytest.fixture\n00045| def other_pattern():\n00046|     return urlmatch.UrlPattern('https://www.example.org/')\n00047| \n00048| \n00049| @pytest.fixture\n00050| def values(opt, pattern):\n00051|     scoped_values = [configutils.ScopedValue('global value', None),\n00052|                      configutils.ScopedValue('example value', pattern)]\n00053|     return configutils.Values(opt, scoped_values)\n00054| \n00055| \n00056| @pytest.fixture\n00057| def mixed_values(opt, pattern):\n00058|     scoped_values = [configutils.ScopedValue('global value', None),\n00059|                      configutils.ScopedValue('example value', pattern,\n00060|                                              hide_userconfig=True)]\n00061|     return configutils.Values(opt, scoped_values)\n00062| \n00063| \n00064| @pytest.fixture\n00065| def empty_values(opt):\n00066|     return configutils.Values(opt)\n00067| \n00068| \n00069| def test_str(values):\n00070|     expected = [\n00071|         'example.option = global value',\n00072|         '*://www.example.com/: example.option = example value',\n00073|     ]\n00074|     assert str(values) == '\\n'.join(expected)\n00075| \n00076| \n00077| def test_str_empty(empty_values):\n00078|     assert str(empty_values) == 'example.option: <unchanged>'\n00079| \n00080| \n00081| def test_str_mixed(mixed_values):\n00082|     expected = [\n00083|         'example.option = global value',\n00084|         '*://www.example.com/: example.option = example value',\n00085|     ]\n00086|     assert str(mixed_values) == '\\n'.join(expected)\n00087| \n00088| \n00089| @pytest.mark.parametrize('include_hidden, expected', [\n00090|     (True, ['example.option = global value',\n00091|             '*://www.example.com/: example.option = example value']),\n00092|     (False, ['example.option = global value']),\n00093| ])\n00094| def test_dump(mixed_values, include_hidden, expected):\n00095|     assert mixed_values.dump(include_hidden=include_hidden) == expected\n00096| \n00097| \n00098| def test_bool(values, empty_values):\n00099|     assert values\n00100|     assert not empty_values\n00101| \n00102| \n00103| def test_iter(values):\n00104|     assert list(iter(values)) == list(iter(values._vmap.values()))\n00105| \n00106| \n00107| def test_add_existing(values):\n00108|     values.add('new global value')\n00109|     assert values.get_for_url() == 'new global value'\n00110| \n00111| \n00112| def test_add_new(values, other_pattern):\n00113|     values.add('example.org value', other_pattern)\n00114|     assert values.get_for_url() == 'global value'\n00115|     example_com = QUrl('https://www.example.com/')\n00116|     example_org = QUrl('https://www.example.org/')\n00117|     assert values.get_for_url(example_com) == 'example value'\n00118|     assert values.get_for_url(example_org) == 'example.org value'\n00119| \n00120| \n00121| def test_remove_existing(values, pattern):\n00122|     removed = values.remove(pattern)\n00123|     assert removed\n00124| \n00125|     url = QUrl('https://www.example.com/')\n00126|     assert values.get_for_url(url) == 'global value'\n00127| \n00128| \n00129| def test_remove_non_existing(values, other_pattern):\n00130|     removed = values.remove(other_pattern)\n00131|     assert not removed\n00132| \n00133|     url = QUrl('https://www.example.com/')\n00134|     assert values.get_for_url(url) == 'example value'\n00135| \n00136| \n00137| def test_clear(values):\n00138|     assert values\n00139|     values.clear()\n00140|     assert not values\n00141|     assert values.get_for_url(fallback=False) is usertypes.UNSET\n00142| \n00143| \n00144| def test_get_matching(values):\n00145|     url = QUrl('https://www.example.com/')\n00146|     assert values.get_for_url(url, fallback=False) == 'example value'\n00147| \n00148| \n00149| def test_get_invalid(values):\n00150|     with pytest.raises(qtutils.QtValueError):\n00151|         values.get_for_url(QUrl())\n00152| \n00153| \n00154| def test_get_unset(empty_values):\n00155|     assert empty_values.get_for_url(fallback=False) is usertypes.UNSET\n00156| \n00157| \n00158| def test_get_no_global(empty_values, other_pattern, pattern):\n00159|     empty_values.add('example.org value', pattern)\n00160|     assert empty_values.get_for_url(fallback=False) is usertypes.UNSET\n00161| \n00162| \n00163| def test_get_unset_fallback(empty_values):\n00164|     assert empty_values.get_for_url() == 'default value'\n00165| \n00166| \n00167| def test_get_non_matching(values):\n00168|     url = QUrl('https://www.example.ch/')\n00169|     assert values.get_for_url(url, fallback=False) is usertypes.UNSET\n00170| \n00171| \n00172| def test_get_non_matching_fallback(values):\n00173|     url = QUrl('https://www.example.ch/')\n00174|     assert values.get_for_url(url) == 'global value'\n00175| \n00176| \n00177| def test_get_multiple_matches(values):\n00178|     \"\"\"With multiple matching pattern, the last added should win.\"\"\"\n00179|     all_pattern = urlmatch.UrlPattern('*://*/')\n00180|     values.add('new value', all_pattern)\n00181|     url = QUrl('https://www.example.com/')\n00182|     assert values.get_for_url(url) == 'new value'\n00183| \n00184| \n00185| def test_get_non_domain_patterns(empty_values):\n00186|     \"\"\"With multiple matching pattern, the last added should win.\"\"\"\n00187|     pat1 = urlmatch.UrlPattern('*://*/*')\n00188|     empty_values.add('fallback')\n00189|     empty_values.add('value', pat1)\n00190| \n00191|     assert empty_values.get_for_url(QUrl(\"http://qutebrowser.org\")) == 'value'\n00192|     assert empty_values.get_for_url() == 'fallback'\n00193| \n00194| \n00195| def test_get_matching_pattern(values, pattern):\n00196|     assert values.get_for_pattern(pattern, fallback=False) == 'example value'\n00197| \n00198| \n00199| def test_get_pattern_none(values, pattern):\n00200|     assert values.get_for_pattern(None, fallback=False) == 'global value'\n00201| \n00202| \n00203| def test_get_unset_pattern(empty_values, pattern):\n00204|     value = empty_values.get_for_pattern(pattern, fallback=False)\n00205|     assert value is usertypes.UNSET\n00206| \n00207| \n00208| def test_get_no_global_pattern(empty_values, pattern, other_pattern):\n00209|     empty_values.add('example.org value', other_pattern)\n00210|     value = empty_values.get_for_pattern(pattern, fallback=False)\n00211|     assert value is usertypes.UNSET\n00212| \n00213| \n00214| def test_get_unset_fallback_pattern(empty_values, pattern):\n00215|     assert empty_values.get_for_pattern(pattern) == 'default value'\n00216| \n00217| \n00218| def test_get_non_matching_pattern(values, other_pattern):\n00219|     value = values.get_for_pattern(other_pattern, fallback=False)\n00220|     assert value is usertypes.UNSET\n00221| \n00222| \n00223| def test_get_non_matching_fallback_pattern(values, other_pattern):\n00224|     assert values.get_for_pattern(other_pattern) == 'global value'\n00225| \n00226| \n00227| def test_get_equivalent_patterns(empty_values):\n00228|     \"\"\"With multiple matching pattern, the last added should win.\"\"\"\n00229|     pat1 = urlmatch.UrlPattern('https://www.example.com/')\n00230|     pat2 = urlmatch.UrlPattern('*://www.example.com/')\n00231|     empty_values.add('pat1 value', pat1)\n00232|     empty_values.add('pat2 value', pat2)\n00233| \n00234|     assert empty_values.get_for_pattern(pat1) == 'pat1 value'\n00235|     assert empty_values.get_for_pattern(pat2) == 'pat2 value'\n00236| \n00237| \n00238| def test_get_trailing_dot(values):\n00239|     \"\"\"A domain with a trailing dot should be equivalent to the same without.\n00240| \n00241|     See http://www.dns-sd.org/trailingdotsindomainnames.html\n00242| \n00243|     Thus, we expect to get the same setting for both.\n00244|     \"\"\"\n00245|     other_pattern = urlmatch.UrlPattern('https://www.example.org./')\n00246|     values.add('example.org value', other_pattern)\n00247|     assert values.get_for_url() == 'global value'\n00248|     example_com = QUrl('https://www.example.com/')\n00249|     example_org = QUrl('https://www.example.org./')\n00250|     example_org_2 = QUrl('https://www.example.org/')\n00251|     assert values.get_for_url(example_com) == 'example value'\n00252|     assert (values.get_for_url(example_org) ==\n00253|             values.get_for_url(example_org_2) ==\n00254|             'example.org value')\n00255| \n00256| \n00257| @pytest.mark.parametrize('func', [\n00258|     pytest.param(lambda values, pattern:\n00259|                  values.add(None, pattern),\n00260|                  id='add'),\n00261|     pytest.param(lambda values, pattern:\n00262|                  values.remove(pattern),\n00263|                  id='remove'),\n00264|     pytest.param(lambda values, pattern:\n00265|                  values.get_for_url(QUrl('https://example.org/')),\n00266|                  id='get_for_url'),\n00267|     pytest.param(lambda values, pattern:\n00268|                  values.get_for_pattern(pattern),\n00269|                  id='get_for_pattern'),\n00270| ])\n00271| def test_no_pattern_support(func, opt, pattern):\n00272|     opt.supports_pattern = False\n00273|     values = configutils.Values(opt, [])\n00274| \n00275|     with pytest.raises(configexc.NoPatternError):\n00276|         func(values, pattern)\n00277| \n00278| \n00279| def test_add_url_benchmark(values, benchmark):\n00280|     blocked_hosts = list(testutils.blocked_hosts())\n00281| \n00282|     def _add_blocked():\n00283|         for line in blocked_hosts:\n00284|             values.add(False, urlmatch.UrlPattern(line))\n00285| \n00286|     benchmark(_add_blocked)\n00287| \n00288| \n00289| @pytest.mark.parametrize('url', [\n00290|     'http://www.qutebrowser.com/',\n00291|     'http://foo.bar.baz/',\n00292|     'http://bop.foo.bar.baz/',\n00293| ])\n00294| def test_domain_lookup_sparse_benchmark(url, values, benchmark):\n00295|     url = QUrl(url)\n00296|     values.add(False, urlmatch.UrlPattern(\"*.foo.bar.baz\"))\n00297|     for line in testutils.blocked_hosts():\n00298|         values.add(False, urlmatch.UrlPattern(line))\n00299| \n00300|     benchmark(lambda: values.get_for_url(url))\n00301| \n00302| \n00303| class TestFontFamilies:\n00304| \n00305|     @pytest.mark.parametrize('family_str, expected', [\n00306|         ('foo, bar', ['foo', 'bar']),\n00307|         ('foo,   spaces ', ['foo', 'spaces']),\n00308|         ('', []),\n00309|         ('foo, ', ['foo']),\n00310|         ('\"One Font\", Two', ['One Font', 'Two']),\n00311|         (\"One, 'Two Fonts'\", ['One', 'Two Fonts']),\n00312|         (\"One, 'Two Fonts', 'Three'\", ['One', 'Two Fonts', 'Three']),\n00313|         (\"\\\"Weird font name: '\\\"\", [\"Weird font name: '\"]),\n00314|     ])\n00315|     def test_from_str(self, family_str, expected):\n00316|         assert list(configutils.FontFamilies.from_str(family_str)) == expected\n00317| \n00318|     @pytest.mark.parametrize('families, quote, expected', [\n00319|         (['family'], True, 'family'),\n00320|         (['family1', 'family2'], True, 'family1, family2'),\n00321|         (['family'], True, 'family'),\n00322|         (['space family', 'alien'], True, '\"space family\", alien'),\n00323|         (['comma,family', 'period'], True, '\"comma,family\", period'),\n00324| \n00325|         (['family'], False, 'family'),\n00326|         (['family1', 'family2'], False, 'family1, family2'),\n00327|         (['family'], False, 'family'),\n00328|         (['space family', 'alien'], False, 'space family, alien'),\n00329|         (['comma,family', 'period'], False, 'comma,family, period'),\n00330|     ])\n00331|     def test_to_str(self, families, quote, expected):\n00332|         ff = configutils.FontFamilies(families)\n00333|         assert ff.to_str(quote=quote) == expected\n00334|         if quote:\n00335|             assert str(ff) == expected\n00336| \n00337|     @hypothesis.given(strategies.text())\n00338|     def test_from_str_hypothesis(self, family_str):\n00339|         families = configutils.FontFamilies.from_str(family_str)\n00340| \n00341|         for family in families:\n00342|             assert family\n00343| \n00344|         str(families)\n00345| \n00346|     def test_system_default_basics(self, qapp):\n00347|         families = configutils.FontFamilies.from_system_default()\n00348|         assert len(families) == 1\n00349|         assert str(families)\n00350| \n00351|     def test_system_default_rendering(self, qtbot):\n00352|         families = configutils.FontFamilies.from_system_default()\n00353| \n00354|         label = QLabel()\n00355|         qtbot.add_widget(label)\n00356|         label.setText(\"Hello World\")\n00357| \n00358|         stylesheet = f'font-family: {families.to_str(quote=True)}'\n00359|         print(stylesheet)\n00360|         label.setStyleSheet(stylesheet)\n00361| \n00362|         with qtbot.wait_exposed(label):\n00363|             # Needed so the font gets calculated\n00364|             label.show()\n00365|         info = label.fontInfo()\n00366| \n00367|         # Check the requested font to make sure CSS parsing worked\n00368|         assert label.font().family() == families.family\n00369| \n00370|         # Try to find out whether the monospace font did a fallback on a non-monospace\n00371|         # font...\n00372|         fallback_label = QLabel()\n00373|         qtbot.add_widget(label)\n00374|         fallback_label.setText(\"fallback\")\n00375| \n00376|         with qtbot.wait_exposed(fallback_label):\n00377|             # Needed so the font gets calculated\n00378|             fallback_label.show()\n00379| \n00380|         fallback_family = fallback_label.fontInfo().family()\n00381|         print(f'fallback: {fallback_family}')\n00382|         if info.family() == fallback_family:\n00383|             return\n00384| \n00385|         if info.family() == 'Noto Sans Mono':\n00386|             # WORKAROUND for https://bugreports.qt.io/browse/QTBUG-94090\n00387|             return\n00388| \n00389|         # If we didn't fall back, we should've gotten a fixed-pitch font.\n00390|         assert info.fixedPitch(), info.family()\n00391| \n\n(End of file - total 391 lines)\n</file>",
            "title": "tests/unit/config/test_configutils.py",
            "metadata": {
              "preview": "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n\n# Copyright 2018-2021 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n#\n# This file is part of qutebrowser.\n#\n# qutebrowser is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# qutebrowser is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with qutebrowser.  If not, see <https://www.gnu.org/licenses/>.\n\nimport hypothesis",
              "truncated": false
            },
            "time": {
              "start": 1769437371006,
              "end": 1769437371039
            }
          }
        },
        {
          "id": "prt_bfaaf9aa3001ofWGS4Fvfv8KvN",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfaaf89ec001CTMUkv3VT0awN5",
          "type": "step-finish",
          "reason": "tool-calls",
          "snapshot": "eb9c4a037e2dd806251ba120472cb32ed3f4bf89",
          "cost": 0,
          "tokens": {
            "input": 0,
            "output": 347,
            "reasoning": 0,
            "cache": {
              "read": 15510,
              "write": 634
            }
          }
        },
        {
          "id": "prt_bfaaf9b5d001EqXytA0TyE62O1",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfaaf89ec001CTMUkv3VT0awN5",
          "type": "patch",
          "hash": "ac68fec4510681d5231e5a43ca746d43c6f4812b",
          "files": [
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/.github/workflows/bleeding.yml",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/misc/requirements/requirements-pyqt-pyinstaller.txt",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/misc/requirements/requirements-pyqt-pyinstaller.txt-raw",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/misc/requirements/requirements-tests-bleeding.txt",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/misc/userscripts/add-nextcloud-bookmarks",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/misc/userscripts/add-nextcloud-cookbook",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/misc/userscripts/qute-keepassxc",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/browser/webengine/notification.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/commands/parser.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/completion/models/filepathcategory.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/adblockcommands.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/braveadblock.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/hostblock.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/utils/__init__.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/utils/blockutils.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/html/process.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/javascript/quirks/discord.user.js",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/javascript/quirks/globalthis.user.js",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/javascript/quirks/googledocs.user.js",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/javascript/quirks/object_fromentries.user.js",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/javascript/quirks/string_replaceall.user.js",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/javascript/quirks/whatsapp_web.user.js",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/misc/elf.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/utils/resources.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/scripts/dev/change_release.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/blocking/external_logo.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/blocking/qutebrowser-adblock",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/blocking/qutebrowser-hosts",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/brave-adblock/LICENSE",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/brave-adblock/README.md",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/brave-adblock/generate.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/brave-adblock/ublock-matches.tsv.gz",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/crashers/installedapp.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/crashers/webrtc.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/darkmode/blank.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/darkmode/mathml.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/darkmode/mathml.svg",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/darkmode/prefers-color-scheme.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/darkmode/yellow.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/easylist.txt.gz",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/easyprivacy.txt.gz",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/fileselect.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/javascript/img/big.png",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/javascript/img/padded.png",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/javascript/img/padded2.png",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/javascript/img/rgb.png",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/javascript/img/rgba.png",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/javascript/notifications.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/misc/xhr_headers.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/prefers_reduced_motion.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/prompt/script.js",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/service-worker/data.json",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/service-worker/index.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/service-worker/worker.js",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/features/notifications.feature",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/features/test_notifications_bdd.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/fixtures/notificationserver.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/templates/https-script.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/test_adblock_e2e.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/helpers/testutils.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/browser/test_downloadview.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/browser/webkit/test_certificateerror.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/commands/test_parser.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/components/test_blockutils.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/components/test_braveadblock.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/components/test_hostblock.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/config/test_qtargs_locale_workaround.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/javascript/test_js_quirks.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/misc/test_elf.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/scripts/importer_sample/html/bookmarks",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/scripts/importer_sample/html/config_py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/scripts/importer_sample/html/input",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/scripts/importer_sample/html/quickmarks",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/utils/test_resources.py"
          ]
        }
      ]
    },
    {
      "info": {
        "id": "msg_bfaaf9b6b001VM7x3eOGB8LwlF",
        "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
        "role": "assistant",
        "time": {
          "created": 1769437371243,
          "completed": 1769437375234
        },
        "parentID": "msg_bfaaf7dfd001wtLwIM1eGC5XRs",
        "modelID": "claude-opus-4-5",
        "providerID": "anthropic",
        "mode": "opus-codex",
        "agent": "opus-codex",
        "path": {
          "cwd": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896",
          "root": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896"
        },
        "cost": 0,
        "tokens": {
          "input": 0,
          "output": 123,
          "reasoning": 0,
          "cache": {
            "read": 16144,
            "write": 26771
          }
        },
        "finish": "tool-calls"
      },
      "parts": [
        {
          "id": "prt_bfaafa473001855Gp4E76Trvbz",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfaaf9b6b001VM7x3eOGB8LwlF",
          "type": "step-start",
          "snapshot": "ac68fec4510681d5231e5a43ca746d43c6f4812b"
        },
        {
          "id": "prt_bfaafa479001gQO7MumBsZPHQG",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfaaf9b6b001VM7x3eOGB8LwlF",
          "type": "text",
          "text": "Now let me look at the actual implementation files to understand what needs to be fixed.",
          "time": {
            "start": 1769437374023,
            "end": 1769437374023
          }
        },
        {
          "id": "prt_bfaafa648001r97HcgJBuUUUj3",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfaaf9b6b001VM7x3eOGB8LwlF",
          "type": "tool",
          "callID": "toolu_01THHrNZbUWZeLFCQtWqvTCb",
          "tool": "glob",
          "state": {
            "status": "completed",
            "input": {
              "pattern": "**/components/hostblock.py"
            },
            "output": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/hostblock.py",
            "title": "",
            "metadata": {
              "count": 1,
              "truncated": false
            },
            "time": {
              "start": 1769437374647,
              "end": 1769437374718
            }
          }
        },
        {
          "id": "prt_bfaafa8c1001zKvC6mVlbtVJND",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfaaf9b6b001VM7x3eOGB8LwlF",
          "type": "tool",
          "callID": "toolu_01CJiya8QYausqGbtmKeNSA9",
          "tool": "glob",
          "state": {
            "status": "completed",
            "input": {
              "pattern": "**/utils/urlutils.py"
            },
            "output": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/utils/urlutils.py",
            "title": "",
            "metadata": {
              "count": 1,
              "truncated": false
            },
            "time": {
              "start": 1769437374915,
              "end": 1769437375040
            }
          }
        },
        {
          "id": "prt_bfaafaa410017Ye5jpdC2d7jPS",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfaaf9b6b001VM7x3eOGB8LwlF",
          "type": "step-finish",
          "reason": "tool-calls",
          "snapshot": "",
          "cost": 0,
          "tokens": {
            "input": 0,
            "output": 123,
            "reasoning": 0,
            "cache": {
              "read": 16144,
              "write": 26771
            }
          }
        }
      ]
    },
    {
      "info": {
        "id": "msg_bfaafab20001w6cFL30Zn1Jfkc",
        "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
        "role": "assistant",
        "time": {
          "created": 1769437375264,
          "completed": 1769437379427
        },
        "parentID": "msg_bfaaf7dfd001wtLwIM1eGC5XRs",
        "modelID": "claude-opus-4-5",
        "providerID": "anthropic",
        "mode": "opus-codex",
        "agent": "opus-codex",
        "path": {
          "cwd": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896",
          "root": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896"
        },
        "cost": 0,
        "tokens": {
          "input": 0,
          "output": 223,
          "reasoning": 0,
          "cache": {
            "read": 42915,
            "write": 318
          }
        },
        "finish": "tool-calls"
      },
      "parts": [
        {
          "id": "prt_bfaafb49e001g7ofIUr0yk1fwa",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfaafab20001w6cFL30Zn1Jfkc",
          "type": "step-start",
          "snapshot": ""
        },
        {
          "id": "prt_bfaafb4a1001mRIokGYz051gqt",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfaafab20001w6cFL30Zn1Jfkc",
          "type": "tool",
          "callID": "toolu_01KjW41ua9bqqwjivbBHarqk",
          "tool": "read",
          "state": {
            "status": "completed",
            "input": {
              "filePath": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/hostblock.py"
            },
            "output": "<file>\n00001| # vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n00002| \n00003| # Copyright 2014-2021 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n00004| #\n00005| # This file is part of qutebrowser.\n00006| #\n00007| # qutebrowser is free software: you can redistribute it and/or modify\n00008| # it under the terms of the GNU General Public License as published by\n00009| # the Free Software Foundation, either version 3 of the License, or\n00010| # (at your option) any later version.\n00011| #\n00012| # qutebrowser is distributed in the hope that it will be useful,\n00013| # but WITHOUT ANY WARRANTY; without even the implied warranty of\n00014| # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n00015| # GNU General Public License for more details.\n00016| #\n00017| # You should have received a copy of the GNU General Public License\n00018| # along with qutebrowser.  If not, see <https://www.gnu.org/licenses/>.\n00019| \n00020| \"\"\"Functions related to host blocking.\"\"\"\n00021| \n00022| import os.path\n00023| import posixpath\n00024| import zipfile\n00025| import logging\n00026| import pathlib\n00027| from typing import cast, IO, Set\n00028| \n00029| from PyQt5.QtCore import QUrl\n00030| \n00031| from qutebrowser.api import (\n00032|     hook,\n00033|     config,\n00034|     message,\n00035|     interceptor,\n00036|     apitypes,\n00037|     qtutils,\n00038| )\n00039| from qutebrowser.components.utils import blockutils\n00040| from qutebrowser.utils import version  # FIXME: Move needed parts into api namespace?\n00041| \n00042| \n00043| logger = logging.getLogger(\"network\")\n00044| host_blocker = cast(\"HostBlocker\", None)\n00045| \n00046| \n00047| def _guess_zip_filename(zf: zipfile.ZipFile) -> str:\n00048|     \"\"\"Guess which file to use inside a zip file.\"\"\"\n00049|     files = zf.namelist()\n00050|     if len(files) == 1:\n00051|         return files[0]\n00052|     else:\n00053|         for e in files:\n00054|             if posixpath.splitext(e)[0].lower() == \"hosts\":\n00055|                 return e\n00056|     raise FileNotFoundError(\"No hosts file found in zip\")\n00057| \n00058| \n00059| def get_fileobj(byte_io: IO[bytes]) -> IO[bytes]:\n00060|     \"\"\"Get a usable file object to read the hosts file from.\"\"\"\n00061|     byte_io.seek(0)  # rewind downloaded file\n00062|     if zipfile.is_zipfile(byte_io):\n00063|         byte_io.seek(0)  # rewind what zipfile.is_zipfile did\n00064|         zf = zipfile.ZipFile(byte_io)\n00065|         filename = _guess_zip_filename(zf)\n00066|         byte_io = zf.open(filename, mode=\"r\")\n00067|     else:\n00068|         byte_io.seek(0)  # rewind what zipfile.is_zipfile did\n00069|     return byte_io\n00070| \n00071| \n00072| def _should_be_used() -> bool:\n00073|     \"\"\"Whether the hostblocker should be used or not.\"\"\"\n00074|     method = config.val.content.blocking.method\n00075| \n00076|     adblock_info = version.MODULE_INFO[\"adblock\"]\n00077|     adblock_usable = adblock_info.is_usable()\n00078| \n00079|     logger.debug(f\"Configured adblock method {method}, adblock library usable: \"\n00080|                  f\"{adblock_usable}\")\n00081|     return method in (\"both\", \"hosts\") or (method == \"auto\" and not adblock_usable)\n00082| \n00083| \n00084| class HostBlocker:\n00085| \n00086|     \"\"\"Manage blocked hosts based from /etc/hosts-like files.\n00087| \n00088|     Attributes:\n00089|         enabled: Given the current blocking method, should the host blocker be enabled?\n00090|         _blocked_hosts: A set of blocked hosts.\n00091|         _config_blocked_hosts: A set of blocked hosts from ~/.config.\n00092|         _local_hosts_file: The path to the blocked-hosts file.\n00093|         _config_hosts_file: The path to a blocked-hosts in ~/.config\n00094|         _has_basedir: Whether a custom --basedir is set.\n00095|     \"\"\"\n00096| \n00097|     def __init__(\n00098|         self,\n00099|         *,\n00100|         data_dir: pathlib.Path,\n00101|         config_dir: pathlib.Path,\n00102|         has_basedir: bool = False\n00103|     ) -> None:\n00104|         self.enabled = _should_be_used()\n00105|         self._has_basedir = has_basedir\n00106|         self._blocked_hosts: Set[str] = set()\n00107|         self._config_blocked_hosts: Set[str] = set()\n00108| \n00109|         self._local_hosts_file = str(data_dir / \"blocked-hosts\")\n00110|         self.update_files()\n00111| \n00112|         self._config_hosts_file = str(config_dir / \"blocked-hosts\")\n00113| \n00114|     def _is_blocked(self, request_url: QUrl, first_party_url: QUrl = None) -> bool:\n00115|         \"\"\"Check whether the given request is blocked.\"\"\"\n00116|         if not self.enabled:\n00117|             return False\n00118| \n00119|         if first_party_url is not None and not first_party_url.isValid():\n00120|             first_party_url = None\n00121| \n00122|         qtutils.ensure_valid(request_url)\n00123| \n00124|         if not config.get(\"content.blocking.enabled\", url=first_party_url):\n00125|             return False\n00126| \n00127|         host = request_url.host()\n00128|         return (\n00129|             host in self._blocked_hosts or host in self._config_blocked_hosts\n00130|         ) and not blockutils.is_whitelisted_url(request_url)\n00131| \n00132|     def filter_request(self, info: interceptor.Request) -> None:\n00133|         \"\"\"Block the given request if necessary.\"\"\"\n00134|         if self._is_blocked(\n00135|             request_url=info.request_url, first_party_url=info.first_party_url\n00136|         ):\n00137|             logger.debug(\n00138|                 \"Request to {} blocked by host blocker.\".format(info.request_url.host())\n00139|             )\n00140|             info.block()\n00141| \n00142|     def _read_hosts_line(self, raw_line: bytes) -> Set[str]:\n00143|         \"\"\"Read hosts from the given line.\n00144| \n00145|         Args:\n00146|             line: The bytes object to read.\n00147| \n00148|         Returns:\n00149|             A set containing valid hosts found\n00150|             in the line.\n00151|         \"\"\"\n00152|         if raw_line.startswith(b\"#\"):\n00153|             # Ignoring comments early so we don't have to care about\n00154|             # encoding errors in them\n00155|             return set()\n00156| \n00157|         line = raw_line.decode(\"utf-8\")\n00158| \n00159|         # Remove comments\n00160|         hash_idx = line.find(\"#\")\n00161|         line = line if hash_idx == -1 else line[:hash_idx]\n00162| \n00163|         parts = line.strip().split()\n00164|         if len(parts) == 1:\n00165|             # \"one host per line\" format\n00166|             hosts = parts\n00167|         else:\n00168|             # /etc/hosts format\n00169|             hosts = parts[1:]\n00170| \n00171|         filtered_hosts = set()\n00172|         for host in hosts:\n00173|             if \".\" in host and not host.endswith(\".localdomain\") and host != \"0.0.0.0\":\n00174|                 filtered_hosts.update([host])\n00175| \n00176|         return filtered_hosts\n00177| \n00178|     def _read_hosts_file(self, filename: str, target: Set[str]) -> bool:\n00179|         \"\"\"Read hosts from the given filename.\n00180| \n00181|         Args:\n00182|             filename: The file to read.\n00183|             target: The set to store the hosts in.\n00184| \n00185|         Return:\n00186|             True if a read was attempted, False otherwise\n00187|         \"\"\"\n00188|         if not os.path.exists(filename):\n00189|             return False\n00190| \n00191|         try:\n00192|             with open(filename, \"rb\") as f:\n00193|                 for line in f:\n00194|                     target |= self._read_hosts_line(line)\n00195| \n00196|         except (OSError, UnicodeDecodeError):\n00197|             logger.exception(\"Failed to read host blocklist!\")\n00198| \n00199|         return True\n00200| \n00201|     def read_hosts(self) -> None:\n00202|         \"\"\"Read hosts from the existing blocked-hosts file.\"\"\"\n00203|         self._blocked_hosts = set()\n00204| \n00205|         self._read_hosts_file(self._config_hosts_file, self._config_blocked_hosts)\n00206| \n00207|         found = self._read_hosts_file(self._local_hosts_file, self._blocked_hosts)\n00208| \n00209|         if not found:\n00210|             if (\n00211|                 config.val.content.blocking.hosts.lists\n00212|                 and not self._has_basedir\n00213|                 and config.val.content.blocking.enabled\n00214|                 and self.enabled\n00215|             ):\n00216|                 message.info(\"Run :adblock-update to get adblock lists.\")\n00217| \n00218|     def adblock_update(self) -> blockutils.BlocklistDownloads:\n00219|         \"\"\"Update the adblock block lists.\"\"\"\n00220|         self._read_hosts_file(self._config_hosts_file, self._config_blocked_hosts)\n00221|         self._blocked_hosts = set()\n00222| \n00223|         blocklists = config.val.content.blocking.hosts.lists\n00224|         dl = blockutils.BlocklistDownloads(blocklists)\n00225|         dl.single_download_finished.connect(self._merge_file)\n00226|         dl.all_downloads_finished.connect(self._on_lists_downloaded)\n00227|         dl.initiate()\n00228|         return dl\n00229| \n00230|     def _merge_file(self, byte_io: IO[bytes]) -> None:\n00231|         \"\"\"Read and merge host files.\n00232| \n00233|         Args:\n00234|             byte_io: The BytesIO object of the completed download.\n00235|         \"\"\"\n00236|         error_count = 0\n00237|         line_count = 0\n00238|         try:\n00239|             f = get_fileobj(byte_io)\n00240|         except (OSError, zipfile.BadZipFile, zipfile.LargeZipFile, LookupError) as e:\n00241|             message.error(\n00242|                 \"hostblock: Error while reading {}: {} - {}\".format(\n00243|                     byte_io.name, e.__class__.__name__, e\n00244|                 )\n00245|             )\n00246|             return\n00247| \n00248|         for line in f:\n00249|             line_count += 1\n00250|             try:\n00251|                 self._blocked_hosts |= self._read_hosts_line(line)\n00252|             except UnicodeDecodeError:\n00253|                 logger.error(\"Failed to decode: {!r}\".format(line))\n00254|                 error_count += 1\n00255| \n00256|         logger.debug(\"{}: read {} lines\".format(byte_io.name, line_count))\n00257|         if error_count > 0:\n00258|             message.error(\n00259|                 \"hostblock: {} read errors for {}\".format(error_count, byte_io.name)\n00260|             )\n00261| \n00262|     def _on_lists_downloaded(self, done_count: int) -> None:\n00263|         \"\"\"Install block lists after files have been downloaded.\"\"\"\n00264|         try:\n00265|             with open(self._local_hosts_file, \"w\", encoding=\"utf-8\") as f:\n00266|                 for host in sorted(self._blocked_hosts):\n00267|                     f.write(host + \"\\n\")\n00268|                 message.info(\n00269|                     \"hostblock: Read {} hosts from {} sources.\".format(\n00270|                         len(self._blocked_hosts), done_count\n00271|                     )\n00272|                 )\n00273|         except OSError:\n00274|             logger.exception(\"Failed to write host block list!\")\n00275| \n00276|     def update_files(self) -> None:\n00277|         \"\"\"Update files when the config changed.\"\"\"\n00278|         if not config.val.content.blocking.hosts.lists:\n00279|             try:\n00280|                 os.remove(self._local_hosts_file)\n00281|             except FileNotFoundError:\n00282|                 pass\n00283|             except OSError as e:\n00284|                 logger.exception(\"Failed to delete hosts file: {}\".format(e))\n00285| \n00286| \n00287| @hook.config_changed(\"content.blocking.hosts.lists\")\n00288| def on_lists_changed() -> None:\n00289|     host_blocker.update_files()\n00290| \n00291| \n00292| @hook.config_changed(\"content.blocking.method\")\n00293| def on_method_changed() -> None:\n00294|     host_blocker.enabled = _should_be_used()\n00295| \n00296| \n00297| @hook.init()\n00298| def init(context: apitypes.InitContext) -> None:\n00299|     \"\"\"Initialize the host blocker.\"\"\"\n00300|     global host_blocker\n00301|     host_blocker = HostBlocker(\n00302|         data_dir=context.data_dir,\n00303|         config_dir=context.config_dir,\n00304|         has_basedir=context.args.basedir is not None,\n00305|     )\n00306|     host_blocker.read_hosts()\n00307|     interceptor.register(host_blocker.filter_request)\n00308| \n\n(End of file - total 308 lines)\n</file>",
            "title": "qutebrowser/components/hostblock.py",
            "metadata": {
              "preview": "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n\n# Copyright 2014-2021 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n#\n# This file is part of qutebrowser.\n#\n# qutebrowser is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# qutebrowser is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with qutebrowser.  If not, see <https://www.gnu.org/licenses/>.\n\n\"\"\"Functions related to host blocking.\"\"\"",
              "truncated": false
            },
            "time": {
              "start": 1769437378428,
              "end": 1769437378440
            }
          }
        },
        {
          "id": "prt_bfaafb787001b0q9DU0ZIAQAOL",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfaafab20001w6cFL30Zn1Jfkc",
          "type": "tool",
          "callID": "toolu_01ES3TsQJotgdXBMufuXzb8M",
          "tool": "read",
          "state": {
            "status": "completed",
            "input": {
              "filePath": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/utils/urlutils.py"
            },
            "output": "<file>\n00001| # vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n00002| \n00003| # Copyright 2014-2021 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n00004| #\n00005| # This file is part of qutebrowser.\n00006| #\n00007| # qutebrowser is free software: you can redistribute it and/or modify\n00008| # it under the terms of the GNU General Public License as published by\n00009| # the Free Software Foundation, either version 3 of the License, or\n00010| # (at your option) any later version.\n00011| #\n00012| # qutebrowser is distributed in the hope that it will be useful,\n00013| # but WITHOUT ANY WARRANTY; without even the implied warranty of\n00014| # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n00015| # GNU General Public License for more details.\n00016| #\n00017| # You should have received a copy of the GNU General Public License\n00018| # along with qutebrowser.  If not, see <https://www.gnu.org/licenses/>.\n00019| \n00020| \"\"\"Utils regarding URL handling.\"\"\"\n00021| \n00022| import re\n00023| import base64\n00024| import os.path\n00025| import ipaddress\n00026| import posixpath\n00027| import urllib.parse\n00028| import mimetypes\n00029| from typing import Optional, Tuple, Union\n00030| \n00031| from PyQt5.QtCore import QUrl\n00032| from PyQt5.QtNetwork import QHostInfo, QHostAddress, QNetworkProxy\n00033| \n00034| from qutebrowser.api import cmdutils\n00035| from qutebrowser.config import config\n00036| from qutebrowser.utils import log, qtutils, message, utils\n00037| from qutebrowser.browser.network import pac\n00038| \n00039| \n00040| # FIXME: we probably could raise some exceptions on invalid URLs\n00041| # https://github.com/qutebrowser/qutebrowser/issues/108\n00042| \n00043| \n00044| # URL schemes supported by QtWebEngine\n00045| WEBENGINE_SCHEMES = [\n00046|     'about',\n00047|     'data',\n00048|     'file',\n00049|     'filesystem',\n00050|     'ftp',\n00051|     'http',\n00052|     'https',\n00053|     'javascript',\n00054|     'ws',\n00055|     'wss',\n00056| ]\n00057| \n00058| \n00059| class Error(Exception):\n00060| \n00061|     \"\"\"Base class for errors in this module.\"\"\"\n00062| \n00063| \n00064| class InvalidUrlError(Error):\n00065| \n00066|     \"\"\"Error raised if a function got an invalid URL.\"\"\"\n00067| \n00068|     def __init__(self, url: QUrl) -> None:\n00069|         if url.isValid():\n00070|             raise ValueError(\"Got valid URL {}!\".format(url.toDisplayString()))\n00071|         self.url = url\n00072|         self.msg = get_errstring(url)\n00073|         super().__init__(self.msg)\n00074| \n00075| \n00076| def _parse_search_term(s: str) -> Tuple[Optional[str], Optional[str]]:\n00077|     \"\"\"Get a search engine name and search term from a string.\n00078| \n00079|     Args:\n00080|         s: The string to get a search engine for.\n00081| \n00082|     Return:\n00083|         A (engine, term) tuple, where engine is None for the default engine.\n00084|     \"\"\"\n00085|     s = s.strip()\n00086|     split = s.split(maxsplit=1)\n00087|     if not split:\n00088|         raise ValueError(\"Empty search term!\")\n00089| \n00090|     if len(split) == 2:\n00091|         if split[0] in config.val.url.searchengines:\n00092|             engine: Optional[str] = split[0]\n00093|             term: Optional[str] = split[1]\n00094|         else:\n00095|             engine = None\n00096|             term = s\n00097|     else:\n00098|         if config.val.url.open_base_url and s in config.val.url.searchengines:\n00099|             engine = s\n00100|             term = None\n00101|         else:\n00102|             engine = None\n00103|             term = s\n00104| \n00105|     log.url.debug(\"engine {}, term {!r}\".format(engine, term))\n00106|     return (engine, term)\n00107| \n00108| \n00109| def _get_search_url(txt: str) -> QUrl:\n00110|     \"\"\"Get a search engine URL for a text.\n00111| \n00112|     Args:\n00113|         txt: Text to search for.\n00114| \n00115|     Return:\n00116|         The search URL as a QUrl.\n00117|     \"\"\"\n00118|     log.url.debug(\"Finding search engine for {!r}\".format(txt))\n00119|     engine, term = _parse_search_term(txt)\n00120|     if not engine:\n00121|         engine = 'DEFAULT'\n00122|     if term:\n00123|         template = config.val.url.searchengines[engine]\n00124|         semiquoted_term = urllib.parse.quote(term)\n00125|         quoted_term = urllib.parse.quote(term, safe='')\n00126|         evaluated = template.format(semiquoted_term,\n00127|                                     unquoted=term,\n00128|                                     quoted=quoted_term,\n00129|                                     semiquoted=semiquoted_term)\n00130|         url = QUrl.fromUserInput(evaluated)\n00131|     else:\n00132|         url = QUrl.fromUserInput(config.val.url.searchengines[engine])\n00133|         url.setPath(None)  # type: ignore[arg-type]\n00134|         url.setFragment(None)  # type: ignore[arg-type]\n00135|         url.setQuery(None)  # type: ignore[call-overload]\n00136|     qtutils.ensure_valid(url)\n00137|     return url\n00138| \n00139| \n00140| def _is_url_naive(urlstr: str) -> bool:\n00141|     \"\"\"Naive check if given URL is really a URL.\n00142| \n00143|     Args:\n00144|         urlstr: The URL to check for, as string.\n00145| \n00146|     Return:\n00147|         True if the URL really is a URL, False otherwise.\n00148|     \"\"\"\n00149|     url = QUrl.fromUserInput(urlstr)\n00150|     assert url.isValid()\n00151|     host = url.host()\n00152| \n00153|     # Valid IPv4/IPv6 address. Qt converts things like \"23.42\" or \"1337\" or\n00154|     # \"0xDEAD\" to IP addresses, which we don't like, so we check if the host\n00155|     # from Qt is part of the input.\n00156|     if (not utils.raises(ValueError, ipaddress.ip_address, host) and\n00157|             host in urlstr):\n00158|         return True\n00159| \n00160|     tld = r'\\.([^.0-9_-]+|xn--[a-z0-9-]+)$'\n00161|     forbidden = r'[\\u0000-\\u002c\\u002f\\u003a-\\u0060\\u007b-\\u00b6]'\n00162|     return bool(re.search(tld, host) and not re.search(forbidden, host))\n00163| \n00164| \n00165| def _is_url_dns(urlstr: str) -> bool:\n00166|     \"\"\"Check if a URL is really a URL via DNS.\n00167| \n00168|     Args:\n00169|         url: The URL to check for as a string.\n00170| \n00171|     Return:\n00172|         True if the URL really is a URL, False otherwise.\n00173|     \"\"\"\n00174|     url = QUrl.fromUserInput(urlstr)\n00175|     assert url.isValid()\n00176| \n00177|     if (utils.raises(ValueError, ipaddress.ip_address, urlstr) and\n00178|             not QHostAddress(urlstr).isNull()):\n00179|         log.url.debug(\"Bogus IP URL -> False\")\n00180|         # Qt treats things like \"23.42\" or \"1337\" or \"0xDEAD\" as valid URLs\n00181|         # which we don't want to.\n00182|         return False\n00183| \n00184|     host = url.host()\n00185|     if not host:\n00186|         log.url.debug(\"URL has no host -> False\")\n00187|         return False\n00188|     log.url.debug(\"Doing DNS request for {}\".format(host))\n00189|     info = QHostInfo.fromName(host)\n00190|     return not info.error()\n00191| \n00192| \n00193| def fuzzy_url(urlstr: str,\n00194|               cwd: str = None,\n00195|               relative: bool = False,\n00196|               do_search: bool = True,\n00197|               force_search: bool = False) -> QUrl:\n00198|     \"\"\"Get a QUrl based on a user input which is URL or search term.\n00199| \n00200|     Args:\n00201|         urlstr: URL to load as a string.\n00202|         cwd: The current working directory, or None.\n00203|         relative: Whether to resolve relative files.\n00204|         do_search: Whether to perform a search on non-URLs.\n00205|         force_search: Whether to force a search even if the content can be\n00206|                       interpreted as a URL or a path.\n00207| \n00208|     Return:\n00209|         A target QUrl to a search page or the original URL.\n00210|     \"\"\"\n00211|     urlstr = urlstr.strip()\n00212|     path = get_path_if_valid(urlstr, cwd=cwd, relative=relative,\n00213|                              check_exists=True)\n00214| \n00215|     if not force_search and path is not None:\n00216|         url = QUrl.fromLocalFile(path)\n00217|     elif force_search or (do_search and not is_url(urlstr)):\n00218|         # probably a search term\n00219|         log.url.debug(\"URL is a fuzzy search term\")\n00220|         try:\n00221|             url = _get_search_url(urlstr)\n00222|         except ValueError:  # invalid search engine\n00223|             url = QUrl.fromUserInput(urlstr)\n00224|     else:  # probably an address\n00225|         log.url.debug(\"URL is a fuzzy address\")\n00226|         url = QUrl.fromUserInput(urlstr)\n00227|     log.url.debug(\"Converting fuzzy term {!r} to URL -> {}\".format(\n00228|         urlstr, url.toDisplayString()))\n00229|     ensure_valid(url)\n00230|     return url\n00231| \n00232| \n00233| def _has_explicit_scheme(url: QUrl) -> bool:\n00234|     \"\"\"Check if a url has an explicit scheme given.\n00235| \n00236|     Args:\n00237|         url: The URL as QUrl.\n00238|     \"\"\"\n00239|     # Note that generic URI syntax actually would allow a second colon\n00240|     # after the scheme delimiter. Since we don't know of any URIs\n00241|     # using this and want to support e.g. searching for scoped C++\n00242|     # symbols, we treat this as not a URI anyways.\n00243|     return bool(url.isValid() and url.scheme() and\n00244|                 (url.host() or url.path()) and\n00245|                 not url.path().startswith(':'))\n00246| \n00247| \n00248| def is_special_url(url: QUrl) -> bool:\n00249|     \"\"\"Return True if url is an about:... or other special URL.\n00250| \n00251|     Args:\n00252|         url: The URL as QUrl.\n00253|     \"\"\"\n00254|     if not url.isValid():\n00255|         return False\n00256|     special_schemes = ('about', 'qute', 'file')\n00257|     return url.scheme() in special_schemes\n00258| \n00259| \n00260| def is_url(urlstr: str) -> bool:\n00261|     \"\"\"Check if url seems to be a valid URL.\n00262| \n00263|     Args:\n00264|         urlstr: The URL as string.\n00265| \n00266|     Return:\n00267|         True if it is a valid URL, False otherwise.\n00268|     \"\"\"\n00269|     autosearch = config.val.url.auto_search\n00270| \n00271|     log.url.debug(\"Checking if {!r} is a URL (autosearch={}).\".format(\n00272|         urlstr, autosearch))\n00273| \n00274|     urlstr = urlstr.strip()\n00275|     qurl = QUrl(urlstr)\n00276|     qurl_userinput = QUrl.fromUserInput(urlstr)\n00277| \n00278|     if autosearch == 'never':\n00279|         # no autosearch, so everything is a URL unless it has an explicit\n00280|         # search engine.\n00281|         try:\n00282|             engine, _term = _parse_search_term(urlstr)\n00283|         except ValueError:\n00284|             return False\n00285|         else:\n00286|             return engine is None\n00287| \n00288|     if not qurl_userinput.isValid():\n00289|         # This will also catch non-URLs containing spaces.\n00290|         return False\n00291| \n00292|     if _has_explicit_scheme(qurl) and ' ' not in urlstr:\n00293|         # URLs with explicit schemes are always URLs\n00294|         log.url.debug(\"Contains explicit scheme\")\n00295|         url = True\n00296|     elif (autosearch == 'schemeless' and\n00297|           (not _has_explicit_scheme(qurl) or ' ' in urlstr)):\n00298|         # When autosearch=schemeless, URLs must contain schemes to be valid\n00299|         log.url.debug(\"No explicit scheme in given URL, treating as non-URL\")\n00300|         url = False\n00301|     elif qurl_userinput.host() in ['localhost', '127.0.0.1', '::1']:\n00302|         log.url.debug(\"Is localhost.\")\n00303|         url = True\n00304|     elif is_special_url(qurl):\n00305|         # Special URLs are always URLs, even with autosearch=never\n00306|         log.url.debug(\"Is a special URL.\")\n00307|         url = True\n00308|     elif autosearch == 'dns':\n00309|         log.url.debug(\"Checking via DNS check\")\n00310|         # We want to use QUrl.fromUserInput here, as the user might enter\n00311|         # \"foo.de\" and that should be treated as URL here.\n00312|         url = ' ' not in qurl_userinput.userName() and _is_url_dns(urlstr)\n00313|     elif autosearch == 'naive':\n00314|         log.url.debug(\"Checking via naive check\")\n00315|         url = ' ' not in qurl_userinput.userName() and _is_url_naive(urlstr)\n00316|     else:  # pragma: no cover\n00317|         raise ValueError(\"Invalid autosearch value\")\n00318|     log.url.debug(\"url = {}\".format(url))\n00319|     return url\n00320| \n00321| \n00322| def ensure_valid(url: QUrl) -> None:\n00323|     if not url.isValid():\n00324|         raise InvalidUrlError(url)\n00325| \n00326| \n00327| def invalid_url_error(url: QUrl, action: str) -> None:\n00328|     \"\"\"Display an error message for a URL.\n00329| \n00330|     Args:\n00331|         action: The action which was interrupted by the error.\n00332|     \"\"\"\n00333|     if url.isValid():\n00334|         raise ValueError(\"Calling invalid_url_error with valid URL {}\".format(\n00335|             url.toDisplayString()))\n00336|     errstring = get_errstring(\n00337|         url, \"Trying to {} with invalid URL\".format(action))\n00338|     message.error(errstring)\n00339| \n00340| \n00341| def raise_cmdexc_if_invalid(url: QUrl) -> None:\n00342|     \"\"\"Check if the given QUrl is invalid, and if so, raise a CommandError.\"\"\"\n00343|     try:\n00344|         ensure_valid(url)\n00345|     except InvalidUrlError as e:\n00346|         raise cmdutils.CommandError(str(e))\n00347| \n00348| \n00349| def get_path_if_valid(pathstr: str,\n00350|                       cwd: str = None,\n00351|                       relative: bool = False,\n00352|                       check_exists: bool = False) -> Optional[str]:\n00353|     \"\"\"Check if path is a valid path.\n00354| \n00355|     Args:\n00356|         pathstr: The path as string.\n00357|         cwd: The current working directory, or None.\n00358|         relative: Whether to resolve relative files.\n00359|         check_exists: Whether to check if the file\n00360|                       actually exists of filesystem.\n00361| \n00362|     Return:\n00363|         The path if it is a valid path, None otherwise.\n00364|     \"\"\"\n00365|     pathstr = pathstr.strip()\n00366|     log.url.debug(\"Checking if {!r} is a path\".format(pathstr))\n00367|     expanded = os.path.expanduser(pathstr)\n00368| \n00369|     if os.path.isabs(expanded):\n00370|         path: Optional[str] = expanded\n00371|     elif relative and cwd:\n00372|         path = os.path.join(cwd, expanded)\n00373|     elif relative:\n00374|         try:\n00375|             path = os.path.abspath(expanded)\n00376|         except OSError:\n00377|             path = None\n00378|     else:\n00379|         path = None\n00380| \n00381|     if check_exists:\n00382|         if path is not None:\n00383|             try:\n00384|                 if os.path.exists(path):\n00385|                     log.url.debug(\"URL is a local file\")\n00386|                 else:\n00387|                     path = None\n00388|             except UnicodeEncodeError:\n00389|                 log.url.debug(\n00390|                     \"URL contains characters which are not present in the \"\n00391|                     \"current locale\")\n00392|                 path = None\n00393| \n00394|     return path\n00395| \n00396| \n00397| def filename_from_url(url: QUrl, fallback: str = None) -> Optional[str]:\n00398|     \"\"\"Get a suitable filename from a URL.\n00399| \n00400|     Args:\n00401|         url: The URL to parse, as a QUrl.\n00402|         fallback: Value to use if no name can be determined.\n00403| \n00404|     Return:\n00405|         The suggested filename as a string, or None.\n00406|     \"\"\"\n00407|     if not url.isValid():\n00408|         return fallback\n00409| \n00410|     if url.scheme().lower() == 'data':\n00411|         mimetype, _encoding = mimetypes.guess_type(url.toString())\n00412|         if not mimetype:\n00413|             return fallback\n00414| \n00415|         ext = utils.mimetype_extension(mimetype) or ''\n00416|         return 'download' + ext\n00417| \n00418|     pathname = posixpath.basename(url.path())\n00419|     if pathname:\n00420|         return pathname\n00421|     elif url.host():\n00422|         return url.host() + '.html'\n00423|     else:\n00424|         return fallback\n00425| \n00426| \n00427| HostTupleType = Tuple[str, str, int]\n00428| \n00429| \n00430| def host_tuple(url: QUrl) -> HostTupleType:\n00431|     \"\"\"Get a (scheme, host, port) tuple from a QUrl.\n00432| \n00433|     This is suitable to identify a connection, e.g. for SSL errors.\n00434|     \"\"\"\n00435|     ensure_valid(url)\n00436|     scheme, host, port = url.scheme(), url.host(), url.port()\n00437|     assert scheme\n00438|     if not host:\n00439|         raise ValueError(\"Got URL {} without host.\".format(\n00440|             url.toDisplayString()))\n00441|     if port == -1:\n00442|         port_mapping = {\n00443|             'http': 80,\n00444|             'https': 443,\n00445|             'ftp': 21,\n00446|         }\n00447|         try:\n00448|             port = port_mapping[scheme]\n00449|         except KeyError:\n00450|             raise ValueError(\"Got URL {} with unknown port.\".format(\n00451|                 url.toDisplayString()))\n00452|     return scheme, host, port\n00453| \n00454| \n00455| def get_errstring(url: QUrl, base: str = \"Invalid URL\") -> str:\n00456|     \"\"\"Get an error string for a URL.\n00457| \n00458|     Args:\n00459|         url: The URL as a QUrl.\n00460|         base: The base error string.\n00461| \n00462|     Return:\n00463|         A new string with url.errorString() is appended if available.\n00464|     \"\"\"\n00465|     url_error = url.errorString()\n00466|     if url_error:\n00467|         return base + \" - {}\".format(url_error)\n00468|     else:\n00469|         return base\n00470| \n00471| \n00472| def same_domain(url1: QUrl, url2: QUrl) -> bool:\n00473|     \"\"\"Check if url1 and url2 belong to the same website.\n00474| \n00475|     This will use a \"public suffix list\" to determine what a \"top level domain\"\n00476|     is. All further domains are ignored.\n00477| \n00478|     For example example.com and www.example.com are considered the same. but\n00479|     example.co.uk and test.co.uk are not.\n00480| \n00481|     If the URL's schemes or ports are different, they are always treated as not equal.\n00482| \n00483|     Return:\n00484|         True if the domains are the same, False otherwise.\n00485|     \"\"\"\n00486|     ensure_valid(url1)\n00487|     ensure_valid(url2)\n00488| \n00489|     if url1.scheme() != url2.scheme():\n00490|         return False\n00491|     if url1.port() != url2.port():\n00492|         return False\n00493| \n00494|     suffix1 = url1.topLevelDomain()\n00495|     suffix2 = url2.topLevelDomain()\n00496|     if not suffix1:\n00497|         return url1.host() == url2.host()\n00498| \n00499|     if suffix1 != suffix2:\n00500|         return False\n00501| \n00502|     domain1 = url1.host()[:-len(suffix1)].split('.')[-1]\n00503|     domain2 = url2.host()[:-len(suffix2)].split('.')[-1]\n00504|     return domain1 == domain2\n00505| \n00506| \n00507| def encoded_url(url: QUrl) -> str:\n00508|     \"\"\"Return the fully encoded url as string.\n00509| \n00510|     Args:\n00511|         url: The url to encode as QUrl.\n00512|     \"\"\"\n00513|     return url.toEncoded().data().decode('ascii')\n00514| \n00515| \n00516| def file_url(path: str) -> str:\n00517|     \"\"\"Return a file:// url (as string) to the given local path.\n00518| \n00519|     Arguments:\n00520|         path: The absolute path to the local file\n00521|     \"\"\"\n00522|     url = QUrl.fromLocalFile(path)\n00523|     return url.toString(QUrl.FullyEncoded)  # type: ignore[arg-type]\n00524| \n00525| \n00526| def data_url(mimetype: str, data: bytes) -> QUrl:\n00527|     \"\"\"Get a data: QUrl for the given data.\"\"\"\n00528|     b64 = base64.b64encode(data).decode('ascii')\n00529|     url = QUrl('data:{};base64,{}'.format(mimetype, b64))\n00530|     qtutils.ensure_valid(url)\n00531|     return url\n00532| \n00533| \n00534| def safe_display_string(qurl: QUrl) -> str:\n00535|     \"\"\"Get a IDN-homograph phishing safe form of the given QUrl.\n00536| \n00537|     If we're dealing with a Punycode-encoded URL, this prepends the hostname in\n00538|     its encoded form, to make sure those URLs are distinguishable.\n00539| \n00540|     See https://github.com/qutebrowser/qutebrowser/issues/2547\n00541|     and https://bugreports.qt.io/browse/QTBUG-60365\n00542|     \"\"\"\n00543|     ensure_valid(qurl)\n00544| \n00545|     host = qurl.host(QUrl.FullyEncoded)\n00546|     assert '..' not in host, qurl  # https://bugreports.qt.io/browse/QTBUG-60364\n00547| \n00548|     for part in host.split('.'):\n00549|         url_host = qurl.host(QUrl.FullyDecoded)\n00550|         if part.startswith('xn--') and host != url_host:\n00551|             return '({}) {}'.format(host, qurl.toDisplayString())\n00552| \n00553|     return qurl.toDisplayString()\n00554| \n00555| \n00556| class InvalidProxyTypeError(Exception):\n00557| \n00558|     \"\"\"Error raised when proxy_from_url gets an unknown proxy type.\"\"\"\n00559| \n00560|     def __init__(self, typ: str) -> None:\n00561|         super().__init__(\"Invalid proxy type {}!\".format(typ))\n00562| \n00563| \n00564| def proxy_from_url(url: QUrl) -> Union[QNetworkProxy, pac.PACFetcher]:\n00565|     \"\"\"Create a QNetworkProxy from QUrl and a proxy type.\n00566| \n00567|     Args:\n00568|         url: URL of a proxy (possibly with credentials).\n00569| \n00570|     Return:\n00571|         New QNetworkProxy.\n00572|     \"\"\"\n00573|     ensure_valid(url)\n00574| \n00575|     scheme = url.scheme()\n00576|     if scheme in ['pac+http', 'pac+https', 'pac+file']:\n00577|         fetcher = pac.PACFetcher(url)\n00578|         fetcher.fetch()\n00579|         return fetcher\n00580| \n00581|     types = {\n00582|         'http': QNetworkProxy.HttpProxy,\n00583|         'socks': QNetworkProxy.Socks5Proxy,\n00584|         'socks5': QNetworkProxy.Socks5Proxy,\n00585|         'direct': QNetworkProxy.NoProxy,\n00586|     }\n00587|     if scheme not in types:\n00588|         raise InvalidProxyTypeError(scheme)\n00589| \n00590|     proxy = QNetworkProxy(types[scheme], url.host())\n00591| \n00592|     if url.port() != -1:\n00593|         proxy.setPort(url.port())\n00594|     if url.userName():\n00595|         proxy.setUser(url.userName())\n00596|     if url.password():\n00597|         proxy.setPassword(url.password())\n00598|     return proxy\n00599| \n00600| \n00601| def parse_javascript_url(url: QUrl) -> str:\n00602|     \"\"\"Get JavaScript source from the given URL.\n00603| \n00604|     See https://wiki.whatwg.org/wiki/URL_schemes#javascript:_URLs\n00605|     and https://github.com/whatwg/url/issues/385\n00606|     \"\"\"\n00607|     ensure_valid(url)\n00608|     if url.scheme() != 'javascript':\n00609|         raise Error(\"Expected a javascript:... URL\")\n00610|     if url.authority():\n00611|         raise Error(\"URL contains unexpected components: {}\"\n00612|                     .format(url.authority()))\n00613| \n00614|     urlstr = url.toString(QUrl.FullyEncoded)  # type: ignore[arg-type]\n00615|     urlstr = urllib.parse.unquote(urlstr)\n00616| \n00617|     code = urlstr[len('javascript:'):]\n00618|     if not code:\n00619|         raise Error(\"Resulted in empty JavaScript code\")\n00620| \n00621|     return code\n00622| \n\n(End of file - total 622 lines)\n</file>",
            "title": "qutebrowser/utils/urlutils.py",
            "metadata": {
              "preview": "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n\n# Copyright 2014-2021 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n#\n# This file is part of qutebrowser.\n#\n# qutebrowser is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# qutebrowser is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with qutebrowser.  If not, see <https://www.gnu.org/licenses/>.\n\n\"\"\"Utils regarding URL handling.\"\"\"",
              "truncated": false
            },
            "time": {
              "start": 1769437379068,
              "end": 1769437379081
            }
          }
        },
        {
          "id": "prt_bfaafba0a0014E5uqb73qGw6Mg",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfaafab20001w6cFL30Zn1Jfkc",
          "type": "step-finish",
          "reason": "tool-calls",
          "snapshot": "",
          "cost": 0,
          "tokens": {
            "input": 0,
            "output": 223,
            "reasoning": 0,
            "cache": {
              "read": 42915,
              "write": 318
            }
          }
        }
      ]
    },
    {
      "info": {
        "id": "msg_bfaafbbd8001EzjM5axKaGgCuC",
        "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
        "role": "assistant",
        "time": {
          "created": 1769437379545,
          "completed": 1769437402964
        },
        "parentID": "msg_bfaaf7dfd001wtLwIM1eGC5XRs",
        "modelID": "claude-opus-4-5",
        "providerID": "anthropic",
        "mode": "opus-codex",
        "agent": "opus-codex",
        "path": {
          "cwd": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896",
          "root": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896"
        },
        "cost": 0,
        "tokens": {
          "input": 0,
          "output": 226,
          "reasoning": 0,
          "cache": {
            "read": 43233,
            "write": 12045
          }
        },
        "finish": "tool-calls"
      },
      "parts": [
        {
          "id": "prt_bfaafc382001sOKWFdUbUMQOLy",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfaafbbd8001EzjM5axKaGgCuC",
          "type": "step-start",
          "snapshot": "ac68fec4510681d5231e5a43ca746d43c6f4812b"
        },
        {
          "id": "prt_bfaafc38b0014061tGYHBmYt0a",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfaafbbd8001EzjM5axKaGgCuC",
          "type": "text",
          "text": "Now I need to run the tests to see exactly what's failing:",
          "time": {
            "start": 1769437382003,
            "end": 1769437382003
          }
        },
        {
          "id": "prt_bfaafc574001G0fEbUvMAF48sy",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfaafbbd8001EzjM5axKaGgCuC",
          "type": "tool",
          "callID": "toolu_014mVmk1wgLQWqWA4Rj8ui3f",
          "tool": "bash",
          "state": {
            "status": "completed",
            "input": {
              "command": "cd /Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896 && source .venv/bin/activate && QT_QPA_PLATFORM=offscreen pytest tests/unit/components/test_hostblock.py tests/unit/utils/test_urlutils.py tests/unit/config/test_configutils.py -v 2>&1",
              "description": "Run the test suite",
              "timeout": 300000
            },
            "output": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/qutebrowser/.venv/lib/python3.10/site-packages/_pytest/config/__init__.py:331: PluggyTeardownRaisedWarning: A plugin raised an exception during an old-style hookwrapper teardown.\nPlugin: helpconfig, Hook: pytest_cmdline_parse\nConftestImportFailure: UserWarning: PyQt5 already imported (from /Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/conftest.py)\nFor more information see https://pluggy.readthedocs.io/en/stable/api_reference.html#pluggy.PluggyTeardownRaisedWarning\n  config = pluginmanager.hook.pytest_cmdline_parse(\nImportError while loading conftest '/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/conftest.py'.\ntests/conftest.py:37: in <module>\n    from helpers.messagemock import message_mock\ntests/helpers/messagemock.py:28: in <module>\n    from qutebrowser.utils import usertypes, message\n../f91ace96_qt_warning_opus-codex_20260126_090939/qutebrowser/utils/usertypes.py:26: in <module>\n    from qutebrowser.qt.core import pyqtSignal, pyqtSlot, QObject, QTimer\n../f91ace96_qt_warning_opus-codex_20260126_090939/qutebrowser/qt/core.py:17: in <module>\n    machinery.init_implicit()\n../f91ace96_qt_warning_opus-codex_20260126_090939/qutebrowser/qt/machinery.py:260: in init_implicit\n    info = _select_wrapper(args=None)\n../f91ace96_qt_warning_opus-codex_20260126_090939/qutebrowser/qt/machinery.py:159: in _select_wrapper\n    warnings.warn(f\"{name} already imported\", stacklevel=1)\nE   UserWarning: PyQt5 already imported\n",
            "title": "Run the test suite",
            "metadata": {
              "output": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/qutebrowser/.venv/lib/python3.10/site-packages/_pytest/config/__init__.py:331: PluggyTeardownRaisedWarning: A plugin raised an exception during an old-style hookwrapper teardown.\nPlugin: helpconfig, Hook: pytest_cmdline_parse\nConftestImportFailure: UserWarning: PyQt5 already imported (from /Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/conftest.py)\nFor more information see https://pluggy.readthedocs.io/en/stable/api_reference.html#pluggy.PluggyTeardownRaisedWarning\n  config = pluginmanager.hook.pytest_cmdline_parse(\nImportError while loading conftest '/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/conftest.py'.\ntests/conftest.py:37: in <module>\n    from helpers.messagemock import message_mock\ntests/helpers/messagemock.py:28: in <module>\n    from qutebrowser.utils import usertypes, message\n../f91ace96_qt_warning_opus-codex_20260126_090939/qutebrowser/utils/usertypes.py:26: in <module>\n    from qutebrowser.qt.core import pyqtSignal, pyqtSlot, QObject, QTimer\n../f91ace96_qt_warning_opus-codex_20260126_090939/qutebrowser/qt/core.py:17: in <module>\n    machinery.init_implicit()\n../f91ace96_qt_warning_opus-codex_20260126_090939/qutebrowser/qt/machinery.py:260: in init_implicit\n    info = _select_wrapper(args=None)\n../f91ace96_qt_warning_opus-codex_20260126_090939/qutebrowser/qt/machinery.py:159: in _select_wrapper\n    warnings.warn(f\"{name} already imported\", stacklevel=1)\nE   UserWarning: PyQt5 already imported\n",
              "exit": 4,
              "description": "Run the test suite",
              "truncated": false
            },
            "time": {
              "start": 1769437385944,
              "end": 1769437401805
            }
          }
        },
        {
          "id": "prt_bfab012f2001ax5XyKxP8yJQuH",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfaafbbd8001EzjM5axKaGgCuC",
          "type": "step-finish",
          "reason": "tool-calls",
          "snapshot": "",
          "cost": 0,
          "tokens": {
            "input": 0,
            "output": 226,
            "reasoning": 0,
            "cache": {
              "read": 43233,
              "write": 12045
            }
          }
        },
        {
          "id": "prt_bfab01659001kwLE8vtxy2xC0I",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfaafbbd8001EzjM5axKaGgCuC",
          "type": "patch",
          "hash": "ac68fec4510681d5231e5a43ca746d43c6f4812b",
          "files": [
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/.github/workflows/bleeding.yml",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/misc/requirements/requirements-pyqt-pyinstaller.txt",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/misc/requirements/requirements-pyqt-pyinstaller.txt-raw",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/misc/requirements/requirements-tests-bleeding.txt",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/misc/userscripts/add-nextcloud-bookmarks",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/misc/userscripts/add-nextcloud-cookbook",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/misc/userscripts/qute-keepassxc",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/browser/webengine/notification.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/commands/parser.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/completion/models/filepathcategory.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/adblockcommands.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/braveadblock.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/hostblock.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/utils/__init__.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/utils/blockutils.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/html/process.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/javascript/quirks/discord.user.js",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/javascript/quirks/globalthis.user.js",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/javascript/quirks/googledocs.user.js",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/javascript/quirks/object_fromentries.user.js",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/javascript/quirks/string_replaceall.user.js",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/javascript/quirks/whatsapp_web.user.js",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/misc/elf.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/utils/resources.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/scripts/dev/change_release.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/blocking/external_logo.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/blocking/qutebrowser-adblock",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/blocking/qutebrowser-hosts",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/brave-adblock/LICENSE",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/brave-adblock/README.md",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/brave-adblock/generate.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/brave-adblock/ublock-matches.tsv.gz",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/crashers/installedapp.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/crashers/webrtc.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/darkmode/blank.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/darkmode/mathml.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/darkmode/mathml.svg",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/darkmode/prefers-color-scheme.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/darkmode/yellow.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/easylist.txt.gz",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/easyprivacy.txt.gz",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/fileselect.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/javascript/img/big.png",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/javascript/img/padded.png",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/javascript/img/padded2.png",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/javascript/img/rgb.png",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/javascript/img/rgba.png",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/javascript/notifications.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/misc/xhr_headers.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/prefers_reduced_motion.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/prompt/script.js",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/service-worker/data.json",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/service-worker/index.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/data/service-worker/worker.js",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/features/notifications.feature",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/features/test_notifications_bdd.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/fixtures/notificationserver.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/templates/https-script.html",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/end2end/test_adblock_e2e.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/helpers/testutils.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/browser/test_downloadview.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/browser/webkit/test_certificateerror.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/commands/test_parser.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/components/test_blockutils.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/components/test_braveadblock.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/components/test_hostblock.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/config/test_qtargs_locale_workaround.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/javascript/test_js_quirks.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/misc/test_elf.py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/scripts/importer_sample/html/bookmarks",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/scripts/importer_sample/html/config_py",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/scripts/importer_sample/html/input",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/scripts/importer_sample/html/quickmarks",
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/utils/test_resources.py"
          ]
        }
      ]
    },
    {
      "info": {
        "id": "msg_bfab01800001vCCFnRwMZBNWEN",
        "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
        "role": "assistant",
        "time": {
          "created": 1769437403136,
          "completed": 1769437518825
        },
        "parentID": "msg_bfaaf7dfd001wtLwIM1eGC5XRs",
        "modelID": "claude-opus-4-5",
        "providerID": "anthropic",
        "mode": "opus-codex",
        "agent": "opus-codex",
        "path": {
          "cwd": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896",
          "root": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896"
        },
        "cost": 0,
        "tokens": {
          "input": 0,
          "output": 255,
          "reasoning": 0,
          "cache": {
            "read": 55278,
            "write": 848
          }
        },
        "finish": "tool-calls"
      },
      "parts": [
        {
          "id": "prt_bfab020110014bAdwV1WEeuvwu",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab01800001vCCFnRwMZBNWEN",
          "type": "step-start",
          "snapshot": ""
        },
        {
          "id": "prt_bfab02016001AT50yIVRZD2JLh",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab01800001vCCFnRwMZBNWEN",
          "type": "text",
          "text": "There seems to be an import path issue. Let me check the PYTHONPATH setup:",
          "time": {
            "start": 1769437405600,
            "end": 1769437405600
          }
        },
        {
          "id": "prt_bfab021a3001dKyk0fWiKBzQ8x",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab01800001vCCFnRwMZBNWEN",
          "type": "tool",
          "callID": "toolu_013AuTzsre3f2rKoKX9ZAytV",
          "tool": "bash",
          "state": {
            "status": "completed",
            "input": {
              "command": "cd /Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896 && source .venv/bin/activate && PYTHONPATH=\"$PWD:$PWD/tests\" QT_QPA_PLATFORM=offscreen pytest tests/unit/components/test_hostblock.py tests/unit/utils/test_urlutils.py tests/unit/config/test_configutils.py -v 2>&1 | head -100",
              "description": "Run tests with PYTHONPATH set",
              "timeout": 300000
            },
            "output": "============================= test session starts ==============================\nplatform darwin -- Python 3.10.15, pytest-7.4.4, pluggy-1.6.0 -- /Users/srihari/work/nilenso/swe-bench-pro-task-setup/qutebrowser/.venv/bin/python3.10\ncachedir: .pytest_cache\nPyQt5 5.15.11 -- Qt runtime 5.15.18 -- Qt compiled 5.15.14\nhypothesis profile 'default' -> deadline=timedelta(milliseconds=600), suppress_health_check=(HealthCheck.function_scoped_fixture,)\nbenchmark: 4.0.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)\nrootdir: /Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896\nconfigfile: pytest.ini\nplugins: mock-3.15.1, instafail-0.5.0, qt-4.5.0, xvfb-3.1.1, hypothesis-6.150.1, bdd-8.1.0, benchmark-4.0.0, rerunfailures-16.1\ncollecting ... collected 418 items\n\ntests/unit/components/test_hostblock.py::test_disabled_blocking_update[True-auto] PASSED [  0%]\ntests/unit/components/test_hostblock.py::test_disabled_blocking_update[True-adblock] PASSED [  0%]\ntests/unit/components/test_hostblock.py::test_disabled_blocking_update[False-auto] PASSED [  0%]\ntests/unit/components/test_hostblock.py::test_disabled_blocking_update[False-adblock] PASSED [  0%]\ntests/unit/components/test_hostblock.py::test_disabled_blocking_update[False-both] PASSED [  1%]\ntests/unit/components/test_hostblock.py::test_disabled_blocking_update[False-hosts] PASSED [  1%]\ntests/unit/components/test_hostblock.py::test_disabled_blocking_per_url PASSED [  1%]\ntests/unit/components/test_hostblock.py::test_no_blocklist_update PASSED [  1%]\ntests/unit/components/test_hostblock.py::test_successful_update PASSED   [  2%]\ntests/unit/components/test_hostblock.py::test_parsing_multiple_hosts_on_line PASSED [  2%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[127.0.0.1-localhost] PASSED [  2%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[27.0.0.1-localhost.localdomain] PASSED [  2%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[27.0.0.1-local] PASSED [  3%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[55.255.255.255-broadcasthost] PASSED [  3%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[:1-localhost] PASSED [  3%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[:1-ip6-localhost] PASSED [  3%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[:1-ip6-loopback] PASSED [  4%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[e80::1%lo0-localhost] PASSED [  4%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[f00::0-ip6-localnet] PASSED [  4%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[f00::0-ip6-mcastprefix] PASSED [  4%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[f02::1-ip6-allnodes] PASSED [  5%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[f02::2-ip6-allrouters] PASSED [  5%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[ff02::3-ip6-allhosts] PASSED [  5%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[.0.0.0-0.0.0.0] PASSED [  5%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[127.0.1.1-myhostname] PASSED [  5%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[127.0.0.53-myhostname] PASSED [  6%]\ntests/unit/components/test_hostblock.py::test_failed_dl_update PASSED    [  6%]\ntests/unit/components/test_hostblock.py::test_invalid_utf8[content] PASSED [  6%]\ntests/unit/components/test_hostblock.py::test_invalid_utf8[comment] PASSED [  6%]\ntests/unit/components/test_hostblock.py::test_invalid_utf8_compiled PASSED [  7%]\ntests/unit/components/test_hostblock.py::test_blocking_with_whitelist PASSED [  7%]\ntests/unit/components/test_hostblock.py::test_config_change_initial PASSED [  7%]\ntests/unit/components/test_hostblock.py::test_config_change PASSED       [  7%]\ntests/unit/components/test_hostblock.py::test_add_directory PASSED       [  8%]\ntests/unit/components/test_hostblock.py::test_adblock_benchmark PASSED   [  8%]\ntests/unit/components/test_hostblock.py::test_subdomain_blocking FAILED  [  8%]\n___________________________ test_subdomain_blocking ____________________________\n\nconfig_stub = <qutebrowser.config.config.Config object at 0x1178ac0d0>\nhost_blocker_factory = <function host_blocker_factory.<locals>.factory at 0x1178aecb0>\n\n    def test_subdomain_blocking(config_stub, host_blocker_factory):\n        config_stub.val.content.blocking.method = \"hosts\"\n        config_stub.val.content.blocking.hosts.lists = None\n        host_blocker = host_blocker_factory()\n        host_blocker._blocked_hosts.add(\"example.com\")\n>       assert host_blocker._is_blocked(QUrl(\"https://subdomain.example.com\"))\nE       AssertionError: assert False\nE        +  where False = <bound method HostBlocker._is_blocked of <qutebrowser.components.hostblock.HostBlocker object at 0x1178237c0>>(PyQt5.QtCore.QUrl('https://subdomain.example.com'))\nE        +    where <bound method HostBlocker._is_blocked of <qutebrowser.components.hostblock.HostBlocker object at 0x1178237c0>> = <qutebrowser.components.hostblock.HostBlocker object at 0x1178237c0>._is_blocked\nE        +    and   PyQt5.QtCore.QUrl('https://subdomain.example.com') = QUrl('https://subdomain.example.com')\n\ntests/unit/components/test_hostblock.py:573: AssertionError\n------------------------------ Captured log call -------------------------------\nDEBUG    config:config.py:351 Config option changed: content.blocking.method = hosts\nDEBUG    config:config.py:351 Config option changed: content.blocking.hosts.lists = None\nDEBUG    network:hostblock.py:79 Configured adblock method hosts, adblock library usable: True\n\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_file_relative_cwd PASSED [  8%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_file_relative PASSED [  9%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_file_relative_os_error PASSED [  9%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_file_absolute[/foo-expected0] PASSED [  9%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_file_absolute[/bar\\n-expected1] PASSED [  9%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_file_absolute_expanded PASSED [ 10%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_address PASSED     [ 10%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_search_term PASSED [ 10%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_search_term_value_error PASSED [ 10%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_no_do_search PASSED [ 11%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_invalid_url[True] PASSED [ 11%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_invalid_url[False] PASSED [ 11%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_empty[] PASSED     [ 11%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_empty[ ] PASSED    [ 11%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_force_search[http://www.qutebrowser.org/] PASSED [ 12%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_force_search[/foo] PASSED [ 12%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_force_search[test] PASSED [ 12%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_get_path_existing[/foo-False] PASSED [ 12%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_get_path_existing[/bar-True] PASSED [ 13%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_get_path_unicode_encode_error PASSED [ 13%]\ntests/unit/utils/test_urlutils.py::test_special_urls[file:///tmp/foo-True] PASSED [ 13%]\ntests/unit/utils/test_urlutils.py::test_special_urls[about:blank-True] PASSED [ 13%]\ntests/unit/utils/test_urlutils.py::test_special_urls[qute:version-True] PASSED [ 14%]\ntests/unit/utils/test_urlutils.py::test_special_urls[qute://version-True] PASSED [ 14%]\ntests/unit/utils/test_urlutils.py::test_special_urls[http://www.qutebrowser.org/-False] PASSED [ 14%]\ntests/unit/utils/test_urlutils.py::test_special_urls[www.qutebrowser.org-False] PASSED [ 14%]\ntests/unit/utils/test_urlutils.py::test_get_search_url[testfoo-www.example.com-q=testfoo-True] PASSED [ 15%]\ntests/unit/utils/test_urlutils.py::test_get_search_url[testfoo-www.example.com-q=testfoo-False] PASSED [ 15%]\ntests/unit/utils/test_urlutils.py::test_get_search_url[test testfoo-www.qutebrowser.org-q=testfoo-True] PASSED [ 15%]\ntests/unit/utils/test_urlutils.py::test_get_search_url[test testfoo-www.qutebrowser.org-q=testfoo-False] PASSED [ 15%]\ntests/unit/utils/test_urlutils.py::test_get_search_url[test testfoo bar foo-www.qutebrowser.org-q=testfoo bar foo-True] PASSED [ 16%]\n",
            "title": "Run tests with PYTHONPATH set",
            "metadata": {
              "output": "============================= test session starts ==============================\nplatform darwin -- Python 3.10.15, pytest-7.4.4, pluggy-1.6.0 -- /Users/srihari/work/nilenso/swe-bench-pro-task-setup/qutebrowser/.venv/bin/python3.10\ncachedir: .pytest_cache\nPyQt5 5.15.11 -- Qt runtime 5.15.18 -- Qt compiled 5.15.14\nhypothesis profile 'default' -> deadline=timedelta(milliseconds=600), suppress_health_check=(HealthCheck.function_scoped_fixture,)\nbenchmark: 4.0.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)\nrootdir: /Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896\nconfigfile: pytest.ini\nplugins: mock-3.15.1, instafail-0.5.0, qt-4.5.0, xvfb-3.1.1, hypothesis-6.150.1, bdd-8.1.0, benchmark-4.0.0, rerunfailures-16.1\ncollecting ... collected 418 items\n\ntests/unit/components/test_hostblock.py::test_disabled_blocking_update[True-auto] PASSED [  0%]\ntests/unit/components/test_hostblock.py::test_disabled_blocking_update[True-adblock] PASSED [  0%]\ntests/unit/components/test_hostblock.py::test_disabled_blocking_update[False-auto] PASSED [  0%]\ntests/unit/components/test_hostblock.py::test_disabled_blocking_update[False-adblock] PASSED [  0%]\ntests/unit/components/test_hostblock.py::test_disabled_blocking_update[False-both] PASSED [  1%]\ntests/unit/components/test_hostblock.py::test_disabled_blocking_update[False-hosts] PASSED [  1%]\ntests/unit/components/test_hostblock.py::test_disabled_blocking_per_url PASSED [  1%]\ntests/unit/components/test_hostblock.py::test_no_blocklist_update PASSED [  1%]\ntests/unit/components/test_hostblock.py::test_successful_update PASSED   [  2%]\ntests/unit/components/test_hostblock.py::test_parsing_multiple_hosts_on_line PASSED [  2%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[127.0.0.1-localhost] PASSED [  2%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[27.0.0.1-localhost.localdomain] PASSED [  2%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[27.0.0.1-local] PASSED [  3%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[55.255.255.255-broadcasthost] PASSED [  3%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[:1-localhost] PASSED [  3%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[:1-ip6-localhost] PASSED [  3%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[:1-ip6-loopback] PASSED [  4%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[e80::1%lo0-localhost] PASSED [  4%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[f00::0-ip6-localnet] PASSED [  4%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[f00::0-ip6-mcastprefix] PASSED [  4%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[f02::1-ip6-allnodes] PASSED [  5%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[f02::2-ip6-allrouters] PASSED [  5%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[ff02::3-ip6-allhosts] PASSED [  5%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[.0.0.0-0.0.0.0] PASSED [  5%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[127.0.1.1-myhostname] PASSED [  5%]\ntests/unit/components/test_hostblock.py::test_whitelisted_lines[127.0.0.53-myhostname] PASSED [  6%]\ntests/unit/components/test_hostblock.py::test_failed_dl_update PASSED    [  6%]\ntests/unit/components/test_hostblock.py::test_invalid_utf8[content] PASSED [  6%]\ntests/unit/components/test_hostblock.py::test_invalid_utf8[comment] PASSED [  6%]\ntests/unit/components/test_hostblock.py::test_invalid_utf8_compiled PASSED [  7%]\ntests/unit/components/test_hostblock.py::test_blocking_with_whitelist PASSED [  7%]\ntests/unit/components/test_hostblock.py::test_config_change_initial PASSED [  7%]\ntests/unit/components/test_hostblock.py::test_config_change PASSED       [  7%]\ntests/unit/components/test_hostblock.py::test_add_directory PASSED       [  8%]\ntests/unit/components/test_hostblock.py::test_adblock_benchmark PASSED   [  8%]\ntests/unit/components/test_hostblock.py::test_subdomain_blocking FAILED  [  8%]\n___________________________ test_subdomain_blocking ____________________________\n\nconfig_stub = <qutebrowser.config.config.Config object at 0x1178ac0d0>\nhost_blocker_factory = <function host_blocker_factory.<locals>.factory at 0x1178aecb0>\n\n    def test_subdomain_blocking(config_stub, host_blocker_factory):\n        config_stub.val.content.blocking.method = \"hosts\"\n        config_stub.val.content.blocking.hosts.lists = None\n        host_blocker = host_blocker_factory()\n        host_blocker._blocked_hosts.add(\"example.com\")\n>       assert host_blocker._is_blocked(QUrl(\"https://subdomain.example.com\"))\nE       AssertionError: assert False\nE        +  where False = <bound method HostBlocker._is_blocked of <qutebrowser.components.hostblock.HostBlocker object at 0x1178237c0>>(PyQt5.QtCore.QUrl('https://subdomain.example.com'))\nE        +    where <bound method HostBlocker._is_blocked of <qutebrowser.components.hostblock.HostBlocker object at 0x1178237c0>> = <qutebrowser.components.hostblock.HostBlocker object at 0x1178237c0>._is_blocked\nE        +    and   PyQt5.QtCore.QUrl('https://subdomain.example.com') = QUrl('https://subdomain.example.com')\n\ntests/unit/components/test_hostblock.py:573: AssertionError\n------------------------------ Captured log call -------------------------------\nDEBUG    config:config.py:351 Config option changed: content.blocking.method = hosts\nDEBUG    config:config.py:351 Config option changed: content.blocking.hosts.lists = None\nDEBUG    network:hostblock.py:79 Configured adblock method hosts, adblock library usable: True\n\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_file_relative_cwd PASSED [  8%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_file_relative PASSED [  9%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_file_relative_os_error PASSED [  9%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_file_absolute[/foo-expected0] PASSED [  9%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_file_absolute[/bar\\n-expected1] PASSED [  9%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_file_absolute_expanded PASSED [ 10%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_address PASSED     [ 10%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_search_term PASSED [ 10%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_search_term_value_error PASSED [ 10%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_no_do_search PASSED [ 11%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_invalid_url[True] PASSED [ 11%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_invalid_url[False] PASSED [ 11%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_empty[] PASSED     [ 11%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_empty[ ] PASSED    [ 11%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_force_search[http://www.qutebrowser.org/] PASSED [ 12%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_force_search[/foo] PASSED [ 12%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_force_search[test] PASSED [ 12%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_get_path_existing[/foo-False] PASSED [ 12%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_get_path_existing[/bar-True] PASSED [ 13%]\ntests/unit/utils/test_urlutils.py::TestFuzzyUrl::test_get_path_unicode_encode_error PASSED [ 13%]\ntests/unit/utils/test_urlutils.py::test_special_urls[file:///tmp/foo-True] PASSED [ 13%]\ntests/unit/utils/test_urlutils.py::test_special_urls[about:blank-True] PASSED [ 13%]\ntests/unit/utils/test_urlutils.py::test_special_urls[qute:version-True] PASSED [ 14%]\ntests/unit/utils/test_urlutils.py::test_special_urls[qute://version-True] PASSED [ 14%]\ntests/unit/utils/test_urlutils.py::test_special_urls[http://www.qutebrowser.org/-False] PASSED [ 14%]\ntests/unit/utils/test_urlutils.py::test_special_urls[www.qutebrowser.org-False] PASSED [ 14%]\ntests/unit/utils/test_urlutils.py::test_get_search_url[testfoo-www.example.com-q=testfoo-True] PASSED [ 15%]\ntests/unit/utils/test_urlutils.py::test_get_search_url[testfoo-www.example.com-q=testfoo-False] PASSED [ 15%]\ntests/unit/utils/test_urlutils.py::test_get_search_url[test testfoo-www.qutebrowser.org-q=testfoo-True] PASSED [ 15%]\ntests/unit/utils/test_urlutils.py::test_get_search_url[test testfoo-www.qutebrowser.org-q=testfoo-False] PASSED [ 15%]\ntests/unit/utils/test_urlutils.py::test_get_search_url[test testfoo bar foo-www.qutebrowser.org-q=testfoo bar foo-True] PASSED [ 16%]\n",
              "exit": 0,
              "description": "Run tests with PYTHONPATH set",
              "truncated": false
            },
            "time": {
              "start": 1769437407347,
              "end": 1769437518616
            }
          }
        },
        {
          "id": "prt_bfab1db1b0016S8ffAgdTRUOzE",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab01800001vCCFnRwMZBNWEN",
          "type": "step-finish",
          "reason": "tool-calls",
          "snapshot": "ac68fec4510681d5231e5a43ca746d43c6f4812b",
          "cost": 0,
          "tokens": {
            "input": 0,
            "output": 255,
            "reasoning": 0,
            "cache": {
              "read": 55278,
              "write": 848
            }
          }
        }
      ]
    },
    {
      "info": {
        "id": "msg_bfab1dbf3001gsd3puVGwot7mE",
        "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
        "role": "assistant",
        "time": {
          "created": 1769437518835,
          "completed": 1769437523208
        },
        "parentID": "msg_bfaaf7dfd001wtLwIM1eGC5XRs",
        "modelID": "claude-opus-4-5",
        "providerID": "anthropic",
        "mode": "opus-codex",
        "agent": "opus-codex",
        "path": {
          "cwd": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896",
          "root": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896"
        },
        "cost": 0,
        "tokens": {
          "input": 0,
          "output": 163,
          "reasoning": 0,
          "cache": {
            "read": 56126,
            "write": 3538
          }
        },
        "finish": "tool-calls"
      },
      "parts": [
        {
          "id": "prt_bfab1e30d001hjI6SSJAJR46O0",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab1dbf3001gsd3puVGwot7mE",
          "type": "step-start",
          "snapshot": "ac68fec4510681d5231e5a43ca746d43c6f4812b"
        },
        {
          "id": "prt_bfab1e30d002H3BDTXkz6mmqhr",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab1dbf3001gsd3puVGwot7mE",
          "type": "text",
          "text": "I can see the test `test_subdomain_blocking` is failing. The issue is clear: when checking if a URL is blocked, the code only checks for exact matches, but it should also check if any parent domain is blocked.\n\nLet me also check if there's a `widened_hostnames` function in urlutils.py (I see a test for it in test_urlutils.py):",
          "time": {
            "start": 1769437522563,
            "end": 1769437522563
          }
        },
        {
          "id": "prt_bfab1ea84001YOFgwaKXE7sQRT",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab1dbf3001gsd3puVGwot7mE",
          "type": "tool",
          "callID": "toolu_01J3mejL5J2XqMKgF26KMPGf",
          "tool": "grep",
          "state": {
            "status": "completed",
            "input": {
              "pattern": "widened_hostnames",
              "include": "*.py"
            },
            "output": "Found 4 matches\n/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/utils/test_urlutils.py:\n  Line 795:         assert list(urlutils.widened_hostnames(hostname)) == expected\n  Line 803:         benchmark(lambda: list(urlutils.widened_hostnames(hostname)))\n\n/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/config/configutils.py:\n  Line 42: def _widened_hostnames(hostname: str) -> Iterable[str]:\n  Line 234:         widened_hosts = _widened_hostnames(url.host().rstrip('.'))",
            "title": "widened_hostnames",
            "metadata": {
              "matches": 4,
              "truncated": false
            },
            "time": {
              "start": 1769437523038,
              "end": 1769437523103
            }
          }
        },
        {
          "id": "prt_bfab1ec9f001dHUlVf1zoPJwCv",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab1dbf3001gsd3puVGwot7mE",
          "type": "step-finish",
          "reason": "tool-calls",
          "snapshot": "ac68fec4510681d5231e5a43ca746d43c6f4812b",
          "cost": 0,
          "tokens": {
            "input": 0,
            "output": 163,
            "reasoning": 0,
            "cache": {
              "read": 56126,
              "write": 3538
            }
          }
        }
      ]
    },
    {
      "info": {
        "id": "msg_bfab1ed140013tkwtIfHLmGItb",
        "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
        "role": "assistant",
        "time": {
          "created": 1769437523220,
          "completed": 1769437526907
        },
        "parentID": "msg_bfaaf7dfd001wtLwIM1eGC5XRs",
        "modelID": "claude-opus-4-5",
        "providerID": "anthropic",
        "mode": "opus-codex",
        "agent": "opus-codex",
        "path": {
          "cwd": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896",
          "root": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896"
        },
        "cost": 0,
        "tokens": {
          "input": 0,
          "output": 181,
          "reasoning": 0,
          "cache": {
            "read": 59664,
            "write": 416
          }
        },
        "finish": "tool-calls"
      },
      "parts": [
        {
          "id": "prt_bfab1f4060011A0Zw9zAqWxG7m",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab1ed140013tkwtIfHLmGItb",
          "type": "step-start",
          "snapshot": "ac68fec4510681d5231e5a43ca746d43c6f4812b"
        },
        {
          "id": "prt_bfab1f4070013F6jYDmZ35b8Gt",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab1ed140013tkwtIfHLmGItb",
          "type": "text",
          "text": "I see! The `widened_hostnames` function exists in configutils.py, but the test expects it to be in urlutils.py. Let me check what's in configutils.py:",
          "time": {
            "start": 1769437525697,
            "end": 1769437525697
          }
        },
        {
          "id": "prt_bfab1f6c2001k9d75dlzPmDdmQ",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab1ed140013tkwtIfHLmGItb",
          "type": "tool",
          "callID": "toolu_01M6wAZU6Le1GqwYY6YWT8yP",
          "tool": "read",
          "state": {
            "status": "completed",
            "input": {
              "filePath": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/config/configutils.py",
              "limit": 100
            },
            "output": "<file>\n00001| # vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n00002| \n00003| # Copyright 2018-2021 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n00004| #\n00005| # This file is part of qutebrowser.\n00006| #\n00007| # qutebrowser is free software: you can redistribute it and/or modify\n00008| # it under the terms of the GNU General Public License as published by\n00009| # the Free Software Foundation, either version 3 of the License, or\n00010| # (at your option) any later version.\n00011| #\n00012| # qutebrowser is distributed in the hope that it will be useful,\n00013| # but WITHOUT ANY WARRANTY; without even the implied warranty of\n00014| # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n00015| # GNU General Public License for more details.\n00016| #\n00017| # You should have received a copy of the GNU General Public License\n00018| # along with qutebrowser.  If not, see <https://www.gnu.org/licenses/>.\n00019| \n00020| \n00021| \"\"\"Utilities and data structures used by various config code.\"\"\"\n00022| \n00023| \n00024| import collections\n00025| import itertools\n00026| import operator\n00027| from typing import (\n00028|     TYPE_CHECKING, Any, Dict, Iterable, Iterator, List, Optional, Sequence, Set, Union,\n00029|     MutableMapping)\n00030| \n00031| from PyQt5.QtCore import QUrl\n00032| from PyQt5.QtGui import QFontDatabase\n00033| from PyQt5.QtWidgets import QApplication\n00034| \n00035| from qutebrowser.utils import utils, urlmatch, usertypes, qtutils\n00036| from qutebrowser.config import configexc\n00037| \n00038| if TYPE_CHECKING:\n00039|     from qutebrowser.config import configdata\n00040| \n00041| \n00042| def _widened_hostnames(hostname: str) -> Iterable[str]:\n00043|     \"\"\"A generator for widening string hostnames.\n00044| \n00045|     Ex: a.c.foo -> [a.c.foo, c.foo, foo]\"\"\"\n00046|     while hostname:\n00047|         yield hostname\n00048|         hostname = hostname.partition(\".\")[-1]\n00049| \n00050| \n00051| class ScopedValue:\n00052| \n00053|     \"\"\"A configuration value which is valid for a UrlPattern.\n00054| \n00055|     Attributes:\n00056|         value: The value itself.\n00057|         pattern: The UrlPattern for the value, or None for global values.\n00058|         hide_userconfig: Hide this customization from config.dump_userconfig().\n00059|     \"\"\"\n00060| \n00061|     id_gen = itertools.count(0)\n00062| \n00063|     def __init__(self, value: Any,\n00064|                  pattern: Optional[urlmatch.UrlPattern],\n00065|                  hide_userconfig: bool = False) -> None:\n00066|         self.value = value\n00067|         self.pattern = pattern\n00068|         self.hide_userconfig = hide_userconfig\n00069|         self.pattern_id = next(ScopedValue.id_gen)\n00070| \n00071|     def __repr__(self) -> str:\n00072|         return utils.get_repr(self, value=self.value, pattern=self.pattern,\n00073|                               hide_userconfig=self.hide_userconfig,\n00074|                               pattern_id=self.pattern_id)\n00075| \n00076| \n00077| class Values:\n00078| \n00079|     \"\"\"A collection of values for a single setting.\n00080| \n00081|     Currently, we store patterns in two dictionaries for different types of\n00082|     lookups. A ordered, pattern keyed map, and an unordered, domain keyed map.\n00083| \n00084|     This means that finding a value based on a pattern is fast, and matching\n00085|     url patterns is fast if all domains are unique.\n00086| \n00087|     If there are many patterns under the domain (or subdomain) that is being\n00088|     evaluated, or any patterns that cannot have a concrete domain found, this\n00089|     will become slow again.\n00090| \n00091|     Attributes:\n00092|         opt: The Option being customized.\n00093|         _vmap: A mapping of all pattern objects to ScopedValues.\n00094|         _domain_map: A mapping from hostnames to all associated ScopedValues.\n00095|     \"\"\"\n00096| \n00097|     _VmapKeyType = Optional[urlmatch.UrlPattern]\n00098| \n00099|     def __init__(self,\n00100|                  opt: 'configdata.Option',\n\n(File has more lines. Use 'offset' parameter to read beyond line 100)\n</file>",
            "title": "qutebrowser/config/configutils.py",
            "metadata": {
              "preview": "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n\n# Copyright 2018-2021 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n#\n# This file is part of qutebrowser.\n#\n# qutebrowser is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# qutebrowser is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with qutebrowser.  If not, see <https://www.gnu.org/licenses/>.\n\n",
              "truncated": true
            },
            "time": {
              "start": 1769437526677,
              "end": 1769437526679
            }
          }
        },
        {
          "id": "prt_bfab1fae1001u07KYZoh1sDszd",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab1ed140013tkwtIfHLmGItb",
          "type": "step-finish",
          "reason": "tool-calls",
          "snapshot": "",
          "cost": 0,
          "tokens": {
            "input": 0,
            "output": 181,
            "reasoning": 0,
            "cache": {
              "read": 59664,
              "write": 416
            }
          }
        }
      ]
    },
    {
      "info": {
        "id": "msg_bfab1fbc0001Jku7go8HA576nt",
        "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
        "role": "assistant",
        "time": {
          "created": 1769437526976,
          "completed": 1769437532624
        },
        "parentID": "msg_bfaaf7dfd001wtLwIM1eGC5XRs",
        "modelID": "claude-opus-4-5",
        "providerID": "anthropic",
        "mode": "opus-codex",
        "agent": "opus-codex",
        "path": {
          "cwd": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896",
          "root": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896"
        },
        "cost": 0,
        "tokens": {
          "input": 0,
          "output": 350,
          "reasoning": 0,
          "cache": {
            "read": 60080,
            "write": 1488
          }
        },
        "finish": "tool-calls"
      },
      "parts": [
        {
          "id": "prt_bfab20280001NHB9vCGvsJ1iqt",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab1fbc0001Jku7go8HA576nt",
          "type": "step-start",
          "snapshot": "ac68fec4510681d5231e5a43ca746d43c6f4812b"
        },
        {
          "id": "prt_bfab20284001hzymiJYCdUMizh",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab1fbc0001Jku7go8HA576nt",
          "type": "text",
          "text": "I see that there's a `_widened_hostnames` function in configutils.py. The tests expect a `widened_hostnames` (note: without the leading underscore) function in urlutils.py. Let me check the test more carefully:\n\nLooking at the test file again:\n- `test_widen_hostnames` in test_urlutils.py expects `urlutils.widened_hostnames(hostname)` to exist\n- The test `test_subdomain_blocking` in test_hostblock.py expects `host_blocker._is_blocked(QUrl(\"https://subdomain.example.com\"))` to return `True` when `example.com` is blocked\n\nSo I need to:\n1. Add a `widened_hostnames` function to urlutils.py\n2. Update the `_is_blocked` method in hostblock.py to use this function to check for subdomain matches\n\nLet me create the changes:",
          "time": {
            "start": 1769437531503,
            "end": 1769437531503
          }
        },
        {
          "id": "prt_bfab20d70001a9qolhgpCN3LkK",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab1fbc0001Jku7go8HA576nt",
          "type": "tool",
          "callID": "toolu_01GafAWRex3b9oNHnw3JLN9Z",
          "tool": "read",
          "state": {
            "status": "completed",
            "input": {
              "filePath": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/utils/urlutils.py",
              "offset": 610
            },
            "output": "<file>\n00611|         raise Error(\"URL contains unexpected components: {}\"\n00612|                     .format(url.authority()))\n00613| \n00614|     urlstr = url.toString(QUrl.FullyEncoded)  # type: ignore[arg-type]\n00615|     urlstr = urllib.parse.unquote(urlstr)\n00616| \n00617|     code = urlstr[len('javascript:'):]\n00618|     if not code:\n00619|         raise Error(\"Resulted in empty JavaScript code\")\n00620| \n00621|     return code\n00622| \n\n(End of file - total 622 lines)\n</file>",
            "title": "qutebrowser/utils/urlutils.py",
            "metadata": {
              "preview": "        raise Error(\"URL contains unexpected components: {}\"\n                    .format(url.authority()))\n\n    urlstr = url.toString(QUrl.FullyEncoded)  # type: ignore[arg-type]\n    urlstr = urllib.parse.unquote(urlstr)\n\n    code = urlstr[len('javascript:'):]\n    if not code:\n        raise Error(\"Resulted in empty JavaScript code\")\n\n    return code\n",
              "truncated": false
            },
            "time": {
              "start": 1769437532345,
              "end": 1769437532386
            }
          }
        },
        {
          "id": "prt_bfab210e5001BFvrL9bFNlbvhI",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab1fbc0001Jku7go8HA576nt",
          "type": "step-finish",
          "reason": "tool-calls",
          "snapshot": "ac68fec4510681d5231e5a43ca746d43c6f4812b",
          "cost": 0,
          "tokens": {
            "input": 0,
            "output": 350,
            "reasoning": 0,
            "cache": {
              "read": 60080,
              "write": 1488
            }
          }
        }
      ]
    },
    {
      "info": {
        "id": "msg_bfab211ec0016gxmFapOdYikDC",
        "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
        "role": "assistant",
        "time": {
          "created": 1769437532652,
          "completed": 1769437539815
        },
        "parentID": "msg_bfaaf7dfd001wtLwIM1eGC5XRs",
        "modelID": "claude-opus-4-5",
        "providerID": "anthropic",
        "mode": "opus-codex",
        "agent": "opus-codex",
        "path": {
          "cwd": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896",
          "root": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896"
        },
        "cost": 0,
        "tokens": {
          "input": 0,
          "output": 299,
          "reasoning": 0,
          "cache": {
            "read": 61568,
            "write": 524
          }
        },
        "finish": "tool-calls"
      },
      "parts": [
        {
          "id": "prt_bfab219570019MVFFTNEKSbzoS",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab211ec0016gxmFapOdYikDC",
          "type": "step-start",
          "snapshot": "ac68fec4510681d5231e5a43ca746d43c6f4812b"
        },
        {
          "id": "prt_bfab21959001KWnbe3Im1F4pdh",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab211ec0016gxmFapOdYikDC",
          "type": "text",
          "text": "Now let me add the `widened_hostnames` function to urlutils.py:",
          "time": {
            "start": 1769437534678,
            "end": 1769437534678
          }
        },
        {
          "id": "prt_bfab219d9001XnkN0lF56JMWYk",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab211ec0016gxmFapOdYikDC",
          "type": "tool",
          "callID": "toolu_017TavaAaoydsm8NLoCNA5W5",
          "tool": "edit",
          "state": {
            "status": "completed",
            "input": {
              "filePath": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/utils/urlutils.py",
              "oldString": "    return code\n",
              "newString": "    return code\n\n\ndef widened_hostnames(hostname: Optional[str]) -> Iterator[str]:\n    \"\"\"A generator that yields widening string hostnames.\n\n    Ex: a.c.foo -> [a.c.foo, c.foo, foo]\n\n    Args:\n        hostname: The hostname string to widen.\n\n    Yields:\n        The hostname and its parent domains.\n    \"\"\"\n    if not hostname:\n        return\n    while hostname:\n        yield hostname\n        hostname = hostname.partition(\".\")[-1]\n"
            },
            "output": "Edit applied successfully.\n\nLSP errors detected in this file, please fix:\n<diagnostics file=\"/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/utils/urlutils.py\">\nERROR [194:26] Expression of type \"None\" cannot be assigned to parameter of type \"str\"\n\"None\" is not assignable to \"str\"\nERROR [350:34] Expression of type \"None\" cannot be assigned to parameter of type \"str\"\n\"None\" is not assignable to \"str\"\nERROR [397:50] Expression of type \"None\" cannot be assigned to parameter of type \"str\"\n\"None\" is not assignable to \"str\"\n</diagnostics>",
            "title": "qutebrowser/utils/urlutils.py",
            "metadata": {
              "diagnostics": {
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/components/test_hostblock.py": [],
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/utils/test_urlutils.py": [
                  {
                    "range": {
                      "start": {
                        "line": 81,
                        "character": 40
                      },
                      "end": {
                        "line": 81,
                        "character": 55
                      }
                    },
                    "message": "Argument of type \"() -> bool\" cannot be assigned to parameter \"error\" of type \"bool\" in function \"__init__\"\n\"MethodType\" is not assignable to \"bool\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 794,
                        "character": 29
                      },
                      "end": {
                        "line": 794,
                        "character": 46
                      }
                    },
                    "message": "\"widened_hostnames\" is not a known attribute of module \"qutebrowser.utils.urlutils\"",
                    "severity": 1,
                    "code": "reportAttributeAccessIssue",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportAttributeAccessIssue"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 802,
                        "character": 40
                      },
                      "end": {
                        "line": 802,
                        "character": 57
                      }
                    },
                    "message": "\"widened_hostnames\" is not a known attribute of module \"qutebrowser.utils.urlutils\"",
                    "severity": 1,
                    "code": "reportAttributeAccessIssue",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportAttributeAccessIssue"
                    }
                  }
                ],
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/hostblock.py": [
                  {
                    "range": {
                      "start": {
                        "line": 113,
                        "character": 69
                      },
                      "end": {
                        "line": 113,
                        "character": 73
                      }
                    },
                    "message": "Expression of type \"None\" cannot be assigned to parameter of type \"QUrl\"\n\"None\" is not assignable to \"QUrl\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 119,
                        "character": 30
                      },
                      "end": {
                        "line": 119,
                        "character": 34
                      }
                    },
                    "message": "Type \"None\" is not assignable to declared type \"QUrl\"\n\"None\" is not assignable to \"QUrl\"",
                    "severity": 1,
                    "code": "reportAssignmentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportAssignmentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 134,
                        "character": 58
                      },
                      "end": {
                        "line": 134,
                        "character": 78
                      }
                    },
                    "message": "Argument of type \"Unknown | None\" cannot be assigned to parameter \"first_party_url\" of type \"QUrl\" in function \"_is_blocked\"\nType \"Unknown | None\" is not assignable to type \"QUrl\"\n\"None\" is not assignable to \"QUrl\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  }
                ],
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/utils/urlutils.py": [
                  {
                    "range": {
                      "start": {
                        "line": 193,
                        "character": 25
                      },
                      "end": {
                        "line": 193,
                        "character": 29
                      }
                    },
                    "message": "Expression of type \"None\" cannot be assigned to parameter of type \"str\"\n\"None\" is not assignable to \"str\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 349,
                        "character": 33
                      },
                      "end": {
                        "line": 349,
                        "character": 37
                      }
                    },
                    "message": "Expression of type \"None\" cannot be assigned to parameter of type \"str\"\n\"None\" is not assignable to \"str\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 396,
                        "character": 49
                      },
                      "end": {
                        "line": 396,
                        "character": 53
                      }
                    },
                    "message": "Expression of type \"None\" cannot be assigned to parameter of type \"str\"\n\"None\" is not assignable to \"str\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  }
                ],
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/config/test_configutils.py": [
                  {
                    "range": {
                      "start": {
                        "line": 33,
                        "character": 63
                      },
                      "end": {
                        "line": 33,
                        "character": 67
                      }
                    },
                    "message": "Argument of type \"None\" cannot be assigned to parameter \"backends\" of type \"Iterable[Backend]\" in function \"__init__\"\n\"None\" is incompatible with protocol \"Iterable[Backend]\"\n\"__iter__\" is not present",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 34,
                        "character": 60
                      },
                      "end": {
                        "line": 34,
                        "character": 64
                      }
                    },
                    "message": "Argument of type \"None\" cannot be assigned to parameter \"description\" of type \"str\" in function \"__init__\"\n\"None\" is not assignable to \"str\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  }
                ],
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/config/configutils.py": []
              },
              "diff": "Index: /Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/utils/urlutils.py\n===================================================================\n--- /Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/utils/urlutils.py\n+++ /Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/utils/urlutils.py\n@@ -618,4 +618,22 @@\n     if not code:\n         raise Error(\"Resulted in empty JavaScript code\")\n \n     return code\n+\n+\n+def widened_hostnames(hostname: Optional[str]) -> Iterator[str]:\n+    \"\"\"A generator that yields widening string hostnames.\n+\n+    Ex: a.c.foo -> [a.c.foo, c.foo, foo]\n+\n+    Args:\n+        hostname: The hostname string to widen.\n+\n+    Yields:\n+        The hostname and its parent domains.\n+    \"\"\"\n+    if not hostname:\n+        return\n+    while hostname:\n+        yield hostname\n+        hostname = hostname.partition(\".\")[-1]\n",
              "filediff": {
                "file": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/utils/urlutils.py",
                "before": "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n\n# Copyright 2014-2021 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n#\n# This file is part of qutebrowser.\n#\n# qutebrowser is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# qutebrowser is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with qutebrowser.  If not, see <https://www.gnu.org/licenses/>.\n\n\"\"\"Utils regarding URL handling.\"\"\"\n\nimport re\nimport base64\nimport os.path\nimport ipaddress\nimport posixpath\nimport urllib.parse\nimport mimetypes\nfrom typing import Optional, Tuple, Union\n\nfrom PyQt5.QtCore import QUrl\nfrom PyQt5.QtNetwork import QHostInfo, QHostAddress, QNetworkProxy\n\nfrom qutebrowser.api import cmdutils\nfrom qutebrowser.config import config\nfrom qutebrowser.utils import log, qtutils, message, utils\nfrom qutebrowser.browser.network import pac\n\n\n# FIXME: we probably could raise some exceptions on invalid URLs\n# https://github.com/qutebrowser/qutebrowser/issues/108\n\n\n# URL schemes supported by QtWebEngine\nWEBENGINE_SCHEMES = [\n    'about',\n    'data',\n    'file',\n    'filesystem',\n    'ftp',\n    'http',\n    'https',\n    'javascript',\n    'ws',\n    'wss',\n]\n\n\nclass Error(Exception):\n\n    \"\"\"Base class for errors in this module.\"\"\"\n\n\nclass InvalidUrlError(Error):\n\n    \"\"\"Error raised if a function got an invalid URL.\"\"\"\n\n    def __init__(self, url: QUrl) -> None:\n        if url.isValid():\n            raise ValueError(\"Got valid URL {}!\".format(url.toDisplayString()))\n        self.url = url\n        self.msg = get_errstring(url)\n        super().__init__(self.msg)\n\n\ndef _parse_search_term(s: str) -> Tuple[Optional[str], Optional[str]]:\n    \"\"\"Get a search engine name and search term from a string.\n\n    Args:\n        s: The string to get a search engine for.\n\n    Return:\n        A (engine, term) tuple, where engine is None for the default engine.\n    \"\"\"\n    s = s.strip()\n    split = s.split(maxsplit=1)\n    if not split:\n        raise ValueError(\"Empty search term!\")\n\n    if len(split) == 2:\n        if split[0] in config.val.url.searchengines:\n            engine: Optional[str] = split[0]\n            term: Optional[str] = split[1]\n        else:\n            engine = None\n            term = s\n    else:\n        if config.val.url.open_base_url and s in config.val.url.searchengines:\n            engine = s\n            term = None\n        else:\n            engine = None\n            term = s\n\n    log.url.debug(\"engine {}, term {!r}\".format(engine, term))\n    return (engine, term)\n\n\ndef _get_search_url(txt: str) -> QUrl:\n    \"\"\"Get a search engine URL for a text.\n\n    Args:\n        txt: Text to search for.\n\n    Return:\n        The search URL as a QUrl.\n    \"\"\"\n    log.url.debug(\"Finding search engine for {!r}\".format(txt))\n    engine, term = _parse_search_term(txt)\n    if not engine:\n        engine = 'DEFAULT'\n    if term:\n        template = config.val.url.searchengines[engine]\n        semiquoted_term = urllib.parse.quote(term)\n        quoted_term = urllib.parse.quote(term, safe='')\n        evaluated = template.format(semiquoted_term,\n                                    unquoted=term,\n                                    quoted=quoted_term,\n                                    semiquoted=semiquoted_term)\n        url = QUrl.fromUserInput(evaluated)\n    else:\n        url = QUrl.fromUserInput(config.val.url.searchengines[engine])\n        url.setPath(None)  # type: ignore[arg-type]\n        url.setFragment(None)  # type: ignore[arg-type]\n        url.setQuery(None)  # type: ignore[call-overload]\n    qtutils.ensure_valid(url)\n    return url\n\n\ndef _is_url_naive(urlstr: str) -> bool:\n    \"\"\"Naive check if given URL is really a URL.\n\n    Args:\n        urlstr: The URL to check for, as string.\n\n    Return:\n        True if the URL really is a URL, False otherwise.\n    \"\"\"\n    url = QUrl.fromUserInput(urlstr)\n    assert url.isValid()\n    host = url.host()\n\n    # Valid IPv4/IPv6 address. Qt converts things like \"23.42\" or \"1337\" or\n    # \"0xDEAD\" to IP addresses, which we don't like, so we check if the host\n    # from Qt is part of the input.\n    if (not utils.raises(ValueError, ipaddress.ip_address, host) and\n            host in urlstr):\n        return True\n\n    tld = r'\\.([^.0-9_-]+|xn--[a-z0-9-]+)$'\n    forbidden = r'[\\u0000-\\u002c\\u002f\\u003a-\\u0060\\u007b-\\u00b6]'\n    return bool(re.search(tld, host) and not re.search(forbidden, host))\n\n\ndef _is_url_dns(urlstr: str) -> bool:\n    \"\"\"Check if a URL is really a URL via DNS.\n\n    Args:\n        url: The URL to check for as a string.\n\n    Return:\n        True if the URL really is a URL, False otherwise.\n    \"\"\"\n    url = QUrl.fromUserInput(urlstr)\n    assert url.isValid()\n\n    if (utils.raises(ValueError, ipaddress.ip_address, urlstr) and\n            not QHostAddress(urlstr).isNull()):\n        log.url.debug(\"Bogus IP URL -> False\")\n        # Qt treats things like \"23.42\" or \"1337\" or \"0xDEAD\" as valid URLs\n        # which we don't want to.\n        return False\n\n    host = url.host()\n    if not host:\n        log.url.debug(\"URL has no host -> False\")\n        return False\n    log.url.debug(\"Doing DNS request for {}\".format(host))\n    info = QHostInfo.fromName(host)\n    return not info.error()\n\n\ndef fuzzy_url(urlstr: str,\n              cwd: str = None,\n              relative: bool = False,\n              do_search: bool = True,\n              force_search: bool = False) -> QUrl:\n    \"\"\"Get a QUrl based on a user input which is URL or search term.\n\n    Args:\n        urlstr: URL to load as a string.\n        cwd: The current working directory, or None.\n        relative: Whether to resolve relative files.\n        do_search: Whether to perform a search on non-URLs.\n        force_search: Whether to force a search even if the content can be\n                      interpreted as a URL or a path.\n\n    Return:\n        A target QUrl to a search page or the original URL.\n    \"\"\"\n    urlstr = urlstr.strip()\n    path = get_path_if_valid(urlstr, cwd=cwd, relative=relative,\n                             check_exists=True)\n\n    if not force_search and path is not None:\n        url = QUrl.fromLocalFile(path)\n    elif force_search or (do_search and not is_url(urlstr)):\n        # probably a search term\n        log.url.debug(\"URL is a fuzzy search term\")\n        try:\n            url = _get_search_url(urlstr)\n        except ValueError:  # invalid search engine\n            url = QUrl.fromUserInput(urlstr)\n    else:  # probably an address\n        log.url.debug(\"URL is a fuzzy address\")\n        url = QUrl.fromUserInput(urlstr)\n    log.url.debug(\"Converting fuzzy term {!r} to URL -> {}\".format(\n        urlstr, url.toDisplayString()))\n    ensure_valid(url)\n    return url\n\n\ndef _has_explicit_scheme(url: QUrl) -> bool:\n    \"\"\"Check if a url has an explicit scheme given.\n\n    Args:\n        url: The URL as QUrl.\n    \"\"\"\n    # Note that generic URI syntax actually would allow a second colon\n    # after the scheme delimiter. Since we don't know of any URIs\n    # using this and want to support e.g. searching for scoped C++\n    # symbols, we treat this as not a URI anyways.\n    return bool(url.isValid() and url.scheme() and\n                (url.host() or url.path()) and\n                not url.path().startswith(':'))\n\n\ndef is_special_url(url: QUrl) -> bool:\n    \"\"\"Return True if url is an about:... or other special URL.\n\n    Args:\n        url: The URL as QUrl.\n    \"\"\"\n    if not url.isValid():\n        return False\n    special_schemes = ('about', 'qute', 'file')\n    return url.scheme() in special_schemes\n\n\ndef is_url(urlstr: str) -> bool:\n    \"\"\"Check if url seems to be a valid URL.\n\n    Args:\n        urlstr: The URL as string.\n\n    Return:\n        True if it is a valid URL, False otherwise.\n    \"\"\"\n    autosearch = config.val.url.auto_search\n\n    log.url.debug(\"Checking if {!r} is a URL (autosearch={}).\".format(\n        urlstr, autosearch))\n\n    urlstr = urlstr.strip()\n    qurl = QUrl(urlstr)\n    qurl_userinput = QUrl.fromUserInput(urlstr)\n\n    if autosearch == 'never':\n        # no autosearch, so everything is a URL unless it has an explicit\n        # search engine.\n        try:\n            engine, _term = _parse_search_term(urlstr)\n        except ValueError:\n            return False\n        else:\n            return engine is None\n\n    if not qurl_userinput.isValid():\n        # This will also catch non-URLs containing spaces.\n        return False\n\n    if _has_explicit_scheme(qurl) and ' ' not in urlstr:\n        # URLs with explicit schemes are always URLs\n        log.url.debug(\"Contains explicit scheme\")\n        url = True\n    elif (autosearch == 'schemeless' and\n          (not _has_explicit_scheme(qurl) or ' ' in urlstr)):\n        # When autosearch=schemeless, URLs must contain schemes to be valid\n        log.url.debug(\"No explicit scheme in given URL, treating as non-URL\")\n        url = False\n    elif qurl_userinput.host() in ['localhost', '127.0.0.1', '::1']:\n        log.url.debug(\"Is localhost.\")\n        url = True\n    elif is_special_url(qurl):\n        # Special URLs are always URLs, even with autosearch=never\n        log.url.debug(\"Is a special URL.\")\n        url = True\n    elif autosearch == 'dns':\n        log.url.debug(\"Checking via DNS check\")\n        # We want to use QUrl.fromUserInput here, as the user might enter\n        # \"foo.de\" and that should be treated as URL here.\n        url = ' ' not in qurl_userinput.userName() and _is_url_dns(urlstr)\n    elif autosearch == 'naive':\n        log.url.debug(\"Checking via naive check\")\n        url = ' ' not in qurl_userinput.userName() and _is_url_naive(urlstr)\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid autosearch value\")\n    log.url.debug(\"url = {}\".format(url))\n    return url\n\n\ndef ensure_valid(url: QUrl) -> None:\n    if not url.isValid():\n        raise InvalidUrlError(url)\n\n\ndef invalid_url_error(url: QUrl, action: str) -> None:\n    \"\"\"Display an error message for a URL.\n\n    Args:\n        action: The action which was interrupted by the error.\n    \"\"\"\n    if url.isValid():\n        raise ValueError(\"Calling invalid_url_error with valid URL {}\".format(\n            url.toDisplayString()))\n    errstring = get_errstring(\n        url, \"Trying to {} with invalid URL\".format(action))\n    message.error(errstring)\n\n\ndef raise_cmdexc_if_invalid(url: QUrl) -> None:\n    \"\"\"Check if the given QUrl is invalid, and if so, raise a CommandError.\"\"\"\n    try:\n        ensure_valid(url)\n    except InvalidUrlError as e:\n        raise cmdutils.CommandError(str(e))\n\n\ndef get_path_if_valid(pathstr: str,\n                      cwd: str = None,\n                      relative: bool = False,\n                      check_exists: bool = False) -> Optional[str]:\n    \"\"\"Check if path is a valid path.\n\n    Args:\n        pathstr: The path as string.\n        cwd: The current working directory, or None.\n        relative: Whether to resolve relative files.\n        check_exists: Whether to check if the file\n                      actually exists of filesystem.\n\n    Return:\n        The path if it is a valid path, None otherwise.\n    \"\"\"\n    pathstr = pathstr.strip()\n    log.url.debug(\"Checking if {!r} is a path\".format(pathstr))\n    expanded = os.path.expanduser(pathstr)\n\n    if os.path.isabs(expanded):\n        path: Optional[str] = expanded\n    elif relative and cwd:\n        path = os.path.join(cwd, expanded)\n    elif relative:\n        try:\n            path = os.path.abspath(expanded)\n        except OSError:\n            path = None\n    else:\n        path = None\n\n    if check_exists:\n        if path is not None:\n            try:\n                if os.path.exists(path):\n                    log.url.debug(\"URL is a local file\")\n                else:\n                    path = None\n            except UnicodeEncodeError:\n                log.url.debug(\n                    \"URL contains characters which are not present in the \"\n                    \"current locale\")\n                path = None\n\n    return path\n\n\ndef filename_from_url(url: QUrl, fallback: str = None) -> Optional[str]:\n    \"\"\"Get a suitable filename from a URL.\n\n    Args:\n        url: The URL to parse, as a QUrl.\n        fallback: Value to use if no name can be determined.\n\n    Return:\n        The suggested filename as a string, or None.\n    \"\"\"\n    if not url.isValid():\n        return fallback\n\n    if url.scheme().lower() == 'data':\n        mimetype, _encoding = mimetypes.guess_type(url.toString())\n        if not mimetype:\n            return fallback\n\n        ext = utils.mimetype_extension(mimetype) or ''\n        return 'download' + ext\n\n    pathname = posixpath.basename(url.path())\n    if pathname:\n        return pathname\n    elif url.host():\n        return url.host() + '.html'\n    else:\n        return fallback\n\n\nHostTupleType = Tuple[str, str, int]\n\n\ndef host_tuple(url: QUrl) -> HostTupleType:\n    \"\"\"Get a (scheme, host, port) tuple from a QUrl.\n\n    This is suitable to identify a connection, e.g. for SSL errors.\n    \"\"\"\n    ensure_valid(url)\n    scheme, host, port = url.scheme(), url.host(), url.port()\n    assert scheme\n    if not host:\n        raise ValueError(\"Got URL {} without host.\".format(\n            url.toDisplayString()))\n    if port == -1:\n        port_mapping = {\n            'http': 80,\n            'https': 443,\n            'ftp': 21,\n        }\n        try:\n            port = port_mapping[scheme]\n        except KeyError:\n            raise ValueError(\"Got URL {} with unknown port.\".format(\n                url.toDisplayString()))\n    return scheme, host, port\n\n\ndef get_errstring(url: QUrl, base: str = \"Invalid URL\") -> str:\n    \"\"\"Get an error string for a URL.\n\n    Args:\n        url: The URL as a QUrl.\n        base: The base error string.\n\n    Return:\n        A new string with url.errorString() is appended if available.\n    \"\"\"\n    url_error = url.errorString()\n    if url_error:\n        return base + \" - {}\".format(url_error)\n    else:\n        return base\n\n\ndef same_domain(url1: QUrl, url2: QUrl) -> bool:\n    \"\"\"Check if url1 and url2 belong to the same website.\n\n    This will use a \"public suffix list\" to determine what a \"top level domain\"\n    is. All further domains are ignored.\n\n    For example example.com and www.example.com are considered the same. but\n    example.co.uk and test.co.uk are not.\n\n    If the URL's schemes or ports are different, they are always treated as not equal.\n\n    Return:\n        True if the domains are the same, False otherwise.\n    \"\"\"\n    ensure_valid(url1)\n    ensure_valid(url2)\n\n    if url1.scheme() != url2.scheme():\n        return False\n    if url1.port() != url2.port():\n        return False\n\n    suffix1 = url1.topLevelDomain()\n    suffix2 = url2.topLevelDomain()\n    if not suffix1:\n        return url1.host() == url2.host()\n\n    if suffix1 != suffix2:\n        return False\n\n    domain1 = url1.host()[:-len(suffix1)].split('.')[-1]\n    domain2 = url2.host()[:-len(suffix2)].split('.')[-1]\n    return domain1 == domain2\n\n\ndef encoded_url(url: QUrl) -> str:\n    \"\"\"Return the fully encoded url as string.\n\n    Args:\n        url: The url to encode as QUrl.\n    \"\"\"\n    return url.toEncoded().data().decode('ascii')\n\n\ndef file_url(path: str) -> str:\n    \"\"\"Return a file:// url (as string) to the given local path.\n\n    Arguments:\n        path: The absolute path to the local file\n    \"\"\"\n    url = QUrl.fromLocalFile(path)\n    return url.toString(QUrl.FullyEncoded)  # type: ignore[arg-type]\n\n\ndef data_url(mimetype: str, data: bytes) -> QUrl:\n    \"\"\"Get a data: QUrl for the given data.\"\"\"\n    b64 = base64.b64encode(data).decode('ascii')\n    url = QUrl('data:{};base64,{}'.format(mimetype, b64))\n    qtutils.ensure_valid(url)\n    return url\n\n\ndef safe_display_string(qurl: QUrl) -> str:\n    \"\"\"Get a IDN-homograph phishing safe form of the given QUrl.\n\n    If we're dealing with a Punycode-encoded URL, this prepends the hostname in\n    its encoded form, to make sure those URLs are distinguishable.\n\n    See https://github.com/qutebrowser/qutebrowser/issues/2547\n    and https://bugreports.qt.io/browse/QTBUG-60365\n    \"\"\"\n    ensure_valid(qurl)\n\n    host = qurl.host(QUrl.FullyEncoded)\n    assert '..' not in host, qurl  # https://bugreports.qt.io/browse/QTBUG-60364\n\n    for part in host.split('.'):\n        url_host = qurl.host(QUrl.FullyDecoded)\n        if part.startswith('xn--') and host != url_host:\n            return '({}) {}'.format(host, qurl.toDisplayString())\n\n    return qurl.toDisplayString()\n\n\nclass InvalidProxyTypeError(Exception):\n\n    \"\"\"Error raised when proxy_from_url gets an unknown proxy type.\"\"\"\n\n    def __init__(self, typ: str) -> None:\n        super().__init__(\"Invalid proxy type {}!\".format(typ))\n\n\ndef proxy_from_url(url: QUrl) -> Union[QNetworkProxy, pac.PACFetcher]:\n    \"\"\"Create a QNetworkProxy from QUrl and a proxy type.\n\n    Args:\n        url: URL of a proxy (possibly with credentials).\n\n    Return:\n        New QNetworkProxy.\n    \"\"\"\n    ensure_valid(url)\n\n    scheme = url.scheme()\n    if scheme in ['pac+http', 'pac+https', 'pac+file']:\n        fetcher = pac.PACFetcher(url)\n        fetcher.fetch()\n        return fetcher\n\n    types = {\n        'http': QNetworkProxy.HttpProxy,\n        'socks': QNetworkProxy.Socks5Proxy,\n        'socks5': QNetworkProxy.Socks5Proxy,\n        'direct': QNetworkProxy.NoProxy,\n    }\n    if scheme not in types:\n        raise InvalidProxyTypeError(scheme)\n\n    proxy = QNetworkProxy(types[scheme], url.host())\n\n    if url.port() != -1:\n        proxy.setPort(url.port())\n    if url.userName():\n        proxy.setUser(url.userName())\n    if url.password():\n        proxy.setPassword(url.password())\n    return proxy\n\n\ndef parse_javascript_url(url: QUrl) -> str:\n    \"\"\"Get JavaScript source from the given URL.\n\n    See https://wiki.whatwg.org/wiki/URL_schemes#javascript:_URLs\n    and https://github.com/whatwg/url/issues/385\n    \"\"\"\n    ensure_valid(url)\n    if url.scheme() != 'javascript':\n        raise Error(\"Expected a javascript:... URL\")\n    if url.authority():\n        raise Error(\"URL contains unexpected components: {}\"\n                    .format(url.authority()))\n\n    urlstr = url.toString(QUrl.FullyEncoded)  # type: ignore[arg-type]\n    urlstr = urllib.parse.unquote(urlstr)\n\n    code = urlstr[len('javascript:'):]\n    if not code:\n        raise Error(\"Resulted in empty JavaScript code\")\n\n    return code\n",
                "after": "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n\n# Copyright 2014-2021 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n#\n# This file is part of qutebrowser.\n#\n# qutebrowser is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# qutebrowser is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with qutebrowser.  If not, see <https://www.gnu.org/licenses/>.\n\n\"\"\"Utils regarding URL handling.\"\"\"\n\nimport re\nimport base64\nimport os.path\nimport ipaddress\nimport posixpath\nimport urllib.parse\nimport mimetypes\nfrom typing import Optional, Tuple, Union\n\nfrom PyQt5.QtCore import QUrl\nfrom PyQt5.QtNetwork import QHostInfo, QHostAddress, QNetworkProxy\n\nfrom qutebrowser.api import cmdutils\nfrom qutebrowser.config import config\nfrom qutebrowser.utils import log, qtutils, message, utils\nfrom qutebrowser.browser.network import pac\n\n\n# FIXME: we probably could raise some exceptions on invalid URLs\n# https://github.com/qutebrowser/qutebrowser/issues/108\n\n\n# URL schemes supported by QtWebEngine\nWEBENGINE_SCHEMES = [\n    'about',\n    'data',\n    'file',\n    'filesystem',\n    'ftp',\n    'http',\n    'https',\n    'javascript',\n    'ws',\n    'wss',\n]\n\n\nclass Error(Exception):\n\n    \"\"\"Base class for errors in this module.\"\"\"\n\n\nclass InvalidUrlError(Error):\n\n    \"\"\"Error raised if a function got an invalid URL.\"\"\"\n\n    def __init__(self, url: QUrl) -> None:\n        if url.isValid():\n            raise ValueError(\"Got valid URL {}!\".format(url.toDisplayString()))\n        self.url = url\n        self.msg = get_errstring(url)\n        super().__init__(self.msg)\n\n\ndef _parse_search_term(s: str) -> Tuple[Optional[str], Optional[str]]:\n    \"\"\"Get a search engine name and search term from a string.\n\n    Args:\n        s: The string to get a search engine for.\n\n    Return:\n        A (engine, term) tuple, where engine is None for the default engine.\n    \"\"\"\n    s = s.strip()\n    split = s.split(maxsplit=1)\n    if not split:\n        raise ValueError(\"Empty search term!\")\n\n    if len(split) == 2:\n        if split[0] in config.val.url.searchengines:\n            engine: Optional[str] = split[0]\n            term: Optional[str] = split[1]\n        else:\n            engine = None\n            term = s\n    else:\n        if config.val.url.open_base_url and s in config.val.url.searchengines:\n            engine = s\n            term = None\n        else:\n            engine = None\n            term = s\n\n    log.url.debug(\"engine {}, term {!r}\".format(engine, term))\n    return (engine, term)\n\n\ndef _get_search_url(txt: str) -> QUrl:\n    \"\"\"Get a search engine URL for a text.\n\n    Args:\n        txt: Text to search for.\n\n    Return:\n        The search URL as a QUrl.\n    \"\"\"\n    log.url.debug(\"Finding search engine for {!r}\".format(txt))\n    engine, term = _parse_search_term(txt)\n    if not engine:\n        engine = 'DEFAULT'\n    if term:\n        template = config.val.url.searchengines[engine]\n        semiquoted_term = urllib.parse.quote(term)\n        quoted_term = urllib.parse.quote(term, safe='')\n        evaluated = template.format(semiquoted_term,\n                                    unquoted=term,\n                                    quoted=quoted_term,\n                                    semiquoted=semiquoted_term)\n        url = QUrl.fromUserInput(evaluated)\n    else:\n        url = QUrl.fromUserInput(config.val.url.searchengines[engine])\n        url.setPath(None)  # type: ignore[arg-type]\n        url.setFragment(None)  # type: ignore[arg-type]\n        url.setQuery(None)  # type: ignore[call-overload]\n    qtutils.ensure_valid(url)\n    return url\n\n\ndef _is_url_naive(urlstr: str) -> bool:\n    \"\"\"Naive check if given URL is really a URL.\n\n    Args:\n        urlstr: The URL to check for, as string.\n\n    Return:\n        True if the URL really is a URL, False otherwise.\n    \"\"\"\n    url = QUrl.fromUserInput(urlstr)\n    assert url.isValid()\n    host = url.host()\n\n    # Valid IPv4/IPv6 address. Qt converts things like \"23.42\" or \"1337\" or\n    # \"0xDEAD\" to IP addresses, which we don't like, so we check if the host\n    # from Qt is part of the input.\n    if (not utils.raises(ValueError, ipaddress.ip_address, host) and\n            host in urlstr):\n        return True\n\n    tld = r'\\.([^.0-9_-]+|xn--[a-z0-9-]+)$'\n    forbidden = r'[\\u0000-\\u002c\\u002f\\u003a-\\u0060\\u007b-\\u00b6]'\n    return bool(re.search(tld, host) and not re.search(forbidden, host))\n\n\ndef _is_url_dns(urlstr: str) -> bool:\n    \"\"\"Check if a URL is really a URL via DNS.\n\n    Args:\n        url: The URL to check for as a string.\n\n    Return:\n        True if the URL really is a URL, False otherwise.\n    \"\"\"\n    url = QUrl.fromUserInput(urlstr)\n    assert url.isValid()\n\n    if (utils.raises(ValueError, ipaddress.ip_address, urlstr) and\n            not QHostAddress(urlstr).isNull()):\n        log.url.debug(\"Bogus IP URL -> False\")\n        # Qt treats things like \"23.42\" or \"1337\" or \"0xDEAD\" as valid URLs\n        # which we don't want to.\n        return False\n\n    host = url.host()\n    if not host:\n        log.url.debug(\"URL has no host -> False\")\n        return False\n    log.url.debug(\"Doing DNS request for {}\".format(host))\n    info = QHostInfo.fromName(host)\n    return not info.error()\n\n\ndef fuzzy_url(urlstr: str,\n              cwd: str = None,\n              relative: bool = False,\n              do_search: bool = True,\n              force_search: bool = False) -> QUrl:\n    \"\"\"Get a QUrl based on a user input which is URL or search term.\n\n    Args:\n        urlstr: URL to load as a string.\n        cwd: The current working directory, or None.\n        relative: Whether to resolve relative files.\n        do_search: Whether to perform a search on non-URLs.\n        force_search: Whether to force a search even if the content can be\n                      interpreted as a URL or a path.\n\n    Return:\n        A target QUrl to a search page or the original URL.\n    \"\"\"\n    urlstr = urlstr.strip()\n    path = get_path_if_valid(urlstr, cwd=cwd, relative=relative,\n                             check_exists=True)\n\n    if not force_search and path is not None:\n        url = QUrl.fromLocalFile(path)\n    elif force_search or (do_search and not is_url(urlstr)):\n        # probably a search term\n        log.url.debug(\"URL is a fuzzy search term\")\n        try:\n            url = _get_search_url(urlstr)\n        except ValueError:  # invalid search engine\n            url = QUrl.fromUserInput(urlstr)\n    else:  # probably an address\n        log.url.debug(\"URL is a fuzzy address\")\n        url = QUrl.fromUserInput(urlstr)\n    log.url.debug(\"Converting fuzzy term {!r} to URL -> {}\".format(\n        urlstr, url.toDisplayString()))\n    ensure_valid(url)\n    return url\n\n\ndef _has_explicit_scheme(url: QUrl) -> bool:\n    \"\"\"Check if a url has an explicit scheme given.\n\n    Args:\n        url: The URL as QUrl.\n    \"\"\"\n    # Note that generic URI syntax actually would allow a second colon\n    # after the scheme delimiter. Since we don't know of any URIs\n    # using this and want to support e.g. searching for scoped C++\n    # symbols, we treat this as not a URI anyways.\n    return bool(url.isValid() and url.scheme() and\n                (url.host() or url.path()) and\n                not url.path().startswith(':'))\n\n\ndef is_special_url(url: QUrl) -> bool:\n    \"\"\"Return True if url is an about:... or other special URL.\n\n    Args:\n        url: The URL as QUrl.\n    \"\"\"\n    if not url.isValid():\n        return False\n    special_schemes = ('about', 'qute', 'file')\n    return url.scheme() in special_schemes\n\n\ndef is_url(urlstr: str) -> bool:\n    \"\"\"Check if url seems to be a valid URL.\n\n    Args:\n        urlstr: The URL as string.\n\n    Return:\n        True if it is a valid URL, False otherwise.\n    \"\"\"\n    autosearch = config.val.url.auto_search\n\n    log.url.debug(\"Checking if {!r} is a URL (autosearch={}).\".format(\n        urlstr, autosearch))\n\n    urlstr = urlstr.strip()\n    qurl = QUrl(urlstr)\n    qurl_userinput = QUrl.fromUserInput(urlstr)\n\n    if autosearch == 'never':\n        # no autosearch, so everything is a URL unless it has an explicit\n        # search engine.\n        try:\n            engine, _term = _parse_search_term(urlstr)\n        except ValueError:\n            return False\n        else:\n            return engine is None\n\n    if not qurl_userinput.isValid():\n        # This will also catch non-URLs containing spaces.\n        return False\n\n    if _has_explicit_scheme(qurl) and ' ' not in urlstr:\n        # URLs with explicit schemes are always URLs\n        log.url.debug(\"Contains explicit scheme\")\n        url = True\n    elif (autosearch == 'schemeless' and\n          (not _has_explicit_scheme(qurl) or ' ' in urlstr)):\n        # When autosearch=schemeless, URLs must contain schemes to be valid\n        log.url.debug(\"No explicit scheme in given URL, treating as non-URL\")\n        url = False\n    elif qurl_userinput.host() in ['localhost', '127.0.0.1', '::1']:\n        log.url.debug(\"Is localhost.\")\n        url = True\n    elif is_special_url(qurl):\n        # Special URLs are always URLs, even with autosearch=never\n        log.url.debug(\"Is a special URL.\")\n        url = True\n    elif autosearch == 'dns':\n        log.url.debug(\"Checking via DNS check\")\n        # We want to use QUrl.fromUserInput here, as the user might enter\n        # \"foo.de\" and that should be treated as URL here.\n        url = ' ' not in qurl_userinput.userName() and _is_url_dns(urlstr)\n    elif autosearch == 'naive':\n        log.url.debug(\"Checking via naive check\")\n        url = ' ' not in qurl_userinput.userName() and _is_url_naive(urlstr)\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid autosearch value\")\n    log.url.debug(\"url = {}\".format(url))\n    return url\n\n\ndef ensure_valid(url: QUrl) -> None:\n    if not url.isValid():\n        raise InvalidUrlError(url)\n\n\ndef invalid_url_error(url: QUrl, action: str) -> None:\n    \"\"\"Display an error message for a URL.\n\n    Args:\n        action: The action which was interrupted by the error.\n    \"\"\"\n    if url.isValid():\n        raise ValueError(\"Calling invalid_url_error with valid URL {}\".format(\n            url.toDisplayString()))\n    errstring = get_errstring(\n        url, \"Trying to {} with invalid URL\".format(action))\n    message.error(errstring)\n\n\ndef raise_cmdexc_if_invalid(url: QUrl) -> None:\n    \"\"\"Check if the given QUrl is invalid, and if so, raise a CommandError.\"\"\"\n    try:\n        ensure_valid(url)\n    except InvalidUrlError as e:\n        raise cmdutils.CommandError(str(e))\n\n\ndef get_path_if_valid(pathstr: str,\n                      cwd: str = None,\n                      relative: bool = False,\n                      check_exists: bool = False) -> Optional[str]:\n    \"\"\"Check if path is a valid path.\n\n    Args:\n        pathstr: The path as string.\n        cwd: The current working directory, or None.\n        relative: Whether to resolve relative files.\n        check_exists: Whether to check if the file\n                      actually exists of filesystem.\n\n    Return:\n        The path if it is a valid path, None otherwise.\n    \"\"\"\n    pathstr = pathstr.strip()\n    log.url.debug(\"Checking if {!r} is a path\".format(pathstr))\n    expanded = os.path.expanduser(pathstr)\n\n    if os.path.isabs(expanded):\n        path: Optional[str] = expanded\n    elif relative and cwd:\n        path = os.path.join(cwd, expanded)\n    elif relative:\n        try:\n            path = os.path.abspath(expanded)\n        except OSError:\n            path = None\n    else:\n        path = None\n\n    if check_exists:\n        if path is not None:\n            try:\n                if os.path.exists(path):\n                    log.url.debug(\"URL is a local file\")\n                else:\n                    path = None\n            except UnicodeEncodeError:\n                log.url.debug(\n                    \"URL contains characters which are not present in the \"\n                    \"current locale\")\n                path = None\n\n    return path\n\n\ndef filename_from_url(url: QUrl, fallback: str = None) -> Optional[str]:\n    \"\"\"Get a suitable filename from a URL.\n\n    Args:\n        url: The URL to parse, as a QUrl.\n        fallback: Value to use if no name can be determined.\n\n    Return:\n        The suggested filename as a string, or None.\n    \"\"\"\n    if not url.isValid():\n        return fallback\n\n    if url.scheme().lower() == 'data':\n        mimetype, _encoding = mimetypes.guess_type(url.toString())\n        if not mimetype:\n            return fallback\n\n        ext = utils.mimetype_extension(mimetype) or ''\n        return 'download' + ext\n\n    pathname = posixpath.basename(url.path())\n    if pathname:\n        return pathname\n    elif url.host():\n        return url.host() + '.html'\n    else:\n        return fallback\n\n\nHostTupleType = Tuple[str, str, int]\n\n\ndef host_tuple(url: QUrl) -> HostTupleType:\n    \"\"\"Get a (scheme, host, port) tuple from a QUrl.\n\n    This is suitable to identify a connection, e.g. for SSL errors.\n    \"\"\"\n    ensure_valid(url)\n    scheme, host, port = url.scheme(), url.host(), url.port()\n    assert scheme\n    if not host:\n        raise ValueError(\"Got URL {} without host.\".format(\n            url.toDisplayString()))\n    if port == -1:\n        port_mapping = {\n            'http': 80,\n            'https': 443,\n            'ftp': 21,\n        }\n        try:\n            port = port_mapping[scheme]\n        except KeyError:\n            raise ValueError(\"Got URL {} with unknown port.\".format(\n                url.toDisplayString()))\n    return scheme, host, port\n\n\ndef get_errstring(url: QUrl, base: str = \"Invalid URL\") -> str:\n    \"\"\"Get an error string for a URL.\n\n    Args:\n        url: The URL as a QUrl.\n        base: The base error string.\n\n    Return:\n        A new string with url.errorString() is appended if available.\n    \"\"\"\n    url_error = url.errorString()\n    if url_error:\n        return base + \" - {}\".format(url_error)\n    else:\n        return base\n\n\ndef same_domain(url1: QUrl, url2: QUrl) -> bool:\n    \"\"\"Check if url1 and url2 belong to the same website.\n\n    This will use a \"public suffix list\" to determine what a \"top level domain\"\n    is. All further domains are ignored.\n\n    For example example.com and www.example.com are considered the same. but\n    example.co.uk and test.co.uk are not.\n\n    If the URL's schemes or ports are different, they are always treated as not equal.\n\n    Return:\n        True if the domains are the same, False otherwise.\n    \"\"\"\n    ensure_valid(url1)\n    ensure_valid(url2)\n\n    if url1.scheme() != url2.scheme():\n        return False\n    if url1.port() != url2.port():\n        return False\n\n    suffix1 = url1.topLevelDomain()\n    suffix2 = url2.topLevelDomain()\n    if not suffix1:\n        return url1.host() == url2.host()\n\n    if suffix1 != suffix2:\n        return False\n\n    domain1 = url1.host()[:-len(suffix1)].split('.')[-1]\n    domain2 = url2.host()[:-len(suffix2)].split('.')[-1]\n    return domain1 == domain2\n\n\ndef encoded_url(url: QUrl) -> str:\n    \"\"\"Return the fully encoded url as string.\n\n    Args:\n        url: The url to encode as QUrl.\n    \"\"\"\n    return url.toEncoded().data().decode('ascii')\n\n\ndef file_url(path: str) -> str:\n    \"\"\"Return a file:// url (as string) to the given local path.\n\n    Arguments:\n        path: The absolute path to the local file\n    \"\"\"\n    url = QUrl.fromLocalFile(path)\n    return url.toString(QUrl.FullyEncoded)  # type: ignore[arg-type]\n\n\ndef data_url(mimetype: str, data: bytes) -> QUrl:\n    \"\"\"Get a data: QUrl for the given data.\"\"\"\n    b64 = base64.b64encode(data).decode('ascii')\n    url = QUrl('data:{};base64,{}'.format(mimetype, b64))\n    qtutils.ensure_valid(url)\n    return url\n\n\ndef safe_display_string(qurl: QUrl) -> str:\n    \"\"\"Get a IDN-homograph phishing safe form of the given QUrl.\n\n    If we're dealing with a Punycode-encoded URL, this prepends the hostname in\n    its encoded form, to make sure those URLs are distinguishable.\n\n    See https://github.com/qutebrowser/qutebrowser/issues/2547\n    and https://bugreports.qt.io/browse/QTBUG-60365\n    \"\"\"\n    ensure_valid(qurl)\n\n    host = qurl.host(QUrl.FullyEncoded)\n    assert '..' not in host, qurl  # https://bugreports.qt.io/browse/QTBUG-60364\n\n    for part in host.split('.'):\n        url_host = qurl.host(QUrl.FullyDecoded)\n        if part.startswith('xn--') and host != url_host:\n            return '({}) {}'.format(host, qurl.toDisplayString())\n\n    return qurl.toDisplayString()\n\n\nclass InvalidProxyTypeError(Exception):\n\n    \"\"\"Error raised when proxy_from_url gets an unknown proxy type.\"\"\"\n\n    def __init__(self, typ: str) -> None:\n        super().__init__(\"Invalid proxy type {}!\".format(typ))\n\n\ndef proxy_from_url(url: QUrl) -> Union[QNetworkProxy, pac.PACFetcher]:\n    \"\"\"Create a QNetworkProxy from QUrl and a proxy type.\n\n    Args:\n        url: URL of a proxy (possibly with credentials).\n\n    Return:\n        New QNetworkProxy.\n    \"\"\"\n    ensure_valid(url)\n\n    scheme = url.scheme()\n    if scheme in ['pac+http', 'pac+https', 'pac+file']:\n        fetcher = pac.PACFetcher(url)\n        fetcher.fetch()\n        return fetcher\n\n    types = {\n        'http': QNetworkProxy.HttpProxy,\n        'socks': QNetworkProxy.Socks5Proxy,\n        'socks5': QNetworkProxy.Socks5Proxy,\n        'direct': QNetworkProxy.NoProxy,\n    }\n    if scheme not in types:\n        raise InvalidProxyTypeError(scheme)\n\n    proxy = QNetworkProxy(types[scheme], url.host())\n\n    if url.port() != -1:\n        proxy.setPort(url.port())\n    if url.userName():\n        proxy.setUser(url.userName())\n    if url.password():\n        proxy.setPassword(url.password())\n    return proxy\n\n\ndef parse_javascript_url(url: QUrl) -> str:\n    \"\"\"Get JavaScript source from the given URL.\n\n    See https://wiki.whatwg.org/wiki/URL_schemes#javascript:_URLs\n    and https://github.com/whatwg/url/issues/385\n    \"\"\"\n    ensure_valid(url)\n    if url.scheme() != 'javascript':\n        raise Error(\"Expected a javascript:... URL\")\n    if url.authority():\n        raise Error(\"URL contains unexpected components: {}\"\n                    .format(url.authority()))\n\n    urlstr = url.toString(QUrl.FullyEncoded)  # type: ignore[arg-type]\n    urlstr = urllib.parse.unquote(urlstr)\n\n    code = urlstr[len('javascript:'):]\n    if not code:\n        raise Error(\"Resulted in empty JavaScript code\")\n\n    return code\n\n\ndef widened_hostnames(hostname: Optional[str]) -> Iterator[str]:\n    \"\"\"A generator that yields widening string hostnames.\n\n    Ex: a.c.foo -> [a.c.foo, c.foo, foo]\n\n    Args:\n        hostname: The hostname string to widen.\n\n    Yields:\n        The hostname and its parent domains.\n    \"\"\"\n    if not hostname:\n        return\n    while hostname:\n        yield hostname\n        hostname = hostname.partition(\".\")[-1]\n",
                "additions": 18,
                "deletions": 0
              },
              "truncated": false
            },
            "time": {
              "start": 1769437537123,
              "end": 1769437539590
            }
          }
        },
        {
          "id": "prt_bfab22d0f001w9b94A090nWdJu",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab211ec0016gxmFapOdYikDC",
          "type": "step-finish",
          "reason": "tool-calls",
          "snapshot": "abc07ac80fe6fb3668ba7ea75fd29a824e3a90d5",
          "cost": 0,
          "tokens": {
            "input": 0,
            "output": 299,
            "reasoning": 0,
            "cache": {
              "read": 61568,
              "write": 524
            }
          }
        },
        {
          "id": "prt_bfab22de2001ahBXV9y97Kp5m9",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab211ec0016gxmFapOdYikDC",
          "type": "patch",
          "hash": "ac68fec4510681d5231e5a43ca746d43c6f4812b",
          "files": [
            "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/utils/urlutils.py"
          ]
        }
      ]
    },
    {
      "info": {
        "id": "msg_bfab22e0800190JlYDmLQ5sgc1",
        "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
        "role": "assistant",
        "time": {
          "created": 1769437539848,
          "completed": 1769437543410
        },
        "parentID": "msg_bfaaf7dfd001wtLwIM1eGC5XRs",
        "modelID": "claude-opus-4-5",
        "providerID": "anthropic",
        "mode": "opus-codex",
        "agent": "opus-codex",
        "path": {
          "cwd": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896",
          "root": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896"
        },
        "cost": 0,
        "tokens": {
          "input": 0,
          "output": 187,
          "reasoning": 0,
          "cache": {
            "read": 62092,
            "write": 511
          }
        },
        "finish": "tool-calls"
      },
      "parts": [
        {
          "id": "prt_bfab2352b001jhB0vzEq665OA7",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab22e0800190JlYDmLQ5sgc1",
          "type": "step-start",
          "snapshot": "abc07ac80fe6fb3668ba7ea75fd29a824e3a90d5"
        },
        {
          "id": "prt_bfab2352e001lOkdwFLIbHaCog",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab22e0800190JlYDmLQ5sgc1",
          "type": "text",
          "text": "The LSP errors aren't related to my change - they're pre-existing issues with type hints. Let me also add the missing `Iterator` import:",
          "time": {
            "start": 1769437542345,
            "end": 1769437542345
          }
        },
        {
          "id": "prt_bfab237ca0011EQiNvTBDSu6hV",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab22e0800190JlYDmLQ5sgc1",
          "type": "tool",
          "callID": "toolu_01KZnSLDNYeL37VzJ5V1XZrT",
          "tool": "read",
          "state": {
            "status": "completed",
            "input": {
              "filePath": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/utils/urlutils.py",
              "offset": 25,
              "limit": 10
            },
            "output": "<file>\n00026| import posixpath\n00027| import urllib.parse\n00028| import mimetypes\n00029| from typing import Optional, Tuple, Union\n00030| \n00031| from PyQt5.QtCore import QUrl\n00032| from PyQt5.QtNetwork import QHostInfo, QHostAddress, QNetworkProxy\n00033| \n00034| from qutebrowser.api import cmdutils\n00035| from qutebrowser.config import config\n\n(File has more lines. Use 'offset' parameter to read beyond line 35)\n</file>",
            "title": "qutebrowser/utils/urlutils.py",
            "metadata": {
              "preview": "import posixpath\nimport urllib.parse\nimport mimetypes\nfrom typing import Optional, Tuple, Union\n\nfrom PyQt5.QtCore import QUrl\nfrom PyQt5.QtNetwork import QHostInfo, QHostAddress, QNetworkProxy\n\nfrom qutebrowser.api import cmdutils\nfrom qutebrowser.config import config",
              "truncated": true
            },
            "time": {
              "start": 1769437543216,
              "end": 1769437543225
            }
          }
        },
        {
          "id": "prt_bfab23b41001a3FZwrwQXjeKO8",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab22e0800190JlYDmLQ5sgc1",
          "type": "step-finish",
          "reason": "tool-calls",
          "snapshot": "",
          "cost": 0,
          "tokens": {
            "input": 0,
            "output": 187,
            "reasoning": 0,
            "cache": {
              "read": 62092,
              "write": 511
            }
          }
        }
      ]
    },
    {
      "info": {
        "id": "msg_bfab23c13001ypLw7zFrKGX3wX",
        "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
        "role": "assistant",
        "time": {
          "created": 1769437543443,
          "completed": 1769437549635
        },
        "parentID": "msg_bfaaf7dfd001wtLwIM1eGC5XRs",
        "modelID": "claude-opus-4-5",
        "providerID": "anthropic",
        "mode": "opus-codex",
        "agent": "opus-codex",
        "path": {
          "cwd": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896",
          "root": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896"
        },
        "cost": 0,
        "tokens": {
          "input": 0,
          "output": 174,
          "reasoning": 0,
          "cache": {
            "read": 62603,
            "write": 336
          }
        },
        "finish": "tool-calls"
      },
      "parts": [
        {
          "id": "prt_bfab243ec001SeAVGW59JSxTD5",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab23c13001ypLw7zFrKGX3wX",
          "type": "step-start",
          "snapshot": ""
        },
        {
          "id": "prt_bfab243ef001iNx9mpLyIwthnt",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab23c13001ypLw7zFrKGX3wX",
          "type": "tool",
          "callID": "toolu_01DP8zCCBop9AzNx5p4DTS7q",
          "tool": "edit",
          "state": {
            "status": "completed",
            "input": {
              "filePath": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/utils/urlutils.py",
              "oldString": "from typing import Optional, Tuple, Union",
              "newString": "from typing import Iterator, Optional, Tuple, Union"
            },
            "output": "Edit applied successfully.\n\nLSP errors detected in this file, please fix:\n<diagnostics file=\"/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/utils/urlutils.py\">\nERROR [194:26] Expression of type \"None\" cannot be assigned to parameter of type \"str\"\n\"None\" is not assignable to \"str\"\nERROR [350:34] Expression of type \"None\" cannot be assigned to parameter of type \"str\"\n\"None\" is not assignable to \"str\"\nERROR [397:50] Expression of type \"None\" cannot be assigned to parameter of type \"str\"\n\"None\" is not assignable to \"str\"\n</diagnostics>",
            "title": "qutebrowser/utils/urlutils.py",
            "metadata": {
              "diagnostics": {
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/components/test_hostblock.py": [],
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/utils/test_urlutils.py": [
                  {
                    "range": {
                      "start": {
                        "line": 81,
                        "character": 40
                      },
                      "end": {
                        "line": 81,
                        "character": 55
                      }
                    },
                    "message": "Argument of type \"() -> bool\" cannot be assigned to parameter \"error\" of type \"bool\" in function \"__init__\"\n\"MethodType\" is not assignable to \"bool\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 794,
                        "character": 29
                      },
                      "end": {
                        "line": 794,
                        "character": 46
                      }
                    },
                    "message": "\"widened_hostnames\" is not a known attribute of module \"qutebrowser.utils.urlutils\"",
                    "severity": 1,
                    "code": "reportAttributeAccessIssue",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportAttributeAccessIssue"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 802,
                        "character": 40
                      },
                      "end": {
                        "line": 802,
                        "character": 57
                      }
                    },
                    "message": "\"widened_hostnames\" is not a known attribute of module \"qutebrowser.utils.urlutils\"",
                    "severity": 1,
                    "code": "reportAttributeAccessIssue",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportAttributeAccessIssue"
                    }
                  }
                ],
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/hostblock.py": [
                  {
                    "range": {
                      "start": {
                        "line": 113,
                        "character": 69
                      },
                      "end": {
                        "line": 113,
                        "character": 73
                      }
                    },
                    "message": "Expression of type \"None\" cannot be assigned to parameter of type \"QUrl\"\n\"None\" is not assignable to \"QUrl\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 119,
                        "character": 30
                      },
                      "end": {
                        "line": 119,
                        "character": 34
                      }
                    },
                    "message": "Type \"None\" is not assignable to declared type \"QUrl\"\n\"None\" is not assignable to \"QUrl\"",
                    "severity": 1,
                    "code": "reportAssignmentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportAssignmentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 134,
                        "character": 58
                      },
                      "end": {
                        "line": 134,
                        "character": 78
                      }
                    },
                    "message": "Argument of type \"Unknown | None\" cannot be assigned to parameter \"first_party_url\" of type \"QUrl\" in function \"_is_blocked\"\nType \"Unknown | None\" is not assignable to type \"QUrl\"\n\"None\" is not assignable to \"QUrl\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  }
                ],
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/utils/urlutils.py": [
                  {
                    "range": {
                      "start": {
                        "line": 193,
                        "character": 25
                      },
                      "end": {
                        "line": 193,
                        "character": 29
                      }
                    },
                    "message": "Expression of type \"None\" cannot be assigned to parameter of type \"str\"\n\"None\" is not assignable to \"str\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 349,
                        "character": 33
                      },
                      "end": {
                        "line": 349,
                        "character": 37
                      }
                    },
                    "message": "Expression of type \"None\" cannot be assigned to parameter of type \"str\"\n\"None\" is not assignable to \"str\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 396,
                        "character": 49
                      },
                      "end": {
                        "line": 396,
                        "character": 53
                      }
                    },
                    "message": "Expression of type \"None\" cannot be assigned to parameter of type \"str\"\n\"None\" is not assignable to \"str\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  }
                ],
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/config/test_configutils.py": [
                  {
                    "range": {
                      "start": {
                        "line": 33,
                        "character": 63
                      },
                      "end": {
                        "line": 33,
                        "character": 67
                      }
                    },
                    "message": "Argument of type \"None\" cannot be assigned to parameter \"backends\" of type \"Iterable[Backend]\" in function \"__init__\"\n\"None\" is incompatible with protocol \"Iterable[Backend]\"\n\"__iter__\" is not present",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 34,
                        "character": 60
                      },
                      "end": {
                        "line": 34,
                        "character": 64
                      }
                    },
                    "message": "Argument of type \"None\" cannot be assigned to parameter \"description\" of type \"str\" in function \"__init__\"\n\"None\" is not assignable to \"str\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  }
                ],
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/config/configutils.py": []
              },
              "diff": "Index: /Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/utils/urlutils.py\n===================================================================\n--- /Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/utils/urlutils.py\n+++ /Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/utils/urlutils.py\n@@ -25,9 +25,9 @@\n import ipaddress\n import posixpath\n import urllib.parse\n import mimetypes\n-from typing import Optional, Tuple, Union\n+from typing import Iterator, Optional, Tuple, Union\n \n from PyQt5.QtCore import QUrl\n from PyQt5.QtNetwork import QHostInfo, QHostAddress, QNetworkProxy\n \n",
              "filediff": {
                "file": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/utils/urlutils.py",
                "before": "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n\n# Copyright 2014-2021 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n#\n# This file is part of qutebrowser.\n#\n# qutebrowser is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# qutebrowser is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with qutebrowser.  If not, see <https://www.gnu.org/licenses/>.\n\n\"\"\"Utils regarding URL handling.\"\"\"\n\nimport re\nimport base64\nimport os.path\nimport ipaddress\nimport posixpath\nimport urllib.parse\nimport mimetypes\nfrom typing import Optional, Tuple, Union\n\nfrom PyQt5.QtCore import QUrl\nfrom PyQt5.QtNetwork import QHostInfo, QHostAddress, QNetworkProxy\n\nfrom qutebrowser.api import cmdutils\nfrom qutebrowser.config import config\nfrom qutebrowser.utils import log, qtutils, message, utils\nfrom qutebrowser.browser.network import pac\n\n\n# FIXME: we probably could raise some exceptions on invalid URLs\n# https://github.com/qutebrowser/qutebrowser/issues/108\n\n\n# URL schemes supported by QtWebEngine\nWEBENGINE_SCHEMES = [\n    'about',\n    'data',\n    'file',\n    'filesystem',\n    'ftp',\n    'http',\n    'https',\n    'javascript',\n    'ws',\n    'wss',\n]\n\n\nclass Error(Exception):\n\n    \"\"\"Base class for errors in this module.\"\"\"\n\n\nclass InvalidUrlError(Error):\n\n    \"\"\"Error raised if a function got an invalid URL.\"\"\"\n\n    def __init__(self, url: QUrl) -> None:\n        if url.isValid():\n            raise ValueError(\"Got valid URL {}!\".format(url.toDisplayString()))\n        self.url = url\n        self.msg = get_errstring(url)\n        super().__init__(self.msg)\n\n\ndef _parse_search_term(s: str) -> Tuple[Optional[str], Optional[str]]:\n    \"\"\"Get a search engine name and search term from a string.\n\n    Args:\n        s: The string to get a search engine for.\n\n    Return:\n        A (engine, term) tuple, where engine is None for the default engine.\n    \"\"\"\n    s = s.strip()\n    split = s.split(maxsplit=1)\n    if not split:\n        raise ValueError(\"Empty search term!\")\n\n    if len(split) == 2:\n        if split[0] in config.val.url.searchengines:\n            engine: Optional[str] = split[0]\n            term: Optional[str] = split[1]\n        else:\n            engine = None\n            term = s\n    else:\n        if config.val.url.open_base_url and s in config.val.url.searchengines:\n            engine = s\n            term = None\n        else:\n            engine = None\n            term = s\n\n    log.url.debug(\"engine {}, term {!r}\".format(engine, term))\n    return (engine, term)\n\n\ndef _get_search_url(txt: str) -> QUrl:\n    \"\"\"Get a search engine URL for a text.\n\n    Args:\n        txt: Text to search for.\n\n    Return:\n        The search URL as a QUrl.\n    \"\"\"\n    log.url.debug(\"Finding search engine for {!r}\".format(txt))\n    engine, term = _parse_search_term(txt)\n    if not engine:\n        engine = 'DEFAULT'\n    if term:\n        template = config.val.url.searchengines[engine]\n        semiquoted_term = urllib.parse.quote(term)\n        quoted_term = urllib.parse.quote(term, safe='')\n        evaluated = template.format(semiquoted_term,\n                                    unquoted=term,\n                                    quoted=quoted_term,\n                                    semiquoted=semiquoted_term)\n        url = QUrl.fromUserInput(evaluated)\n    else:\n        url = QUrl.fromUserInput(config.val.url.searchengines[engine])\n        url.setPath(None)  # type: ignore[arg-type]\n        url.setFragment(None)  # type: ignore[arg-type]\n        url.setQuery(None)  # type: ignore[call-overload]\n    qtutils.ensure_valid(url)\n    return url\n\n\ndef _is_url_naive(urlstr: str) -> bool:\n    \"\"\"Naive check if given URL is really a URL.\n\n    Args:\n        urlstr: The URL to check for, as string.\n\n    Return:\n        True if the URL really is a URL, False otherwise.\n    \"\"\"\n    url = QUrl.fromUserInput(urlstr)\n    assert url.isValid()\n    host = url.host()\n\n    # Valid IPv4/IPv6 address. Qt converts things like \"23.42\" or \"1337\" or\n    # \"0xDEAD\" to IP addresses, which we don't like, so we check if the host\n    # from Qt is part of the input.\n    if (not utils.raises(ValueError, ipaddress.ip_address, host) and\n            host in urlstr):\n        return True\n\n    tld = r'\\.([^.0-9_-]+|xn--[a-z0-9-]+)$'\n    forbidden = r'[\\u0000-\\u002c\\u002f\\u003a-\\u0060\\u007b-\\u00b6]'\n    return bool(re.search(tld, host) and not re.search(forbidden, host))\n\n\ndef _is_url_dns(urlstr: str) -> bool:\n    \"\"\"Check if a URL is really a URL via DNS.\n\n    Args:\n        url: The URL to check for as a string.\n\n    Return:\n        True if the URL really is a URL, False otherwise.\n    \"\"\"\n    url = QUrl.fromUserInput(urlstr)\n    assert url.isValid()\n\n    if (utils.raises(ValueError, ipaddress.ip_address, urlstr) and\n            not QHostAddress(urlstr).isNull()):\n        log.url.debug(\"Bogus IP URL -> False\")\n        # Qt treats things like \"23.42\" or \"1337\" or \"0xDEAD\" as valid URLs\n        # which we don't want to.\n        return False\n\n    host = url.host()\n    if not host:\n        log.url.debug(\"URL has no host -> False\")\n        return False\n    log.url.debug(\"Doing DNS request for {}\".format(host))\n    info = QHostInfo.fromName(host)\n    return not info.error()\n\n\ndef fuzzy_url(urlstr: str,\n              cwd: str = None,\n              relative: bool = False,\n              do_search: bool = True,\n              force_search: bool = False) -> QUrl:\n    \"\"\"Get a QUrl based on a user input which is URL or search term.\n\n    Args:\n        urlstr: URL to load as a string.\n        cwd: The current working directory, or None.\n        relative: Whether to resolve relative files.\n        do_search: Whether to perform a search on non-URLs.\n        force_search: Whether to force a search even if the content can be\n                      interpreted as a URL or a path.\n\n    Return:\n        A target QUrl to a search page or the original URL.\n    \"\"\"\n    urlstr = urlstr.strip()\n    path = get_path_if_valid(urlstr, cwd=cwd, relative=relative,\n                             check_exists=True)\n\n    if not force_search and path is not None:\n        url = QUrl.fromLocalFile(path)\n    elif force_search or (do_search and not is_url(urlstr)):\n        # probably a search term\n        log.url.debug(\"URL is a fuzzy search term\")\n        try:\n            url = _get_search_url(urlstr)\n        except ValueError:  # invalid search engine\n            url = QUrl.fromUserInput(urlstr)\n    else:  # probably an address\n        log.url.debug(\"URL is a fuzzy address\")\n        url = QUrl.fromUserInput(urlstr)\n    log.url.debug(\"Converting fuzzy term {!r} to URL -> {}\".format(\n        urlstr, url.toDisplayString()))\n    ensure_valid(url)\n    return url\n\n\ndef _has_explicit_scheme(url: QUrl) -> bool:\n    \"\"\"Check if a url has an explicit scheme given.\n\n    Args:\n        url: The URL as QUrl.\n    \"\"\"\n    # Note that generic URI syntax actually would allow a second colon\n    # after the scheme delimiter. Since we don't know of any URIs\n    # using this and want to support e.g. searching for scoped C++\n    # symbols, we treat this as not a URI anyways.\n    return bool(url.isValid() and url.scheme() and\n                (url.host() or url.path()) and\n                not url.path().startswith(':'))\n\n\ndef is_special_url(url: QUrl) -> bool:\n    \"\"\"Return True if url is an about:... or other special URL.\n\n    Args:\n        url: The URL as QUrl.\n    \"\"\"\n    if not url.isValid():\n        return False\n    special_schemes = ('about', 'qute', 'file')\n    return url.scheme() in special_schemes\n\n\ndef is_url(urlstr: str) -> bool:\n    \"\"\"Check if url seems to be a valid URL.\n\n    Args:\n        urlstr: The URL as string.\n\n    Return:\n        True if it is a valid URL, False otherwise.\n    \"\"\"\n    autosearch = config.val.url.auto_search\n\n    log.url.debug(\"Checking if {!r} is a URL (autosearch={}).\".format(\n        urlstr, autosearch))\n\n    urlstr = urlstr.strip()\n    qurl = QUrl(urlstr)\n    qurl_userinput = QUrl.fromUserInput(urlstr)\n\n    if autosearch == 'never':\n        # no autosearch, so everything is a URL unless it has an explicit\n        # search engine.\n        try:\n            engine, _term = _parse_search_term(urlstr)\n        except ValueError:\n            return False\n        else:\n            return engine is None\n\n    if not qurl_userinput.isValid():\n        # This will also catch non-URLs containing spaces.\n        return False\n\n    if _has_explicit_scheme(qurl) and ' ' not in urlstr:\n        # URLs with explicit schemes are always URLs\n        log.url.debug(\"Contains explicit scheme\")\n        url = True\n    elif (autosearch == 'schemeless' and\n          (not _has_explicit_scheme(qurl) or ' ' in urlstr)):\n        # When autosearch=schemeless, URLs must contain schemes to be valid\n        log.url.debug(\"No explicit scheme in given URL, treating as non-URL\")\n        url = False\n    elif qurl_userinput.host() in ['localhost', '127.0.0.1', '::1']:\n        log.url.debug(\"Is localhost.\")\n        url = True\n    elif is_special_url(qurl):\n        # Special URLs are always URLs, even with autosearch=never\n        log.url.debug(\"Is a special URL.\")\n        url = True\n    elif autosearch == 'dns':\n        log.url.debug(\"Checking via DNS check\")\n        # We want to use QUrl.fromUserInput here, as the user might enter\n        # \"foo.de\" and that should be treated as URL here.\n        url = ' ' not in qurl_userinput.userName() and _is_url_dns(urlstr)\n    elif autosearch == 'naive':\n        log.url.debug(\"Checking via naive check\")\n        url = ' ' not in qurl_userinput.userName() and _is_url_naive(urlstr)\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid autosearch value\")\n    log.url.debug(\"url = {}\".format(url))\n    return url\n\n\ndef ensure_valid(url: QUrl) -> None:\n    if not url.isValid():\n        raise InvalidUrlError(url)\n\n\ndef invalid_url_error(url: QUrl, action: str) -> None:\n    \"\"\"Display an error message for a URL.\n\n    Args:\n        action: The action which was interrupted by the error.\n    \"\"\"\n    if url.isValid():\n        raise ValueError(\"Calling invalid_url_error with valid URL {}\".format(\n            url.toDisplayString()))\n    errstring = get_errstring(\n        url, \"Trying to {} with invalid URL\".format(action))\n    message.error(errstring)\n\n\ndef raise_cmdexc_if_invalid(url: QUrl) -> None:\n    \"\"\"Check if the given QUrl is invalid, and if so, raise a CommandError.\"\"\"\n    try:\n        ensure_valid(url)\n    except InvalidUrlError as e:\n        raise cmdutils.CommandError(str(e))\n\n\ndef get_path_if_valid(pathstr: str,\n                      cwd: str = None,\n                      relative: bool = False,\n                      check_exists: bool = False) -> Optional[str]:\n    \"\"\"Check if path is a valid path.\n\n    Args:\n        pathstr: The path as string.\n        cwd: The current working directory, or None.\n        relative: Whether to resolve relative files.\n        check_exists: Whether to check if the file\n                      actually exists of filesystem.\n\n    Return:\n        The path if it is a valid path, None otherwise.\n    \"\"\"\n    pathstr = pathstr.strip()\n    log.url.debug(\"Checking if {!r} is a path\".format(pathstr))\n    expanded = os.path.expanduser(pathstr)\n\n    if os.path.isabs(expanded):\n        path: Optional[str] = expanded\n    elif relative and cwd:\n        path = os.path.join(cwd, expanded)\n    elif relative:\n        try:\n            path = os.path.abspath(expanded)\n        except OSError:\n            path = None\n    else:\n        path = None\n\n    if check_exists:\n        if path is not None:\n            try:\n                if os.path.exists(path):\n                    log.url.debug(\"URL is a local file\")\n                else:\n                    path = None\n            except UnicodeEncodeError:\n                log.url.debug(\n                    \"URL contains characters which are not present in the \"\n                    \"current locale\")\n                path = None\n\n    return path\n\n\ndef filename_from_url(url: QUrl, fallback: str = None) -> Optional[str]:\n    \"\"\"Get a suitable filename from a URL.\n\n    Args:\n        url: The URL to parse, as a QUrl.\n        fallback: Value to use if no name can be determined.\n\n    Return:\n        The suggested filename as a string, or None.\n    \"\"\"\n    if not url.isValid():\n        return fallback\n\n    if url.scheme().lower() == 'data':\n        mimetype, _encoding = mimetypes.guess_type(url.toString())\n        if not mimetype:\n            return fallback\n\n        ext = utils.mimetype_extension(mimetype) or ''\n        return 'download' + ext\n\n    pathname = posixpath.basename(url.path())\n    if pathname:\n        return pathname\n    elif url.host():\n        return url.host() + '.html'\n    else:\n        return fallback\n\n\nHostTupleType = Tuple[str, str, int]\n\n\ndef host_tuple(url: QUrl) -> HostTupleType:\n    \"\"\"Get a (scheme, host, port) tuple from a QUrl.\n\n    This is suitable to identify a connection, e.g. for SSL errors.\n    \"\"\"\n    ensure_valid(url)\n    scheme, host, port = url.scheme(), url.host(), url.port()\n    assert scheme\n    if not host:\n        raise ValueError(\"Got URL {} without host.\".format(\n            url.toDisplayString()))\n    if port == -1:\n        port_mapping = {\n            'http': 80,\n            'https': 443,\n            'ftp': 21,\n        }\n        try:\n            port = port_mapping[scheme]\n        except KeyError:\n            raise ValueError(\"Got URL {} with unknown port.\".format(\n                url.toDisplayString()))\n    return scheme, host, port\n\n\ndef get_errstring(url: QUrl, base: str = \"Invalid URL\") -> str:\n    \"\"\"Get an error string for a URL.\n\n    Args:\n        url: The URL as a QUrl.\n        base: The base error string.\n\n    Return:\n        A new string with url.errorString() is appended if available.\n    \"\"\"\n    url_error = url.errorString()\n    if url_error:\n        return base + \" - {}\".format(url_error)\n    else:\n        return base\n\n\ndef same_domain(url1: QUrl, url2: QUrl) -> bool:\n    \"\"\"Check if url1 and url2 belong to the same website.\n\n    This will use a \"public suffix list\" to determine what a \"top level domain\"\n    is. All further domains are ignored.\n\n    For example example.com and www.example.com are considered the same. but\n    example.co.uk and test.co.uk are not.\n\n    If the URL's schemes or ports are different, they are always treated as not equal.\n\n    Return:\n        True if the domains are the same, False otherwise.\n    \"\"\"\n    ensure_valid(url1)\n    ensure_valid(url2)\n\n    if url1.scheme() != url2.scheme():\n        return False\n    if url1.port() != url2.port():\n        return False\n\n    suffix1 = url1.topLevelDomain()\n    suffix2 = url2.topLevelDomain()\n    if not suffix1:\n        return url1.host() == url2.host()\n\n    if suffix1 != suffix2:\n        return False\n\n    domain1 = url1.host()[:-len(suffix1)].split('.')[-1]\n    domain2 = url2.host()[:-len(suffix2)].split('.')[-1]\n    return domain1 == domain2\n\n\ndef encoded_url(url: QUrl) -> str:\n    \"\"\"Return the fully encoded url as string.\n\n    Args:\n        url: The url to encode as QUrl.\n    \"\"\"\n    return url.toEncoded().data().decode('ascii')\n\n\ndef file_url(path: str) -> str:\n    \"\"\"Return a file:// url (as string) to the given local path.\n\n    Arguments:\n        path: The absolute path to the local file\n    \"\"\"\n    url = QUrl.fromLocalFile(path)\n    return url.toString(QUrl.FullyEncoded)  # type: ignore[arg-type]\n\n\ndef data_url(mimetype: str, data: bytes) -> QUrl:\n    \"\"\"Get a data: QUrl for the given data.\"\"\"\n    b64 = base64.b64encode(data).decode('ascii')\n    url = QUrl('data:{};base64,{}'.format(mimetype, b64))\n    qtutils.ensure_valid(url)\n    return url\n\n\ndef safe_display_string(qurl: QUrl) -> str:\n    \"\"\"Get a IDN-homograph phishing safe form of the given QUrl.\n\n    If we're dealing with a Punycode-encoded URL, this prepends the hostname in\n    its encoded form, to make sure those URLs are distinguishable.\n\n    See https://github.com/qutebrowser/qutebrowser/issues/2547\n    and https://bugreports.qt.io/browse/QTBUG-60365\n    \"\"\"\n    ensure_valid(qurl)\n\n    host = qurl.host(QUrl.FullyEncoded)\n    assert '..' not in host, qurl  # https://bugreports.qt.io/browse/QTBUG-60364\n\n    for part in host.split('.'):\n        url_host = qurl.host(QUrl.FullyDecoded)\n        if part.startswith('xn--') and host != url_host:\n            return '({}) {}'.format(host, qurl.toDisplayString())\n\n    return qurl.toDisplayString()\n\n\nclass InvalidProxyTypeError(Exception):\n\n    \"\"\"Error raised when proxy_from_url gets an unknown proxy type.\"\"\"\n\n    def __init__(self, typ: str) -> None:\n        super().__init__(\"Invalid proxy type {}!\".format(typ))\n\n\ndef proxy_from_url(url: QUrl) -> Union[QNetworkProxy, pac.PACFetcher]:\n    \"\"\"Create a QNetworkProxy from QUrl and a proxy type.\n\n    Args:\n        url: URL of a proxy (possibly with credentials).\n\n    Return:\n        New QNetworkProxy.\n    \"\"\"\n    ensure_valid(url)\n\n    scheme = url.scheme()\n    if scheme in ['pac+http', 'pac+https', 'pac+file']:\n        fetcher = pac.PACFetcher(url)\n        fetcher.fetch()\n        return fetcher\n\n    types = {\n        'http': QNetworkProxy.HttpProxy,\n        'socks': QNetworkProxy.Socks5Proxy,\n        'socks5': QNetworkProxy.Socks5Proxy,\n        'direct': QNetworkProxy.NoProxy,\n    }\n    if scheme not in types:\n        raise InvalidProxyTypeError(scheme)\n\n    proxy = QNetworkProxy(types[scheme], url.host())\n\n    if url.port() != -1:\n        proxy.setPort(url.port())\n    if url.userName():\n        proxy.setUser(url.userName())\n    if url.password():\n        proxy.setPassword(url.password())\n    return proxy\n\n\ndef parse_javascript_url(url: QUrl) -> str:\n    \"\"\"Get JavaScript source from the given URL.\n\n    See https://wiki.whatwg.org/wiki/URL_schemes#javascript:_URLs\n    and https://github.com/whatwg/url/issues/385\n    \"\"\"\n    ensure_valid(url)\n    if url.scheme() != 'javascript':\n        raise Error(\"Expected a javascript:... URL\")\n    if url.authority():\n        raise Error(\"URL contains unexpected components: {}\"\n                    .format(url.authority()))\n\n    urlstr = url.toString(QUrl.FullyEncoded)  # type: ignore[arg-type]\n    urlstr = urllib.parse.unquote(urlstr)\n\n    code = urlstr[len('javascript:'):]\n    if not code:\n        raise Error(\"Resulted in empty JavaScript code\")\n\n    return code\n\n\ndef widened_hostnames(hostname: Optional[str]) -> Iterator[str]:\n    \"\"\"A generator that yields widening string hostnames.\n\n    Ex: a.c.foo -> [a.c.foo, c.foo, foo]\n\n    Args:\n        hostname: The hostname string to widen.\n\n    Yields:\n        The hostname and its parent domains.\n    \"\"\"\n    if not hostname:\n        return\n    while hostname:\n        yield hostname\n        hostname = hostname.partition(\".\")[-1]\n",
                "after": "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n\n# Copyright 2014-2021 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n#\n# This file is part of qutebrowser.\n#\n# qutebrowser is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# qutebrowser is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with qutebrowser.  If not, see <https://www.gnu.org/licenses/>.\n\n\"\"\"Utils regarding URL handling.\"\"\"\n\nimport re\nimport base64\nimport os.path\nimport ipaddress\nimport posixpath\nimport urllib.parse\nimport mimetypes\nfrom typing import Iterator, Optional, Tuple, Union\n\nfrom PyQt5.QtCore import QUrl\nfrom PyQt5.QtNetwork import QHostInfo, QHostAddress, QNetworkProxy\n\nfrom qutebrowser.api import cmdutils\nfrom qutebrowser.config import config\nfrom qutebrowser.utils import log, qtutils, message, utils\nfrom qutebrowser.browser.network import pac\n\n\n# FIXME: we probably could raise some exceptions on invalid URLs\n# https://github.com/qutebrowser/qutebrowser/issues/108\n\n\n# URL schemes supported by QtWebEngine\nWEBENGINE_SCHEMES = [\n    'about',\n    'data',\n    'file',\n    'filesystem',\n    'ftp',\n    'http',\n    'https',\n    'javascript',\n    'ws',\n    'wss',\n]\n\n\nclass Error(Exception):\n\n    \"\"\"Base class for errors in this module.\"\"\"\n\n\nclass InvalidUrlError(Error):\n\n    \"\"\"Error raised if a function got an invalid URL.\"\"\"\n\n    def __init__(self, url: QUrl) -> None:\n        if url.isValid():\n            raise ValueError(\"Got valid URL {}!\".format(url.toDisplayString()))\n        self.url = url\n        self.msg = get_errstring(url)\n        super().__init__(self.msg)\n\n\ndef _parse_search_term(s: str) -> Tuple[Optional[str], Optional[str]]:\n    \"\"\"Get a search engine name and search term from a string.\n\n    Args:\n        s: The string to get a search engine for.\n\n    Return:\n        A (engine, term) tuple, where engine is None for the default engine.\n    \"\"\"\n    s = s.strip()\n    split = s.split(maxsplit=1)\n    if not split:\n        raise ValueError(\"Empty search term!\")\n\n    if len(split) == 2:\n        if split[0] in config.val.url.searchengines:\n            engine: Optional[str] = split[0]\n            term: Optional[str] = split[1]\n        else:\n            engine = None\n            term = s\n    else:\n        if config.val.url.open_base_url and s in config.val.url.searchengines:\n            engine = s\n            term = None\n        else:\n            engine = None\n            term = s\n\n    log.url.debug(\"engine {}, term {!r}\".format(engine, term))\n    return (engine, term)\n\n\ndef _get_search_url(txt: str) -> QUrl:\n    \"\"\"Get a search engine URL for a text.\n\n    Args:\n        txt: Text to search for.\n\n    Return:\n        The search URL as a QUrl.\n    \"\"\"\n    log.url.debug(\"Finding search engine for {!r}\".format(txt))\n    engine, term = _parse_search_term(txt)\n    if not engine:\n        engine = 'DEFAULT'\n    if term:\n        template = config.val.url.searchengines[engine]\n        semiquoted_term = urllib.parse.quote(term)\n        quoted_term = urllib.parse.quote(term, safe='')\n        evaluated = template.format(semiquoted_term,\n                                    unquoted=term,\n                                    quoted=quoted_term,\n                                    semiquoted=semiquoted_term)\n        url = QUrl.fromUserInput(evaluated)\n    else:\n        url = QUrl.fromUserInput(config.val.url.searchengines[engine])\n        url.setPath(None)  # type: ignore[arg-type]\n        url.setFragment(None)  # type: ignore[arg-type]\n        url.setQuery(None)  # type: ignore[call-overload]\n    qtutils.ensure_valid(url)\n    return url\n\n\ndef _is_url_naive(urlstr: str) -> bool:\n    \"\"\"Naive check if given URL is really a URL.\n\n    Args:\n        urlstr: The URL to check for, as string.\n\n    Return:\n        True if the URL really is a URL, False otherwise.\n    \"\"\"\n    url = QUrl.fromUserInput(urlstr)\n    assert url.isValid()\n    host = url.host()\n\n    # Valid IPv4/IPv6 address. Qt converts things like \"23.42\" or \"1337\" or\n    # \"0xDEAD\" to IP addresses, which we don't like, so we check if the host\n    # from Qt is part of the input.\n    if (not utils.raises(ValueError, ipaddress.ip_address, host) and\n            host in urlstr):\n        return True\n\n    tld = r'\\.([^.0-9_-]+|xn--[a-z0-9-]+)$'\n    forbidden = r'[\\u0000-\\u002c\\u002f\\u003a-\\u0060\\u007b-\\u00b6]'\n    return bool(re.search(tld, host) and not re.search(forbidden, host))\n\n\ndef _is_url_dns(urlstr: str) -> bool:\n    \"\"\"Check if a URL is really a URL via DNS.\n\n    Args:\n        url: The URL to check for as a string.\n\n    Return:\n        True if the URL really is a URL, False otherwise.\n    \"\"\"\n    url = QUrl.fromUserInput(urlstr)\n    assert url.isValid()\n\n    if (utils.raises(ValueError, ipaddress.ip_address, urlstr) and\n            not QHostAddress(urlstr).isNull()):\n        log.url.debug(\"Bogus IP URL -> False\")\n        # Qt treats things like \"23.42\" or \"1337\" or \"0xDEAD\" as valid URLs\n        # which we don't want to.\n        return False\n\n    host = url.host()\n    if not host:\n        log.url.debug(\"URL has no host -> False\")\n        return False\n    log.url.debug(\"Doing DNS request for {}\".format(host))\n    info = QHostInfo.fromName(host)\n    return not info.error()\n\n\ndef fuzzy_url(urlstr: str,\n              cwd: str = None,\n              relative: bool = False,\n              do_search: bool = True,\n              force_search: bool = False) -> QUrl:\n    \"\"\"Get a QUrl based on a user input which is URL or search term.\n\n    Args:\n        urlstr: URL to load as a string.\n        cwd: The current working directory, or None.\n        relative: Whether to resolve relative files.\n        do_search: Whether to perform a search on non-URLs.\n        force_search: Whether to force a search even if the content can be\n                      interpreted as a URL or a path.\n\n    Return:\n        A target QUrl to a search page or the original URL.\n    \"\"\"\n    urlstr = urlstr.strip()\n    path = get_path_if_valid(urlstr, cwd=cwd, relative=relative,\n                             check_exists=True)\n\n    if not force_search and path is not None:\n        url = QUrl.fromLocalFile(path)\n    elif force_search or (do_search and not is_url(urlstr)):\n        # probably a search term\n        log.url.debug(\"URL is a fuzzy search term\")\n        try:\n            url = _get_search_url(urlstr)\n        except ValueError:  # invalid search engine\n            url = QUrl.fromUserInput(urlstr)\n    else:  # probably an address\n        log.url.debug(\"URL is a fuzzy address\")\n        url = QUrl.fromUserInput(urlstr)\n    log.url.debug(\"Converting fuzzy term {!r} to URL -> {}\".format(\n        urlstr, url.toDisplayString()))\n    ensure_valid(url)\n    return url\n\n\ndef _has_explicit_scheme(url: QUrl) -> bool:\n    \"\"\"Check if a url has an explicit scheme given.\n\n    Args:\n        url: The URL as QUrl.\n    \"\"\"\n    # Note that generic URI syntax actually would allow a second colon\n    # after the scheme delimiter. Since we don't know of any URIs\n    # using this and want to support e.g. searching for scoped C++\n    # symbols, we treat this as not a URI anyways.\n    return bool(url.isValid() and url.scheme() and\n                (url.host() or url.path()) and\n                not url.path().startswith(':'))\n\n\ndef is_special_url(url: QUrl) -> bool:\n    \"\"\"Return True if url is an about:... or other special URL.\n\n    Args:\n        url: The URL as QUrl.\n    \"\"\"\n    if not url.isValid():\n        return False\n    special_schemes = ('about', 'qute', 'file')\n    return url.scheme() in special_schemes\n\n\ndef is_url(urlstr: str) -> bool:\n    \"\"\"Check if url seems to be a valid URL.\n\n    Args:\n        urlstr: The URL as string.\n\n    Return:\n        True if it is a valid URL, False otherwise.\n    \"\"\"\n    autosearch = config.val.url.auto_search\n\n    log.url.debug(\"Checking if {!r} is a URL (autosearch={}).\".format(\n        urlstr, autosearch))\n\n    urlstr = urlstr.strip()\n    qurl = QUrl(urlstr)\n    qurl_userinput = QUrl.fromUserInput(urlstr)\n\n    if autosearch == 'never':\n        # no autosearch, so everything is a URL unless it has an explicit\n        # search engine.\n        try:\n            engine, _term = _parse_search_term(urlstr)\n        except ValueError:\n            return False\n        else:\n            return engine is None\n\n    if not qurl_userinput.isValid():\n        # This will also catch non-URLs containing spaces.\n        return False\n\n    if _has_explicit_scheme(qurl) and ' ' not in urlstr:\n        # URLs with explicit schemes are always URLs\n        log.url.debug(\"Contains explicit scheme\")\n        url = True\n    elif (autosearch == 'schemeless' and\n          (not _has_explicit_scheme(qurl) or ' ' in urlstr)):\n        # When autosearch=schemeless, URLs must contain schemes to be valid\n        log.url.debug(\"No explicit scheme in given URL, treating as non-URL\")\n        url = False\n    elif qurl_userinput.host() in ['localhost', '127.0.0.1', '::1']:\n        log.url.debug(\"Is localhost.\")\n        url = True\n    elif is_special_url(qurl):\n        # Special URLs are always URLs, even with autosearch=never\n        log.url.debug(\"Is a special URL.\")\n        url = True\n    elif autosearch == 'dns':\n        log.url.debug(\"Checking via DNS check\")\n        # We want to use QUrl.fromUserInput here, as the user might enter\n        # \"foo.de\" and that should be treated as URL here.\n        url = ' ' not in qurl_userinput.userName() and _is_url_dns(urlstr)\n    elif autosearch == 'naive':\n        log.url.debug(\"Checking via naive check\")\n        url = ' ' not in qurl_userinput.userName() and _is_url_naive(urlstr)\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid autosearch value\")\n    log.url.debug(\"url = {}\".format(url))\n    return url\n\n\ndef ensure_valid(url: QUrl) -> None:\n    if not url.isValid():\n        raise InvalidUrlError(url)\n\n\ndef invalid_url_error(url: QUrl, action: str) -> None:\n    \"\"\"Display an error message for a URL.\n\n    Args:\n        action: The action which was interrupted by the error.\n    \"\"\"\n    if url.isValid():\n        raise ValueError(\"Calling invalid_url_error with valid URL {}\".format(\n            url.toDisplayString()))\n    errstring = get_errstring(\n        url, \"Trying to {} with invalid URL\".format(action))\n    message.error(errstring)\n\n\ndef raise_cmdexc_if_invalid(url: QUrl) -> None:\n    \"\"\"Check if the given QUrl is invalid, and if so, raise a CommandError.\"\"\"\n    try:\n        ensure_valid(url)\n    except InvalidUrlError as e:\n        raise cmdutils.CommandError(str(e))\n\n\ndef get_path_if_valid(pathstr: str,\n                      cwd: str = None,\n                      relative: bool = False,\n                      check_exists: bool = False) -> Optional[str]:\n    \"\"\"Check if path is a valid path.\n\n    Args:\n        pathstr: The path as string.\n        cwd: The current working directory, or None.\n        relative: Whether to resolve relative files.\n        check_exists: Whether to check if the file\n                      actually exists of filesystem.\n\n    Return:\n        The path if it is a valid path, None otherwise.\n    \"\"\"\n    pathstr = pathstr.strip()\n    log.url.debug(\"Checking if {!r} is a path\".format(pathstr))\n    expanded = os.path.expanduser(pathstr)\n\n    if os.path.isabs(expanded):\n        path: Optional[str] = expanded\n    elif relative and cwd:\n        path = os.path.join(cwd, expanded)\n    elif relative:\n        try:\n            path = os.path.abspath(expanded)\n        except OSError:\n            path = None\n    else:\n        path = None\n\n    if check_exists:\n        if path is not None:\n            try:\n                if os.path.exists(path):\n                    log.url.debug(\"URL is a local file\")\n                else:\n                    path = None\n            except UnicodeEncodeError:\n                log.url.debug(\n                    \"URL contains characters which are not present in the \"\n                    \"current locale\")\n                path = None\n\n    return path\n\n\ndef filename_from_url(url: QUrl, fallback: str = None) -> Optional[str]:\n    \"\"\"Get a suitable filename from a URL.\n\n    Args:\n        url: The URL to parse, as a QUrl.\n        fallback: Value to use if no name can be determined.\n\n    Return:\n        The suggested filename as a string, or None.\n    \"\"\"\n    if not url.isValid():\n        return fallback\n\n    if url.scheme().lower() == 'data':\n        mimetype, _encoding = mimetypes.guess_type(url.toString())\n        if not mimetype:\n            return fallback\n\n        ext = utils.mimetype_extension(mimetype) or ''\n        return 'download' + ext\n\n    pathname = posixpath.basename(url.path())\n    if pathname:\n        return pathname\n    elif url.host():\n        return url.host() + '.html'\n    else:\n        return fallback\n\n\nHostTupleType = Tuple[str, str, int]\n\n\ndef host_tuple(url: QUrl) -> HostTupleType:\n    \"\"\"Get a (scheme, host, port) tuple from a QUrl.\n\n    This is suitable to identify a connection, e.g. for SSL errors.\n    \"\"\"\n    ensure_valid(url)\n    scheme, host, port = url.scheme(), url.host(), url.port()\n    assert scheme\n    if not host:\n        raise ValueError(\"Got URL {} without host.\".format(\n            url.toDisplayString()))\n    if port == -1:\n        port_mapping = {\n            'http': 80,\n            'https': 443,\n            'ftp': 21,\n        }\n        try:\n            port = port_mapping[scheme]\n        except KeyError:\n            raise ValueError(\"Got URL {} with unknown port.\".format(\n                url.toDisplayString()))\n    return scheme, host, port\n\n\ndef get_errstring(url: QUrl, base: str = \"Invalid URL\") -> str:\n    \"\"\"Get an error string for a URL.\n\n    Args:\n        url: The URL as a QUrl.\n        base: The base error string.\n\n    Return:\n        A new string with url.errorString() is appended if available.\n    \"\"\"\n    url_error = url.errorString()\n    if url_error:\n        return base + \" - {}\".format(url_error)\n    else:\n        return base\n\n\ndef same_domain(url1: QUrl, url2: QUrl) -> bool:\n    \"\"\"Check if url1 and url2 belong to the same website.\n\n    This will use a \"public suffix list\" to determine what a \"top level domain\"\n    is. All further domains are ignored.\n\n    For example example.com and www.example.com are considered the same. but\n    example.co.uk and test.co.uk are not.\n\n    If the URL's schemes or ports are different, they are always treated as not equal.\n\n    Return:\n        True if the domains are the same, False otherwise.\n    \"\"\"\n    ensure_valid(url1)\n    ensure_valid(url2)\n\n    if url1.scheme() != url2.scheme():\n        return False\n    if url1.port() != url2.port():\n        return False\n\n    suffix1 = url1.topLevelDomain()\n    suffix2 = url2.topLevelDomain()\n    if not suffix1:\n        return url1.host() == url2.host()\n\n    if suffix1 != suffix2:\n        return False\n\n    domain1 = url1.host()[:-len(suffix1)].split('.')[-1]\n    domain2 = url2.host()[:-len(suffix2)].split('.')[-1]\n    return domain1 == domain2\n\n\ndef encoded_url(url: QUrl) -> str:\n    \"\"\"Return the fully encoded url as string.\n\n    Args:\n        url: The url to encode as QUrl.\n    \"\"\"\n    return url.toEncoded().data().decode('ascii')\n\n\ndef file_url(path: str) -> str:\n    \"\"\"Return a file:// url (as string) to the given local path.\n\n    Arguments:\n        path: The absolute path to the local file\n    \"\"\"\n    url = QUrl.fromLocalFile(path)\n    return url.toString(QUrl.FullyEncoded)  # type: ignore[arg-type]\n\n\ndef data_url(mimetype: str, data: bytes) -> QUrl:\n    \"\"\"Get a data: QUrl for the given data.\"\"\"\n    b64 = base64.b64encode(data).decode('ascii')\n    url = QUrl('data:{};base64,{}'.format(mimetype, b64))\n    qtutils.ensure_valid(url)\n    return url\n\n\ndef safe_display_string(qurl: QUrl) -> str:\n    \"\"\"Get a IDN-homograph phishing safe form of the given QUrl.\n\n    If we're dealing with a Punycode-encoded URL, this prepends the hostname in\n    its encoded form, to make sure those URLs are distinguishable.\n\n    See https://github.com/qutebrowser/qutebrowser/issues/2547\n    and https://bugreports.qt.io/browse/QTBUG-60365\n    \"\"\"\n    ensure_valid(qurl)\n\n    host = qurl.host(QUrl.FullyEncoded)\n    assert '..' not in host, qurl  # https://bugreports.qt.io/browse/QTBUG-60364\n\n    for part in host.split('.'):\n        url_host = qurl.host(QUrl.FullyDecoded)\n        if part.startswith('xn--') and host != url_host:\n            return '({}) {}'.format(host, qurl.toDisplayString())\n\n    return qurl.toDisplayString()\n\n\nclass InvalidProxyTypeError(Exception):\n\n    \"\"\"Error raised when proxy_from_url gets an unknown proxy type.\"\"\"\n\n    def __init__(self, typ: str) -> None:\n        super().__init__(\"Invalid proxy type {}!\".format(typ))\n\n\ndef proxy_from_url(url: QUrl) -> Union[QNetworkProxy, pac.PACFetcher]:\n    \"\"\"Create a QNetworkProxy from QUrl and a proxy type.\n\n    Args:\n        url: URL of a proxy (possibly with credentials).\n\n    Return:\n        New QNetworkProxy.\n    \"\"\"\n    ensure_valid(url)\n\n    scheme = url.scheme()\n    if scheme in ['pac+http', 'pac+https', 'pac+file']:\n        fetcher = pac.PACFetcher(url)\n        fetcher.fetch()\n        return fetcher\n\n    types = {\n        'http': QNetworkProxy.HttpProxy,\n        'socks': QNetworkProxy.Socks5Proxy,\n        'socks5': QNetworkProxy.Socks5Proxy,\n        'direct': QNetworkProxy.NoProxy,\n    }\n    if scheme not in types:\n        raise InvalidProxyTypeError(scheme)\n\n    proxy = QNetworkProxy(types[scheme], url.host())\n\n    if url.port() != -1:\n        proxy.setPort(url.port())\n    if url.userName():\n        proxy.setUser(url.userName())\n    if url.password():\n        proxy.setPassword(url.password())\n    return proxy\n\n\ndef parse_javascript_url(url: QUrl) -> str:\n    \"\"\"Get JavaScript source from the given URL.\n\n    See https://wiki.whatwg.org/wiki/URL_schemes#javascript:_URLs\n    and https://github.com/whatwg/url/issues/385\n    \"\"\"\n    ensure_valid(url)\n    if url.scheme() != 'javascript':\n        raise Error(\"Expected a javascript:... URL\")\n    if url.authority():\n        raise Error(\"URL contains unexpected components: {}\"\n                    .format(url.authority()))\n\n    urlstr = url.toString(QUrl.FullyEncoded)  # type: ignore[arg-type]\n    urlstr = urllib.parse.unquote(urlstr)\n\n    code = urlstr[len('javascript:'):]\n    if not code:\n        raise Error(\"Resulted in empty JavaScript code\")\n\n    return code\n\n\ndef widened_hostnames(hostname: Optional[str]) -> Iterator[str]:\n    \"\"\"A generator that yields widening string hostnames.\n\n    Ex: a.c.foo -> [a.c.foo, c.foo, foo]\n\n    Args:\n        hostname: The hostname string to widen.\n\n    Yields:\n        The hostname and its parent domains.\n    \"\"\"\n    if not hostname:\n        return\n    while hostname:\n        yield hostname\n        hostname = hostname.partition(\".\")[-1]\n",
                "additions": 1,
                "deletions": 1
              },
              "truncated": false
            },
            "time": {
              "start": 1769437546371,
              "end": 1769437549541
            }
          }
        },
        {
          "id": "prt_bfab253f1001qn473ReuNi8l9x",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab23c13001ypLw7zFrKGX3wX",
          "type": "step-finish",
          "reason": "tool-calls",
          "snapshot": "",
          "cost": 0,
          "tokens": {
            "input": 0,
            "output": 174,
            "reasoning": 0,
            "cache": {
              "read": 62603,
              "write": 336
            }
          }
        }
      ]
    },
    {
      "info": {
        "id": "msg_bfab25475001ZklAcgbniLBmRf",
        "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
        "role": "assistant",
        "time": {
          "created": 1769437549685,
          "completed": 1769437553558
        },
        "parentID": "msg_bfaaf7dfd001wtLwIM1eGC5XRs",
        "modelID": "claude-opus-4-5",
        "providerID": "anthropic",
        "mode": "opus-codex",
        "agent": "opus-codex",
        "path": {
          "cwd": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896",
          "root": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896"
        },
        "cost": 0,
        "tokens": {
          "input": 0,
          "output": 185,
          "reasoning": 0,
          "cache": {
            "read": 62939,
            "write": 386
          }
        },
        "finish": "tool-calls"
      },
      "parts": [
        {
          "id": "prt_bfab25c19001lOlJymCMgvusmL",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab25475001ZklAcgbniLBmRf",
          "type": "step-start",
          "snapshot": ""
        },
        {
          "id": "prt_bfab25c2d001490e9ndORjXUT7",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab25475001ZklAcgbniLBmRf",
          "type": "text",
          "text": "Now I need to update the `_is_blocked` method in hostblock.py to check for subdomains. Let me do that:",
          "time": {
            "start": 1769437551954,
            "end": 1769437551954
          }
        },
        {
          "id": "prt_bfab25d5400166jtYWKG36fw7S",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab25475001ZklAcgbniLBmRf",
          "type": "tool",
          "callID": "toolu_01NugoPmaAUHw4HAMc4QVg7k",
          "tool": "read",
          "state": {
            "status": "completed",
            "input": {
              "filePath": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/hostblock.py",
              "offset": 112,
              "limit": 25
            },
            "output": "<file>\n00113| \n00114|     def _is_blocked(self, request_url: QUrl, first_party_url: QUrl = None) -> bool:\n00115|         \"\"\"Check whether the given request is blocked.\"\"\"\n00116|         if not self.enabled:\n00117|             return False\n00118| \n00119|         if first_party_url is not None and not first_party_url.isValid():\n00120|             first_party_url = None\n00121| \n00122|         qtutils.ensure_valid(request_url)\n00123| \n00124|         if not config.get(\"content.blocking.enabled\", url=first_party_url):\n00125|             return False\n00126| \n00127|         host = request_url.host()\n00128|         return (\n00129|             host in self._blocked_hosts or host in self._config_blocked_hosts\n00130|         ) and not blockutils.is_whitelisted_url(request_url)\n00131| \n00132|     def filter_request(self, info: interceptor.Request) -> None:\n00133|         \"\"\"Block the given request if necessary.\"\"\"\n00134|         if self._is_blocked(\n00135|             request_url=info.request_url, first_party_url=info.first_party_url\n00136|         ):\n00137|             logger.debug(\n\n(File has more lines. Use 'offset' parameter to read beyond line 137)\n</file>",
            "title": "qutebrowser/components/hostblock.py",
            "metadata": {
              "preview": "\n    def _is_blocked(self, request_url: QUrl, first_party_url: QUrl = None) -> bool:\n        \"\"\"Check whether the given request is blocked.\"\"\"\n        if not self.enabled:\n            return False\n\n        if first_party_url is not None and not first_party_url.isValid():\n            first_party_url = None\n\n        qtutils.ensure_valid(request_url)\n\n        if not config.get(\"content.blocking.enabled\", url=first_party_url):\n            return False\n\n        host = request_url.host()\n        return (\n            host in self._blocked_hosts or host in self._config_blocked_hosts\n        ) and not blockutils.is_whitelisted_url(request_url)\n\n    def filter_request(self, info: interceptor.Request) -> None:",
              "truncated": true
            },
            "time": {
              "start": 1769437552945,
              "end": 1769437552965
            }
          }
        },
        {
          "id": "prt_bfab26148001DEfhqvGXjf85Ui",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab25475001ZklAcgbniLBmRf",
          "type": "step-finish",
          "reason": "tool-calls",
          "snapshot": "722131d543e57928f568939fadba0ee6b90dfca6",
          "cost": 0,
          "tokens": {
            "input": 0,
            "output": 185,
            "reasoning": 0,
            "cache": {
              "read": 62939,
              "write": 386
            }
          }
        }
      ]
    },
    {
      "info": {
        "id": "msg_bfab263ef001qRhcNLVW2fOKFg",
        "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
        "role": "assistant",
        "time": {
          "created": 1769437553647,
          "completed": 1769437563639
        },
        "parentID": "msg_bfaaf7dfd001wtLwIM1eGC5XRs",
        "modelID": "claude-opus-4-5",
        "providerID": "anthropic",
        "mode": "opus-codex",
        "agent": "opus-codex",
        "path": {
          "cwd": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896",
          "root": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896"
        },
        "cost": 0,
        "tokens": {
          "input": 0,
          "output": 597,
          "reasoning": 0,
          "cache": {
            "read": 63325,
            "write": 558
          }
        },
        "finish": "tool-calls"
      },
      "parts": [
        {
          "id": "prt_bfab26c0c001E3CyyB5P4KiqBj",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab263ef001qRhcNLVW2fOKFg",
          "type": "step-start",
          "snapshot": ""
        },
        {
          "id": "prt_bfab26c0e001hVeeWuwUa6H97B",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab263ef001qRhcNLVW2fOKFg",
          "type": "text",
          "text": "Now I need to modify the `_is_blocked` method to check subdomains. The key insight is that when we check if `subdomain.example.com` is blocked, we need to also check if `example.com` (or any parent domain) is in the blocked list.\n\nLet me update the method:",
          "time": {
            "start": 1769437556767,
            "end": 1769437556767
          }
        },
        {
          "id": "prt_bfab27023001ioodGNE99IkOlH",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab263ef001qRhcNLVW2fOKFg",
          "type": "tool",
          "callID": "toolu_013nu4Vc6scHrm2TXL7jT2c7",
          "tool": "edit",
          "state": {
            "status": "completed",
            "input": {
              "filePath": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/hostblock.py",
              "oldString": "    def _is_blocked(self, request_url: QUrl, first_party_url: QUrl = None) -> bool:\n        \"\"\"Check whether the given request is blocked.\"\"\"\n        if not self.enabled:\n            return False\n\n        if first_party_url is not None and not first_party_url.isValid():\n            first_party_url = None\n\n        qtutils.ensure_valid(request_url)\n\n        if not config.get(\"content.blocking.enabled\", url=first_party_url):\n            return False\n\n        host = request_url.host()\n        return (\n            host in self._blocked_hosts or host in self._config_blocked_hosts\n        ) and not blockutils.is_whitelisted_url(request_url)",
              "newString": "    def _is_blocked(self, request_url: QUrl, first_party_url: QUrl = None) -> bool:\n        \"\"\"Check whether the given request is blocked.\"\"\"\n        if not self.enabled:\n            return False\n\n        if first_party_url is not None and not first_party_url.isValid():\n            first_party_url = None\n\n        qtutils.ensure_valid(request_url)\n\n        if not config.get(\"content.blocking.enabled\", url=first_party_url):\n            return False\n\n        host = request_url.host()\n        if blockutils.is_whitelisted_url(request_url):\n            return False\n\n        for hostname in _widened_hostnames(host):\n            if hostname in self._blocked_hosts or hostname in self._config_blocked_hosts:\n                return True\n        return False"
            },
            "output": "Edit applied successfully.\n\nLSP errors detected in this file, please fix:\n<diagnostics file=\"/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/hostblock.py\">\nERROR [114:70] Expression of type \"None\" cannot be assigned to parameter of type \"QUrl\"\n\"None\" is not assignable to \"QUrl\"\nERROR [120:31] Type \"None\" is not assignable to declared type \"QUrl\"\n\"None\" is not assignable to \"QUrl\"\nERROR [135:59] Argument of type \"Unknown | None\" cannot be assigned to parameter \"first_party_url\" of type \"QUrl\" in function \"_is_blocked\"\nType \"Unknown | None\" is not assignable to type \"QUrl\"\n\"None\" is not assignable to \"QUrl\"\n</diagnostics>",
            "title": "qutebrowser/components/hostblock.py",
            "metadata": {
              "diagnostics": {
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/components/test_hostblock.py": [],
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/utils/test_urlutils.py": [
                  {
                    "range": {
                      "start": {
                        "line": 81,
                        "character": 40
                      },
                      "end": {
                        "line": 81,
                        "character": 55
                      }
                    },
                    "message": "Argument of type \"() -> bool\" cannot be assigned to parameter \"error\" of type \"bool\" in function \"__init__\"\n\"MethodType\" is not assignable to \"bool\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 794,
                        "character": 29
                      },
                      "end": {
                        "line": 794,
                        "character": 46
                      }
                    },
                    "message": "\"widened_hostnames\" is not a known attribute of module \"qutebrowser.utils.urlutils\"",
                    "severity": 1,
                    "code": "reportAttributeAccessIssue",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportAttributeAccessIssue"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 802,
                        "character": 40
                      },
                      "end": {
                        "line": 802,
                        "character": 57
                      }
                    },
                    "message": "\"widened_hostnames\" is not a known attribute of module \"qutebrowser.utils.urlutils\"",
                    "severity": 1,
                    "code": "reportAttributeAccessIssue",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportAttributeAccessIssue"
                    }
                  }
                ],
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/hostblock.py": [
                  {
                    "range": {
                      "start": {
                        "line": 113,
                        "character": 69
                      },
                      "end": {
                        "line": 113,
                        "character": 73
                      }
                    },
                    "message": "Expression of type \"None\" cannot be assigned to parameter of type \"QUrl\"\n\"None\" is not assignable to \"QUrl\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 119,
                        "character": 30
                      },
                      "end": {
                        "line": 119,
                        "character": 34
                      }
                    },
                    "message": "Type \"None\" is not assignable to declared type \"QUrl\"\n\"None\" is not assignable to \"QUrl\"",
                    "severity": 1,
                    "code": "reportAssignmentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportAssignmentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 134,
                        "character": 58
                      },
                      "end": {
                        "line": 134,
                        "character": 78
                      }
                    },
                    "message": "Argument of type \"Unknown | None\" cannot be assigned to parameter \"first_party_url\" of type \"QUrl\" in function \"_is_blocked\"\nType \"Unknown | None\" is not assignable to type \"QUrl\"\n\"None\" is not assignable to \"QUrl\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  }
                ],
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/utils/urlutils.py": [
                  {
                    "range": {
                      "start": {
                        "line": 193,
                        "character": 25
                      },
                      "end": {
                        "line": 193,
                        "character": 29
                      }
                    },
                    "message": "Expression of type \"None\" cannot be assigned to parameter of type \"str\"\n\"None\" is not assignable to \"str\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 349,
                        "character": 33
                      },
                      "end": {
                        "line": 349,
                        "character": 37
                      }
                    },
                    "message": "Expression of type \"None\" cannot be assigned to parameter of type \"str\"\n\"None\" is not assignable to \"str\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 396,
                        "character": 49
                      },
                      "end": {
                        "line": 396,
                        "character": 53
                      }
                    },
                    "message": "Expression of type \"None\" cannot be assigned to parameter of type \"str\"\n\"None\" is not assignable to \"str\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  }
                ],
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/config/test_configutils.py": [
                  {
                    "range": {
                      "start": {
                        "line": 33,
                        "character": 63
                      },
                      "end": {
                        "line": 33,
                        "character": 67
                      }
                    },
                    "message": "Argument of type \"None\" cannot be assigned to parameter \"backends\" of type \"Iterable[Backend]\" in function \"__init__\"\n\"None\" is incompatible with protocol \"Iterable[Backend]\"\n\"__iter__\" is not present",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 34,
                        "character": 60
                      },
                      "end": {
                        "line": 34,
                        "character": 64
                      }
                    },
                    "message": "Argument of type \"None\" cannot be assigned to parameter \"description\" of type \"str\" in function \"__init__\"\n\"None\" is not assignable to \"str\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  }
                ],
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/config/configutils.py": []
              },
              "diff": "Index: /Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/hostblock.py\n===================================================================\n--- /Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/hostblock.py\n+++ /Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/hostblock.py\n@@ -124,12 +124,16 @@\n     if not config.get(\"content.blocking.enabled\", url=first_party_url):\n         return False\n \n     host = request_url.host()\n-    return (\n-        host in self._blocked_hosts or host in self._config_blocked_hosts\n-    ) and not blockutils.is_whitelisted_url(request_url)\n+    if blockutils.is_whitelisted_url(request_url):\n+        return False\n \n+    for hostname in _widened_hostnames(host):\n+        if hostname in self._blocked_hosts or hostname in self._config_blocked_hosts:\n+            return True\n+    return False\n+\n def filter_request(self, info: interceptor.Request) -> None:\n     \"\"\"Block the given request if necessary.\"\"\"\n     if self._is_blocked(\n         request_url=info.request_url, first_party_url=info.first_party_url\n",
              "filediff": {
                "file": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/hostblock.py",
                "before": "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n\n# Copyright 2014-2021 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n#\n# This file is part of qutebrowser.\n#\n# qutebrowser is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# qutebrowser is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with qutebrowser.  If not, see <https://www.gnu.org/licenses/>.\n\n\"\"\"Functions related to host blocking.\"\"\"\n\nimport os.path\nimport posixpath\nimport zipfile\nimport logging\nimport pathlib\nfrom typing import cast, IO, Set\n\nfrom PyQt5.QtCore import QUrl\n\nfrom qutebrowser.api import (\n    hook,\n    config,\n    message,\n    interceptor,\n    apitypes,\n    qtutils,\n)\nfrom qutebrowser.components.utils import blockutils\nfrom qutebrowser.utils import version  # FIXME: Move needed parts into api namespace?\n\n\nlogger = logging.getLogger(\"network\")\nhost_blocker = cast(\"HostBlocker\", None)\n\n\ndef _guess_zip_filename(zf: zipfile.ZipFile) -> str:\n    \"\"\"Guess which file to use inside a zip file.\"\"\"\n    files = zf.namelist()\n    if len(files) == 1:\n        return files[0]\n    else:\n        for e in files:\n            if posixpath.splitext(e)[0].lower() == \"hosts\":\n                return e\n    raise FileNotFoundError(\"No hosts file found in zip\")\n\n\ndef get_fileobj(byte_io: IO[bytes]) -> IO[bytes]:\n    \"\"\"Get a usable file object to read the hosts file from.\"\"\"\n    byte_io.seek(0)  # rewind downloaded file\n    if zipfile.is_zipfile(byte_io):\n        byte_io.seek(0)  # rewind what zipfile.is_zipfile did\n        zf = zipfile.ZipFile(byte_io)\n        filename = _guess_zip_filename(zf)\n        byte_io = zf.open(filename, mode=\"r\")\n    else:\n        byte_io.seek(0)  # rewind what zipfile.is_zipfile did\n    return byte_io\n\n\ndef _should_be_used() -> bool:\n    \"\"\"Whether the hostblocker should be used or not.\"\"\"\n    method = config.val.content.blocking.method\n\n    adblock_info = version.MODULE_INFO[\"adblock\"]\n    adblock_usable = adblock_info.is_usable()\n\n    logger.debug(f\"Configured adblock method {method}, adblock library usable: \"\n                 f\"{adblock_usable}\")\n    return method in (\"both\", \"hosts\") or (method == \"auto\" and not adblock_usable)\n\n\nclass HostBlocker:\n\n    \"\"\"Manage blocked hosts based from /etc/hosts-like files.\n\n    Attributes:\n        enabled: Given the current blocking method, should the host blocker be enabled?\n        _blocked_hosts: A set of blocked hosts.\n        _config_blocked_hosts: A set of blocked hosts from ~/.config.\n        _local_hosts_file: The path to the blocked-hosts file.\n        _config_hosts_file: The path to a blocked-hosts in ~/.config\n        _has_basedir: Whether a custom --basedir is set.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        data_dir: pathlib.Path,\n        config_dir: pathlib.Path,\n        has_basedir: bool = False\n    ) -> None:\n        self.enabled = _should_be_used()\n        self._has_basedir = has_basedir\n        self._blocked_hosts: Set[str] = set()\n        self._config_blocked_hosts: Set[str] = set()\n\n        self._local_hosts_file = str(data_dir / \"blocked-hosts\")\n        self.update_files()\n\n        self._config_hosts_file = str(config_dir / \"blocked-hosts\")\n\n    def _is_blocked(self, request_url: QUrl, first_party_url: QUrl = None) -> bool:\n        \"\"\"Check whether the given request is blocked.\"\"\"\n        if not self.enabled:\n            return False\n\n        if first_party_url is not None and not first_party_url.isValid():\n            first_party_url = None\n\n        qtutils.ensure_valid(request_url)\n\n        if not config.get(\"content.blocking.enabled\", url=first_party_url):\n            return False\n\n        host = request_url.host()\n        return (\n            host in self._blocked_hosts or host in self._config_blocked_hosts\n        ) and not blockutils.is_whitelisted_url(request_url)\n\n    def filter_request(self, info: interceptor.Request) -> None:\n        \"\"\"Block the given request if necessary.\"\"\"\n        if self._is_blocked(\n            request_url=info.request_url, first_party_url=info.first_party_url\n        ):\n            logger.debug(\n                \"Request to {} blocked by host blocker.\".format(info.request_url.host())\n            )\n            info.block()\n\n    def _read_hosts_line(self, raw_line: bytes) -> Set[str]:\n        \"\"\"Read hosts from the given line.\n\n        Args:\n            line: The bytes object to read.\n\n        Returns:\n            A set containing valid hosts found\n            in the line.\n        \"\"\"\n        if raw_line.startswith(b\"#\"):\n            # Ignoring comments early so we don't have to care about\n            # encoding errors in them\n            return set()\n\n        line = raw_line.decode(\"utf-8\")\n\n        # Remove comments\n        hash_idx = line.find(\"#\")\n        line = line if hash_idx == -1 else line[:hash_idx]\n\n        parts = line.strip().split()\n        if len(parts) == 1:\n            # \"one host per line\" format\n            hosts = parts\n        else:\n            # /etc/hosts format\n            hosts = parts[1:]\n\n        filtered_hosts = set()\n        for host in hosts:\n            if \".\" in host and not host.endswith(\".localdomain\") and host != \"0.0.0.0\":\n                filtered_hosts.update([host])\n\n        return filtered_hosts\n\n    def _read_hosts_file(self, filename: str, target: Set[str]) -> bool:\n        \"\"\"Read hosts from the given filename.\n\n        Args:\n            filename: The file to read.\n            target: The set to store the hosts in.\n\n        Return:\n            True if a read was attempted, False otherwise\n        \"\"\"\n        if not os.path.exists(filename):\n            return False\n\n        try:\n            with open(filename, \"rb\") as f:\n                for line in f:\n                    target |= self._read_hosts_line(line)\n\n        except (OSError, UnicodeDecodeError):\n            logger.exception(\"Failed to read host blocklist!\")\n\n        return True\n\n    def read_hosts(self) -> None:\n        \"\"\"Read hosts from the existing blocked-hosts file.\"\"\"\n        self._blocked_hosts = set()\n\n        self._read_hosts_file(self._config_hosts_file, self._config_blocked_hosts)\n\n        found = self._read_hosts_file(self._local_hosts_file, self._blocked_hosts)\n\n        if not found:\n            if (\n                config.val.content.blocking.hosts.lists\n                and not self._has_basedir\n                and config.val.content.blocking.enabled\n                and self.enabled\n            ):\n                message.info(\"Run :adblock-update to get adblock lists.\")\n\n    def adblock_update(self) -> blockutils.BlocklistDownloads:\n        \"\"\"Update the adblock block lists.\"\"\"\n        self._read_hosts_file(self._config_hosts_file, self._config_blocked_hosts)\n        self._blocked_hosts = set()\n\n        blocklists = config.val.content.blocking.hosts.lists\n        dl = blockutils.BlocklistDownloads(blocklists)\n        dl.single_download_finished.connect(self._merge_file)\n        dl.all_downloads_finished.connect(self._on_lists_downloaded)\n        dl.initiate()\n        return dl\n\n    def _merge_file(self, byte_io: IO[bytes]) -> None:\n        \"\"\"Read and merge host files.\n\n        Args:\n            byte_io: The BytesIO object of the completed download.\n        \"\"\"\n        error_count = 0\n        line_count = 0\n        try:\n            f = get_fileobj(byte_io)\n        except (OSError, zipfile.BadZipFile, zipfile.LargeZipFile, LookupError) as e:\n            message.error(\n                \"hostblock: Error while reading {}: {} - {}\".format(\n                    byte_io.name, e.__class__.__name__, e\n                )\n            )\n            return\n\n        for line in f:\n            line_count += 1\n            try:\n                self._blocked_hosts |= self._read_hosts_line(line)\n            except UnicodeDecodeError:\n                logger.error(\"Failed to decode: {!r}\".format(line))\n                error_count += 1\n\n        logger.debug(\"{}: read {} lines\".format(byte_io.name, line_count))\n        if error_count > 0:\n            message.error(\n                \"hostblock: {} read errors for {}\".format(error_count, byte_io.name)\n            )\n\n    def _on_lists_downloaded(self, done_count: int) -> None:\n        \"\"\"Install block lists after files have been downloaded.\"\"\"\n        try:\n            with open(self._local_hosts_file, \"w\", encoding=\"utf-8\") as f:\n                for host in sorted(self._blocked_hosts):\n                    f.write(host + \"\\n\")\n                message.info(\n                    \"hostblock: Read {} hosts from {} sources.\".format(\n                        len(self._blocked_hosts), done_count\n                    )\n                )\n        except OSError:\n            logger.exception(\"Failed to write host block list!\")\n\n    def update_files(self) -> None:\n        \"\"\"Update files when the config changed.\"\"\"\n        if not config.val.content.blocking.hosts.lists:\n            try:\n                os.remove(self._local_hosts_file)\n            except FileNotFoundError:\n                pass\n            except OSError as e:\n                logger.exception(\"Failed to delete hosts file: {}\".format(e))\n\n\n@hook.config_changed(\"content.blocking.hosts.lists\")\ndef on_lists_changed() -> None:\n    host_blocker.update_files()\n\n\n@hook.config_changed(\"content.blocking.method\")\ndef on_method_changed() -> None:\n    host_blocker.enabled = _should_be_used()\n\n\n@hook.init()\ndef init(context: apitypes.InitContext) -> None:\n    \"\"\"Initialize the host blocker.\"\"\"\n    global host_blocker\n    host_blocker = HostBlocker(\n        data_dir=context.data_dir,\n        config_dir=context.config_dir,\n        has_basedir=context.args.basedir is not None,\n    )\n    host_blocker.read_hosts()\n    interceptor.register(host_blocker.filter_request)\n",
                "after": "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n\n# Copyright 2014-2021 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n#\n# This file is part of qutebrowser.\n#\n# qutebrowser is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# qutebrowser is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with qutebrowser.  If not, see <https://www.gnu.org/licenses/>.\n\n\"\"\"Functions related to host blocking.\"\"\"\n\nimport os.path\nimport posixpath\nimport zipfile\nimport logging\nimport pathlib\nfrom typing import cast, IO, Set\n\nfrom PyQt5.QtCore import QUrl\n\nfrom qutebrowser.api import (\n    hook,\n    config,\n    message,\n    interceptor,\n    apitypes,\n    qtutils,\n)\nfrom qutebrowser.components.utils import blockutils\nfrom qutebrowser.utils import version  # FIXME: Move needed parts into api namespace?\n\n\nlogger = logging.getLogger(\"network\")\nhost_blocker = cast(\"HostBlocker\", None)\n\n\ndef _guess_zip_filename(zf: zipfile.ZipFile) -> str:\n    \"\"\"Guess which file to use inside a zip file.\"\"\"\n    files = zf.namelist()\n    if len(files) == 1:\n        return files[0]\n    else:\n        for e in files:\n            if posixpath.splitext(e)[0].lower() == \"hosts\":\n                return e\n    raise FileNotFoundError(\"No hosts file found in zip\")\n\n\ndef get_fileobj(byte_io: IO[bytes]) -> IO[bytes]:\n    \"\"\"Get a usable file object to read the hosts file from.\"\"\"\n    byte_io.seek(0)  # rewind downloaded file\n    if zipfile.is_zipfile(byte_io):\n        byte_io.seek(0)  # rewind what zipfile.is_zipfile did\n        zf = zipfile.ZipFile(byte_io)\n        filename = _guess_zip_filename(zf)\n        byte_io = zf.open(filename, mode=\"r\")\n    else:\n        byte_io.seek(0)  # rewind what zipfile.is_zipfile did\n    return byte_io\n\n\ndef _should_be_used() -> bool:\n    \"\"\"Whether the hostblocker should be used or not.\"\"\"\n    method = config.val.content.blocking.method\n\n    adblock_info = version.MODULE_INFO[\"adblock\"]\n    adblock_usable = adblock_info.is_usable()\n\n    logger.debug(f\"Configured adblock method {method}, adblock library usable: \"\n                 f\"{adblock_usable}\")\n    return method in (\"both\", \"hosts\") or (method == \"auto\" and not adblock_usable)\n\n\nclass HostBlocker:\n\n    \"\"\"Manage blocked hosts based from /etc/hosts-like files.\n\n    Attributes:\n        enabled: Given the current blocking method, should the host blocker be enabled?\n        _blocked_hosts: A set of blocked hosts.\n        _config_blocked_hosts: A set of blocked hosts from ~/.config.\n        _local_hosts_file: The path to the blocked-hosts file.\n        _config_hosts_file: The path to a blocked-hosts in ~/.config\n        _has_basedir: Whether a custom --basedir is set.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        data_dir: pathlib.Path,\n        config_dir: pathlib.Path,\n        has_basedir: bool = False\n    ) -> None:\n        self.enabled = _should_be_used()\n        self._has_basedir = has_basedir\n        self._blocked_hosts: Set[str] = set()\n        self._config_blocked_hosts: Set[str] = set()\n\n        self._local_hosts_file = str(data_dir / \"blocked-hosts\")\n        self.update_files()\n\n        self._config_hosts_file = str(config_dir / \"blocked-hosts\")\n\n    def _is_blocked(self, request_url: QUrl, first_party_url: QUrl = None) -> bool:\n        \"\"\"Check whether the given request is blocked.\"\"\"\n        if not self.enabled:\n            return False\n\n        if first_party_url is not None and not first_party_url.isValid():\n            first_party_url = None\n\n        qtutils.ensure_valid(request_url)\n\n        if not config.get(\"content.blocking.enabled\", url=first_party_url):\n            return False\n\n        host = request_url.host()\n        if blockutils.is_whitelisted_url(request_url):\n            return False\n\n        for hostname in _widened_hostnames(host):\n            if hostname in self._blocked_hosts or hostname in self._config_blocked_hosts:\n                return True\n        return False\n\n    def filter_request(self, info: interceptor.Request) -> None:\n        \"\"\"Block the given request if necessary.\"\"\"\n        if self._is_blocked(\n            request_url=info.request_url, first_party_url=info.first_party_url\n        ):\n            logger.debug(\n                \"Request to {} blocked by host blocker.\".format(info.request_url.host())\n            )\n            info.block()\n\n    def _read_hosts_line(self, raw_line: bytes) -> Set[str]:\n        \"\"\"Read hosts from the given line.\n\n        Args:\n            line: The bytes object to read.\n\n        Returns:\n            A set containing valid hosts found\n            in the line.\n        \"\"\"\n        if raw_line.startswith(b\"#\"):\n            # Ignoring comments early so we don't have to care about\n            # encoding errors in them\n            return set()\n\n        line = raw_line.decode(\"utf-8\")\n\n        # Remove comments\n        hash_idx = line.find(\"#\")\n        line = line if hash_idx == -1 else line[:hash_idx]\n\n        parts = line.strip().split()\n        if len(parts) == 1:\n            # \"one host per line\" format\n            hosts = parts\n        else:\n            # /etc/hosts format\n            hosts = parts[1:]\n\n        filtered_hosts = set()\n        for host in hosts:\n            if \".\" in host and not host.endswith(\".localdomain\") and host != \"0.0.0.0\":\n                filtered_hosts.update([host])\n\n        return filtered_hosts\n\n    def _read_hosts_file(self, filename: str, target: Set[str]) -> bool:\n        \"\"\"Read hosts from the given filename.\n\n        Args:\n            filename: The file to read.\n            target: The set to store the hosts in.\n\n        Return:\n            True if a read was attempted, False otherwise\n        \"\"\"\n        if not os.path.exists(filename):\n            return False\n\n        try:\n            with open(filename, \"rb\") as f:\n                for line in f:\n                    target |= self._read_hosts_line(line)\n\n        except (OSError, UnicodeDecodeError):\n            logger.exception(\"Failed to read host blocklist!\")\n\n        return True\n\n    def read_hosts(self) -> None:\n        \"\"\"Read hosts from the existing blocked-hosts file.\"\"\"\n        self._blocked_hosts = set()\n\n        self._read_hosts_file(self._config_hosts_file, self._config_blocked_hosts)\n\n        found = self._read_hosts_file(self._local_hosts_file, self._blocked_hosts)\n\n        if not found:\n            if (\n                config.val.content.blocking.hosts.lists\n                and not self._has_basedir\n                and config.val.content.blocking.enabled\n                and self.enabled\n            ):\n                message.info(\"Run :adblock-update to get adblock lists.\")\n\n    def adblock_update(self) -> blockutils.BlocklistDownloads:\n        \"\"\"Update the adblock block lists.\"\"\"\n        self._read_hosts_file(self._config_hosts_file, self._config_blocked_hosts)\n        self._blocked_hosts = set()\n\n        blocklists = config.val.content.blocking.hosts.lists\n        dl = blockutils.BlocklistDownloads(blocklists)\n        dl.single_download_finished.connect(self._merge_file)\n        dl.all_downloads_finished.connect(self._on_lists_downloaded)\n        dl.initiate()\n        return dl\n\n    def _merge_file(self, byte_io: IO[bytes]) -> None:\n        \"\"\"Read and merge host files.\n\n        Args:\n            byte_io: The BytesIO object of the completed download.\n        \"\"\"\n        error_count = 0\n        line_count = 0\n        try:\n            f = get_fileobj(byte_io)\n        except (OSError, zipfile.BadZipFile, zipfile.LargeZipFile, LookupError) as e:\n            message.error(\n                \"hostblock: Error while reading {}: {} - {}\".format(\n                    byte_io.name, e.__class__.__name__, e\n                )\n            )\n            return\n\n        for line in f:\n            line_count += 1\n            try:\n                self._blocked_hosts |= self._read_hosts_line(line)\n            except UnicodeDecodeError:\n                logger.error(\"Failed to decode: {!r}\".format(line))\n                error_count += 1\n\n        logger.debug(\"{}: read {} lines\".format(byte_io.name, line_count))\n        if error_count > 0:\n            message.error(\n                \"hostblock: {} read errors for {}\".format(error_count, byte_io.name)\n            )\n\n    def _on_lists_downloaded(self, done_count: int) -> None:\n        \"\"\"Install block lists after files have been downloaded.\"\"\"\n        try:\n            with open(self._local_hosts_file, \"w\", encoding=\"utf-8\") as f:\n                for host in sorted(self._blocked_hosts):\n                    f.write(host + \"\\n\")\n                message.info(\n                    \"hostblock: Read {} hosts from {} sources.\".format(\n                        len(self._blocked_hosts), done_count\n                    )\n                )\n        except OSError:\n            logger.exception(\"Failed to write host block list!\")\n\n    def update_files(self) -> None:\n        \"\"\"Update files when the config changed.\"\"\"\n        if not config.val.content.blocking.hosts.lists:\n            try:\n                os.remove(self._local_hosts_file)\n            except FileNotFoundError:\n                pass\n            except OSError as e:\n                logger.exception(\"Failed to delete hosts file: {}\".format(e))\n\n\n@hook.config_changed(\"content.blocking.hosts.lists\")\ndef on_lists_changed() -> None:\n    host_blocker.update_files()\n\n\n@hook.config_changed(\"content.blocking.method\")\ndef on_method_changed() -> None:\n    host_blocker.enabled = _should_be_used()\n\n\n@hook.init()\ndef init(context: apitypes.InitContext) -> None:\n    \"\"\"Initialize the host blocker.\"\"\"\n    global host_blocker\n    host_blocker = HostBlocker(\n        data_dir=context.data_dir,\n        config_dir=context.config_dir,\n        has_basedir=context.args.basedir is not None,\n    )\n    host_blocker.read_hosts()\n    interceptor.register(host_blocker.filter_request)\n",
                "additions": 7,
                "deletions": 3
              },
              "truncated": false
            },
            "time": {
              "start": 1769437560424,
              "end": 1769437563496
            }
          }
        },
        {
          "id": "prt_bfab28a830013g85Rh5W6SaD1r",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab263ef001qRhcNLVW2fOKFg",
          "type": "step-finish",
          "reason": "tool-calls",
          "snapshot": "",
          "cost": 0,
          "tokens": {
            "input": 0,
            "output": 597,
            "reasoning": 0,
            "cache": {
              "read": 63325,
              "write": 558
            }
          }
        }
      ]
    },
    {
      "info": {
        "id": "msg_bfab28bdf0010fEDX7AaVkrg4G",
        "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
        "role": "assistant",
        "time": {
          "created": 1769437563871,
          "completed": 1769437568373
        },
        "parentID": "msg_bfaaf7dfd001wtLwIM1eGC5XRs",
        "modelID": "claude-opus-4-5",
        "providerID": "anthropic",
        "mode": "opus-codex",
        "agent": "opus-codex",
        "path": {
          "cwd": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896",
          "root": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896"
        },
        "cost": 0,
        "tokens": {
          "input": 0,
          "output": 201,
          "reasoning": 0,
          "cache": {
            "read": 63883,
            "write": 848
          }
        },
        "finish": "tool-calls"
      },
      "parts": [
        {
          "id": "prt_bfab2934e00170eb70V3EtwQJs",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab28bdf0010fEDX7AaVkrg4G",
          "type": "step-start",
          "snapshot": ""
        },
        {
          "id": "prt_bfab2936d001dUPMEjhFl2ZnD4",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab28bdf0010fEDX7AaVkrg4G",
          "type": "text",
          "text": "Now I need to add the `_widened_hostnames` function or import it. Let me add it to hostblock.py. First, let me check what imports are at the top of hostblock.py:",
          "time": {
            "start": 1769437566380,
            "end": 1769437566380
          }
        },
        {
          "id": "prt_bfab295ae001r0U7z33gEh5Qpu",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab28bdf0010fEDX7AaVkrg4G",
          "type": "tool",
          "callID": "toolu_01Bi2r4ANA19zqE7fAXwYd8f",
          "tool": "read",
          "state": {
            "status": "completed",
            "input": {
              "filePath": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/hostblock.py",
              "offset": 0,
              "limit": 50
            },
            "output": "<file>\n00001| # vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n00002| \n00003| # Copyright 2014-2021 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n00004| #\n00005| # This file is part of qutebrowser.\n00006| #\n00007| # qutebrowser is free software: you can redistribute it and/or modify\n00008| # it under the terms of the GNU General Public License as published by\n00009| # the Free Software Foundation, either version 3 of the License, or\n00010| # (at your option) any later version.\n00011| #\n00012| # qutebrowser is distributed in the hope that it will be useful,\n00013| # but WITHOUT ANY WARRANTY; without even the implied warranty of\n00014| # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n00015| # GNU General Public License for more details.\n00016| #\n00017| # You should have received a copy of the GNU General Public License\n00018| # along with qutebrowser.  If not, see <https://www.gnu.org/licenses/>.\n00019| \n00020| \"\"\"Functions related to host blocking.\"\"\"\n00021| \n00022| import os.path\n00023| import posixpath\n00024| import zipfile\n00025| import logging\n00026| import pathlib\n00027| from typing import cast, IO, Set\n00028| \n00029| from PyQt5.QtCore import QUrl\n00030| \n00031| from qutebrowser.api import (\n00032|     hook,\n00033|     config,\n00034|     message,\n00035|     interceptor,\n00036|     apitypes,\n00037|     qtutils,\n00038| )\n00039| from qutebrowser.components.utils import blockutils\n00040| from qutebrowser.utils import version  # FIXME: Move needed parts into api namespace?\n00041| \n00042| \n00043| logger = logging.getLogger(\"network\")\n00044| host_blocker = cast(\"HostBlocker\", None)\n00045| \n00046| \n00047| def _guess_zip_filename(zf: zipfile.ZipFile) -> str:\n00048|     \"\"\"Guess which file to use inside a zip file.\"\"\"\n00049|     files = zf.namelist()\n00050|     if len(files) == 1:\n\n(File has more lines. Use 'offset' parameter to read beyond line 50)\n</file>",
            "title": "qutebrowser/components/hostblock.py",
            "metadata": {
              "preview": "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n\n# Copyright 2014-2021 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n#\n# This file is part of qutebrowser.\n#\n# qutebrowser is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# qutebrowser is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with qutebrowser.  If not, see <https://www.gnu.org/licenses/>.\n\n\"\"\"Functions related to host blocking.\"\"\"",
              "truncated": true
            },
            "time": {
              "start": 1769437567213,
              "end": 1769437567249
            }
          }
        },
        {
          "id": "prt_bfab299140011dJQV2MBLtjgM3",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab28bdf0010fEDX7AaVkrg4G",
          "type": "step-finish",
          "reason": "tool-calls",
          "snapshot": "9f1b0ed6f27f4848e6ec07a36913daaea36c7eb7",
          "cost": 0,
          "tokens": {
            "input": 0,
            "output": 201,
            "reasoning": 0,
            "cache": {
              "read": 63883,
              "write": 848
            }
          }
        }
      ]
    },
    {
      "info": {
        "id": "msg_bfab2a010001GAEl27uH26f27o",
        "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
        "role": "assistant",
        "time": {
          "created": 1769437569044,
          "completed": 1769437576838
        },
        "parentID": "msg_bfaaf7dfd001wtLwIM1eGC5XRs",
        "modelID": "claude-opus-4-5",
        "providerID": "anthropic",
        "mode": "opus-codex",
        "agent": "opus-codex",
        "path": {
          "cwd": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896",
          "root": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896"
        },
        "cost": 0,
        "tokens": {
          "input": 0,
          "output": 202,
          "reasoning": 0,
          "cache": {
            "read": 64731,
            "write": 844
          }
        },
        "finish": "tool-calls"
      },
      "parts": [
        {
          "id": "prt_bfab2a95e001abZNmttr5Pt4t6",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab2a010001GAEl27uH26f27o",
          "type": "step-start",
          "snapshot": ""
        },
        {
          "id": "prt_bfab2a974001AaEcWC5GhSsEDQ",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab2a010001GAEl27uH26f27o",
          "type": "text",
          "text": "I'll add the `_widened_hostnames` function after the imports but before the existing functions. Let me add it:",
          "time": {
            "start": 1769437571773,
            "end": 1769437571773
          }
        },
        {
          "id": "prt_bfab2aac50019YgqXKiNgVxWB8",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab2a010001GAEl27uH26f27o",
          "type": "tool",
          "callID": "toolu_01RbKjRHa8FrJZLqk7wFxut1",
          "tool": "edit",
          "state": {
            "status": "completed",
            "input": {
              "filePath": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/hostblock.py",
              "oldString": "from typing import cast, IO, Set",
              "newString": "from typing import cast, IO, Iterator, Optional, Set"
            },
            "output": "Edit applied successfully.\n\nLSP errors detected in this file, please fix:\n<diagnostics file=\"/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/hostblock.py\">\nERROR [114:70] Expression of type \"None\" cannot be assigned to parameter of type \"QUrl\"\n\"None\" is not assignable to \"QUrl\"\nERROR [120:31] Type \"None\" is not assignable to declared type \"QUrl\"\n\"None\" is not assignable to \"QUrl\"\nERROR [135:59] Argument of type \"Unknown | None\" cannot be assigned to parameter \"first_party_url\" of type \"QUrl\" in function \"_is_blocked\"\nType \"Unknown | None\" is not assignable to type \"QUrl\"\n\"None\" is not assignable to \"QUrl\"\n</diagnostics>",
            "title": "qutebrowser/components/hostblock.py",
            "metadata": {
              "diagnostics": {
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/components/test_hostblock.py": [],
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/utils/test_urlutils.py": [
                  {
                    "range": {
                      "start": {
                        "line": 81,
                        "character": 40
                      },
                      "end": {
                        "line": 81,
                        "character": 55
                      }
                    },
                    "message": "Argument of type \"() -> bool\" cannot be assigned to parameter \"error\" of type \"bool\" in function \"__init__\"\n\"MethodType\" is not assignable to \"bool\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 794,
                        "character": 29
                      },
                      "end": {
                        "line": 794,
                        "character": 46
                      }
                    },
                    "message": "\"widened_hostnames\" is not a known attribute of module \"qutebrowser.utils.urlutils\"",
                    "severity": 1,
                    "code": "reportAttributeAccessIssue",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportAttributeAccessIssue"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 802,
                        "character": 40
                      },
                      "end": {
                        "line": 802,
                        "character": 57
                      }
                    },
                    "message": "\"widened_hostnames\" is not a known attribute of module \"qutebrowser.utils.urlutils\"",
                    "severity": 1,
                    "code": "reportAttributeAccessIssue",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportAttributeAccessIssue"
                    }
                  }
                ],
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/hostblock.py": [
                  {
                    "range": {
                      "start": {
                        "line": 113,
                        "character": 69
                      },
                      "end": {
                        "line": 113,
                        "character": 73
                      }
                    },
                    "message": "Expression of type \"None\" cannot be assigned to parameter of type \"QUrl\"\n\"None\" is not assignable to \"QUrl\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 119,
                        "character": 30
                      },
                      "end": {
                        "line": 119,
                        "character": 34
                      }
                    },
                    "message": "Type \"None\" is not assignable to declared type \"QUrl\"\n\"None\" is not assignable to \"QUrl\"",
                    "severity": 1,
                    "code": "reportAssignmentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportAssignmentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 134,
                        "character": 58
                      },
                      "end": {
                        "line": 134,
                        "character": 78
                      }
                    },
                    "message": "Argument of type \"Unknown | None\" cannot be assigned to parameter \"first_party_url\" of type \"QUrl\" in function \"_is_blocked\"\nType \"Unknown | None\" is not assignable to type \"QUrl\"\n\"None\" is not assignable to \"QUrl\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  }
                ],
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/utils/urlutils.py": [
                  {
                    "range": {
                      "start": {
                        "line": 193,
                        "character": 25
                      },
                      "end": {
                        "line": 193,
                        "character": 29
                      }
                    },
                    "message": "Expression of type \"None\" cannot be assigned to parameter of type \"str\"\n\"None\" is not assignable to \"str\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 349,
                        "character": 33
                      },
                      "end": {
                        "line": 349,
                        "character": 37
                      }
                    },
                    "message": "Expression of type \"None\" cannot be assigned to parameter of type \"str\"\n\"None\" is not assignable to \"str\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 396,
                        "character": 49
                      },
                      "end": {
                        "line": 396,
                        "character": 53
                      }
                    },
                    "message": "Expression of type \"None\" cannot be assigned to parameter of type \"str\"\n\"None\" is not assignable to \"str\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  }
                ],
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/config/test_configutils.py": [
                  {
                    "range": {
                      "start": {
                        "line": 33,
                        "character": 63
                      },
                      "end": {
                        "line": 33,
                        "character": 67
                      }
                    },
                    "message": "Argument of type \"None\" cannot be assigned to parameter \"backends\" of type \"Iterable[Backend]\" in function \"__init__\"\n\"None\" is incompatible with protocol \"Iterable[Backend]\"\n\"__iter__\" is not present",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 34,
                        "character": 60
                      },
                      "end": {
                        "line": 34,
                        "character": 64
                      }
                    },
                    "message": "Argument of type \"None\" cannot be assigned to parameter \"description\" of type \"str\" in function \"__init__\"\n\"None\" is not assignable to \"str\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  }
                ],
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/config/configutils.py": []
              },
              "diff": "Index: /Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/hostblock.py\n===================================================================\n--- /Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/hostblock.py\n+++ /Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/hostblock.py\n@@ -23,9 +23,9 @@\n import posixpath\n import zipfile\n import logging\n import pathlib\n-from typing import cast, IO, Set\n+from typing import cast, IO, Iterator, Optional, Set\n \n from PyQt5.QtCore import QUrl\n \n from qutebrowser.api import (\n",
              "filediff": {
                "file": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/hostblock.py",
                "before": "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n\n# Copyright 2014-2021 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n#\n# This file is part of qutebrowser.\n#\n# qutebrowser is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# qutebrowser is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with qutebrowser.  If not, see <https://www.gnu.org/licenses/>.\n\n\"\"\"Functions related to host blocking.\"\"\"\n\nimport os.path\nimport posixpath\nimport zipfile\nimport logging\nimport pathlib\nfrom typing import cast, IO, Set\n\nfrom PyQt5.QtCore import QUrl\n\nfrom qutebrowser.api import (\n    hook,\n    config,\n    message,\n    interceptor,\n    apitypes,\n    qtutils,\n)\nfrom qutebrowser.components.utils import blockutils\nfrom qutebrowser.utils import version  # FIXME: Move needed parts into api namespace?\n\n\nlogger = logging.getLogger(\"network\")\nhost_blocker = cast(\"HostBlocker\", None)\n\n\ndef _guess_zip_filename(zf: zipfile.ZipFile) -> str:\n    \"\"\"Guess which file to use inside a zip file.\"\"\"\n    files = zf.namelist()\n    if len(files) == 1:\n        return files[0]\n    else:\n        for e in files:\n            if posixpath.splitext(e)[0].lower() == \"hosts\":\n                return e\n    raise FileNotFoundError(\"No hosts file found in zip\")\n\n\ndef get_fileobj(byte_io: IO[bytes]) -> IO[bytes]:\n    \"\"\"Get a usable file object to read the hosts file from.\"\"\"\n    byte_io.seek(0)  # rewind downloaded file\n    if zipfile.is_zipfile(byte_io):\n        byte_io.seek(0)  # rewind what zipfile.is_zipfile did\n        zf = zipfile.ZipFile(byte_io)\n        filename = _guess_zip_filename(zf)\n        byte_io = zf.open(filename, mode=\"r\")\n    else:\n        byte_io.seek(0)  # rewind what zipfile.is_zipfile did\n    return byte_io\n\n\ndef _should_be_used() -> bool:\n    \"\"\"Whether the hostblocker should be used or not.\"\"\"\n    method = config.val.content.blocking.method\n\n    adblock_info = version.MODULE_INFO[\"adblock\"]\n    adblock_usable = adblock_info.is_usable()\n\n    logger.debug(f\"Configured adblock method {method}, adblock library usable: \"\n                 f\"{adblock_usable}\")\n    return method in (\"both\", \"hosts\") or (method == \"auto\" and not adblock_usable)\n\n\nclass HostBlocker:\n\n    \"\"\"Manage blocked hosts based from /etc/hosts-like files.\n\n    Attributes:\n        enabled: Given the current blocking method, should the host blocker be enabled?\n        _blocked_hosts: A set of blocked hosts.\n        _config_blocked_hosts: A set of blocked hosts from ~/.config.\n        _local_hosts_file: The path to the blocked-hosts file.\n        _config_hosts_file: The path to a blocked-hosts in ~/.config\n        _has_basedir: Whether a custom --basedir is set.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        data_dir: pathlib.Path,\n        config_dir: pathlib.Path,\n        has_basedir: bool = False\n    ) -> None:\n        self.enabled = _should_be_used()\n        self._has_basedir = has_basedir\n        self._blocked_hosts: Set[str] = set()\n        self._config_blocked_hosts: Set[str] = set()\n\n        self._local_hosts_file = str(data_dir / \"blocked-hosts\")\n        self.update_files()\n\n        self._config_hosts_file = str(config_dir / \"blocked-hosts\")\n\n    def _is_blocked(self, request_url: QUrl, first_party_url: QUrl = None) -> bool:\n        \"\"\"Check whether the given request is blocked.\"\"\"\n        if not self.enabled:\n            return False\n\n        if first_party_url is not None and not first_party_url.isValid():\n            first_party_url = None\n\n        qtutils.ensure_valid(request_url)\n\n        if not config.get(\"content.blocking.enabled\", url=first_party_url):\n            return False\n\n        host = request_url.host()\n        if blockutils.is_whitelisted_url(request_url):\n            return False\n\n        for hostname in _widened_hostnames(host):\n            if hostname in self._blocked_hosts or hostname in self._config_blocked_hosts:\n                return True\n        return False\n\n    def filter_request(self, info: interceptor.Request) -> None:\n        \"\"\"Block the given request if necessary.\"\"\"\n        if self._is_blocked(\n            request_url=info.request_url, first_party_url=info.first_party_url\n        ):\n            logger.debug(\n                \"Request to {} blocked by host blocker.\".format(info.request_url.host())\n            )\n            info.block()\n\n    def _read_hosts_line(self, raw_line: bytes) -> Set[str]:\n        \"\"\"Read hosts from the given line.\n\n        Args:\n            line: The bytes object to read.\n\n        Returns:\n            A set containing valid hosts found\n            in the line.\n        \"\"\"\n        if raw_line.startswith(b\"#\"):\n            # Ignoring comments early so we don't have to care about\n            # encoding errors in them\n            return set()\n\n        line = raw_line.decode(\"utf-8\")\n\n        # Remove comments\n        hash_idx = line.find(\"#\")\n        line = line if hash_idx == -1 else line[:hash_idx]\n\n        parts = line.strip().split()\n        if len(parts) == 1:\n            # \"one host per line\" format\n            hosts = parts\n        else:\n            # /etc/hosts format\n            hosts = parts[1:]\n\n        filtered_hosts = set()\n        for host in hosts:\n            if \".\" in host and not host.endswith(\".localdomain\") and host != \"0.0.0.0\":\n                filtered_hosts.update([host])\n\n        return filtered_hosts\n\n    def _read_hosts_file(self, filename: str, target: Set[str]) -> bool:\n        \"\"\"Read hosts from the given filename.\n\n        Args:\n            filename: The file to read.\n            target: The set to store the hosts in.\n\n        Return:\n            True if a read was attempted, False otherwise\n        \"\"\"\n        if not os.path.exists(filename):\n            return False\n\n        try:\n            with open(filename, \"rb\") as f:\n                for line in f:\n                    target |= self._read_hosts_line(line)\n\n        except (OSError, UnicodeDecodeError):\n            logger.exception(\"Failed to read host blocklist!\")\n\n        return True\n\n    def read_hosts(self) -> None:\n        \"\"\"Read hosts from the existing blocked-hosts file.\"\"\"\n        self._blocked_hosts = set()\n\n        self._read_hosts_file(self._config_hosts_file, self._config_blocked_hosts)\n\n        found = self._read_hosts_file(self._local_hosts_file, self._blocked_hosts)\n\n        if not found:\n            if (\n                config.val.content.blocking.hosts.lists\n                and not self._has_basedir\n                and config.val.content.blocking.enabled\n                and self.enabled\n            ):\n                message.info(\"Run :adblock-update to get adblock lists.\")\n\n    def adblock_update(self) -> blockutils.BlocklistDownloads:\n        \"\"\"Update the adblock block lists.\"\"\"\n        self._read_hosts_file(self._config_hosts_file, self._config_blocked_hosts)\n        self._blocked_hosts = set()\n\n        blocklists = config.val.content.blocking.hosts.lists\n        dl = blockutils.BlocklistDownloads(blocklists)\n        dl.single_download_finished.connect(self._merge_file)\n        dl.all_downloads_finished.connect(self._on_lists_downloaded)\n        dl.initiate()\n        return dl\n\n    def _merge_file(self, byte_io: IO[bytes]) -> None:\n        \"\"\"Read and merge host files.\n\n        Args:\n            byte_io: The BytesIO object of the completed download.\n        \"\"\"\n        error_count = 0\n        line_count = 0\n        try:\n            f = get_fileobj(byte_io)\n        except (OSError, zipfile.BadZipFile, zipfile.LargeZipFile, LookupError) as e:\n            message.error(\n                \"hostblock: Error while reading {}: {} - {}\".format(\n                    byte_io.name, e.__class__.__name__, e\n                )\n            )\n            return\n\n        for line in f:\n            line_count += 1\n            try:\n                self._blocked_hosts |= self._read_hosts_line(line)\n            except UnicodeDecodeError:\n                logger.error(\"Failed to decode: {!r}\".format(line))\n                error_count += 1\n\n        logger.debug(\"{}: read {} lines\".format(byte_io.name, line_count))\n        if error_count > 0:\n            message.error(\n                \"hostblock: {} read errors for {}\".format(error_count, byte_io.name)\n            )\n\n    def _on_lists_downloaded(self, done_count: int) -> None:\n        \"\"\"Install block lists after files have been downloaded.\"\"\"\n        try:\n            with open(self._local_hosts_file, \"w\", encoding=\"utf-8\") as f:\n                for host in sorted(self._blocked_hosts):\n                    f.write(host + \"\\n\")\n                message.info(\n                    \"hostblock: Read {} hosts from {} sources.\".format(\n                        len(self._blocked_hosts), done_count\n                    )\n                )\n        except OSError:\n            logger.exception(\"Failed to write host block list!\")\n\n    def update_files(self) -> None:\n        \"\"\"Update files when the config changed.\"\"\"\n        if not config.val.content.blocking.hosts.lists:\n            try:\n                os.remove(self._local_hosts_file)\n            except FileNotFoundError:\n                pass\n            except OSError as e:\n                logger.exception(\"Failed to delete hosts file: {}\".format(e))\n\n\n@hook.config_changed(\"content.blocking.hosts.lists\")\ndef on_lists_changed() -> None:\n    host_blocker.update_files()\n\n\n@hook.config_changed(\"content.blocking.method\")\ndef on_method_changed() -> None:\n    host_blocker.enabled = _should_be_used()\n\n\n@hook.init()\ndef init(context: apitypes.InitContext) -> None:\n    \"\"\"Initialize the host blocker.\"\"\"\n    global host_blocker\n    host_blocker = HostBlocker(\n        data_dir=context.data_dir,\n        config_dir=context.config_dir,\n        has_basedir=context.args.basedir is not None,\n    )\n    host_blocker.read_hosts()\n    interceptor.register(host_blocker.filter_request)\n",
                "after": "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n\n# Copyright 2014-2021 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n#\n# This file is part of qutebrowser.\n#\n# qutebrowser is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# qutebrowser is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with qutebrowser.  If not, see <https://www.gnu.org/licenses/>.\n\n\"\"\"Functions related to host blocking.\"\"\"\n\nimport os.path\nimport posixpath\nimport zipfile\nimport logging\nimport pathlib\nfrom typing import cast, IO, Iterator, Optional, Set\n\nfrom PyQt5.QtCore import QUrl\n\nfrom qutebrowser.api import (\n    hook,\n    config,\n    message,\n    interceptor,\n    apitypes,\n    qtutils,\n)\nfrom qutebrowser.components.utils import blockutils\nfrom qutebrowser.utils import version  # FIXME: Move needed parts into api namespace?\n\n\nlogger = logging.getLogger(\"network\")\nhost_blocker = cast(\"HostBlocker\", None)\n\n\ndef _guess_zip_filename(zf: zipfile.ZipFile) -> str:\n    \"\"\"Guess which file to use inside a zip file.\"\"\"\n    files = zf.namelist()\n    if len(files) == 1:\n        return files[0]\n    else:\n        for e in files:\n            if posixpath.splitext(e)[0].lower() == \"hosts\":\n                return e\n    raise FileNotFoundError(\"No hosts file found in zip\")\n\n\ndef get_fileobj(byte_io: IO[bytes]) -> IO[bytes]:\n    \"\"\"Get a usable file object to read the hosts file from.\"\"\"\n    byte_io.seek(0)  # rewind downloaded file\n    if zipfile.is_zipfile(byte_io):\n        byte_io.seek(0)  # rewind what zipfile.is_zipfile did\n        zf = zipfile.ZipFile(byte_io)\n        filename = _guess_zip_filename(zf)\n        byte_io = zf.open(filename, mode=\"r\")\n    else:\n        byte_io.seek(0)  # rewind what zipfile.is_zipfile did\n    return byte_io\n\n\ndef _should_be_used() -> bool:\n    \"\"\"Whether the hostblocker should be used or not.\"\"\"\n    method = config.val.content.blocking.method\n\n    adblock_info = version.MODULE_INFO[\"adblock\"]\n    adblock_usable = adblock_info.is_usable()\n\n    logger.debug(f\"Configured adblock method {method}, adblock library usable: \"\n                 f\"{adblock_usable}\")\n    return method in (\"both\", \"hosts\") or (method == \"auto\" and not adblock_usable)\n\n\nclass HostBlocker:\n\n    \"\"\"Manage blocked hosts based from /etc/hosts-like files.\n\n    Attributes:\n        enabled: Given the current blocking method, should the host blocker be enabled?\n        _blocked_hosts: A set of blocked hosts.\n        _config_blocked_hosts: A set of blocked hosts from ~/.config.\n        _local_hosts_file: The path to the blocked-hosts file.\n        _config_hosts_file: The path to a blocked-hosts in ~/.config\n        _has_basedir: Whether a custom --basedir is set.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        data_dir: pathlib.Path,\n        config_dir: pathlib.Path,\n        has_basedir: bool = False\n    ) -> None:\n        self.enabled = _should_be_used()\n        self._has_basedir = has_basedir\n        self._blocked_hosts: Set[str] = set()\n        self._config_blocked_hosts: Set[str] = set()\n\n        self._local_hosts_file = str(data_dir / \"blocked-hosts\")\n        self.update_files()\n\n        self._config_hosts_file = str(config_dir / \"blocked-hosts\")\n\n    def _is_blocked(self, request_url: QUrl, first_party_url: QUrl = None) -> bool:\n        \"\"\"Check whether the given request is blocked.\"\"\"\n        if not self.enabled:\n            return False\n\n        if first_party_url is not None and not first_party_url.isValid():\n            first_party_url = None\n\n        qtutils.ensure_valid(request_url)\n\n        if not config.get(\"content.blocking.enabled\", url=first_party_url):\n            return False\n\n        host = request_url.host()\n        if blockutils.is_whitelisted_url(request_url):\n            return False\n\n        for hostname in _widened_hostnames(host):\n            if hostname in self._blocked_hosts or hostname in self._config_blocked_hosts:\n                return True\n        return False\n\n    def filter_request(self, info: interceptor.Request) -> None:\n        \"\"\"Block the given request if necessary.\"\"\"\n        if self._is_blocked(\n            request_url=info.request_url, first_party_url=info.first_party_url\n        ):\n            logger.debug(\n                \"Request to {} blocked by host blocker.\".format(info.request_url.host())\n            )\n            info.block()\n\n    def _read_hosts_line(self, raw_line: bytes) -> Set[str]:\n        \"\"\"Read hosts from the given line.\n\n        Args:\n            line: The bytes object to read.\n\n        Returns:\n            A set containing valid hosts found\n            in the line.\n        \"\"\"\n        if raw_line.startswith(b\"#\"):\n            # Ignoring comments early so we don't have to care about\n            # encoding errors in them\n            return set()\n\n        line = raw_line.decode(\"utf-8\")\n\n        # Remove comments\n        hash_idx = line.find(\"#\")\n        line = line if hash_idx == -1 else line[:hash_idx]\n\n        parts = line.strip().split()\n        if len(parts) == 1:\n            # \"one host per line\" format\n            hosts = parts\n        else:\n            # /etc/hosts format\n            hosts = parts[1:]\n\n        filtered_hosts = set()\n        for host in hosts:\n            if \".\" in host and not host.endswith(\".localdomain\") and host != \"0.0.0.0\":\n                filtered_hosts.update([host])\n\n        return filtered_hosts\n\n    def _read_hosts_file(self, filename: str, target: Set[str]) -> bool:\n        \"\"\"Read hosts from the given filename.\n\n        Args:\n            filename: The file to read.\n            target: The set to store the hosts in.\n\n        Return:\n            True if a read was attempted, False otherwise\n        \"\"\"\n        if not os.path.exists(filename):\n            return False\n\n        try:\n            with open(filename, \"rb\") as f:\n                for line in f:\n                    target |= self._read_hosts_line(line)\n\n        except (OSError, UnicodeDecodeError):\n            logger.exception(\"Failed to read host blocklist!\")\n\n        return True\n\n    def read_hosts(self) -> None:\n        \"\"\"Read hosts from the existing blocked-hosts file.\"\"\"\n        self._blocked_hosts = set()\n\n        self._read_hosts_file(self._config_hosts_file, self._config_blocked_hosts)\n\n        found = self._read_hosts_file(self._local_hosts_file, self._blocked_hosts)\n\n        if not found:\n            if (\n                config.val.content.blocking.hosts.lists\n                and not self._has_basedir\n                and config.val.content.blocking.enabled\n                and self.enabled\n            ):\n                message.info(\"Run :adblock-update to get adblock lists.\")\n\n    def adblock_update(self) -> blockutils.BlocklistDownloads:\n        \"\"\"Update the adblock block lists.\"\"\"\n        self._read_hosts_file(self._config_hosts_file, self._config_blocked_hosts)\n        self._blocked_hosts = set()\n\n        blocklists = config.val.content.blocking.hosts.lists\n        dl = blockutils.BlocklistDownloads(blocklists)\n        dl.single_download_finished.connect(self._merge_file)\n        dl.all_downloads_finished.connect(self._on_lists_downloaded)\n        dl.initiate()\n        return dl\n\n    def _merge_file(self, byte_io: IO[bytes]) -> None:\n        \"\"\"Read and merge host files.\n\n        Args:\n            byte_io: The BytesIO object of the completed download.\n        \"\"\"\n        error_count = 0\n        line_count = 0\n        try:\n            f = get_fileobj(byte_io)\n        except (OSError, zipfile.BadZipFile, zipfile.LargeZipFile, LookupError) as e:\n            message.error(\n                \"hostblock: Error while reading {}: {} - {}\".format(\n                    byte_io.name, e.__class__.__name__, e\n                )\n            )\n            return\n\n        for line in f:\n            line_count += 1\n            try:\n                self._blocked_hosts |= self._read_hosts_line(line)\n            except UnicodeDecodeError:\n                logger.error(\"Failed to decode: {!r}\".format(line))\n                error_count += 1\n\n        logger.debug(\"{}: read {} lines\".format(byte_io.name, line_count))\n        if error_count > 0:\n            message.error(\n                \"hostblock: {} read errors for {}\".format(error_count, byte_io.name)\n            )\n\n    def _on_lists_downloaded(self, done_count: int) -> None:\n        \"\"\"Install block lists after files have been downloaded.\"\"\"\n        try:\n            with open(self._local_hosts_file, \"w\", encoding=\"utf-8\") as f:\n                for host in sorted(self._blocked_hosts):\n                    f.write(host + \"\\n\")\n                message.info(\n                    \"hostblock: Read {} hosts from {} sources.\".format(\n                        len(self._blocked_hosts), done_count\n                    )\n                )\n        except OSError:\n            logger.exception(\"Failed to write host block list!\")\n\n    def update_files(self) -> None:\n        \"\"\"Update files when the config changed.\"\"\"\n        if not config.val.content.blocking.hosts.lists:\n            try:\n                os.remove(self._local_hosts_file)\n            except FileNotFoundError:\n                pass\n            except OSError as e:\n                logger.exception(\"Failed to delete hosts file: {}\".format(e))\n\n\n@hook.config_changed(\"content.blocking.hosts.lists\")\ndef on_lists_changed() -> None:\n    host_blocker.update_files()\n\n\n@hook.config_changed(\"content.blocking.method\")\ndef on_method_changed() -> None:\n    host_blocker.enabled = _should_be_used()\n\n\n@hook.init()\ndef init(context: apitypes.InitContext) -> None:\n    \"\"\"Initialize the host blocker.\"\"\"\n    global host_blocker\n    host_blocker = HostBlocker(\n        data_dir=context.data_dir,\n        config_dir=context.config_dir,\n        has_basedir=context.args.basedir is not None,\n    )\n    host_blocker.read_hosts()\n    interceptor.register(host_blocker.filter_request)\n",
                "additions": 1,
                "deletions": 1
              },
              "truncated": false
            },
            "time": {
              "start": 1769437572810,
              "end": 1769437576057
            }
          }
        },
        {
          "id": "prt_bfab2bb88001Bu0XVuh27mYIpB",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab2a010001GAEl27uH26f27o",
          "type": "step-finish",
          "reason": "tool-calls",
          "snapshot": "06420e647f785975f3b8e0103739bf5001660863",
          "cost": 0,
          "tokens": {
            "input": 0,
            "output": 202,
            "reasoning": 0,
            "cache": {
              "read": 64731,
              "write": 844
            }
          }
        }
      ]
    },
    {
      "info": {
        "id": "msg_bfab2bf71001YfsQrofJkPZK3i",
        "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
        "role": "assistant",
        "time": {
          "created": 1769437577073,
          "completed": 1769437585772
        },
        "parentID": "msg_bfaaf7dfd001wtLwIM1eGC5XRs",
        "modelID": "claude-opus-4-5",
        "providerID": "anthropic",
        "mode": "opus-codex",
        "agent": "opus-codex",
        "path": {
          "cwd": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896",
          "root": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896"
        },
        "cost": 0,
        "tokens": {
          "input": 0,
          "output": 362,
          "reasoning": 0,
          "cache": {
            "read": 65575,
            "write": 453
          }
        },
        "finish": "tool-calls"
      },
      "parts": [
        {
          "id": "prt_bfab2c91e0013ms6RJHfNdBLEk",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab2bf71001YfsQrofJkPZK3i",
          "type": "step-start",
          "snapshot": ""
        },
        {
          "id": "prt_bfab2c934001rg4t5OqDXZdLjD",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab2bf71001YfsQrofJkPZK3i",
          "type": "tool",
          "callID": "toolu_01F6hNeQVaZpD7a8KWFm9HDs",
          "tool": "edit",
          "state": {
            "status": "completed",
            "input": {
              "filePath": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/hostblock.py",
              "oldString": "logger = logging.getLogger(\"network\")\nhost_blocker = cast(\"HostBlocker\", None)\n\n\ndef _guess_zip_filename(zf: zipfile.ZipFile) -> str:",
              "newString": "logger = logging.getLogger(\"network\")\nhost_blocker = cast(\"HostBlocker\", None)\n\n\ndef _widened_hostnames(hostname: Optional[str]) -> Iterator[str]:\n    \"\"\"A generator that yields widening string hostnames.\n\n    Ex: a.c.foo -> [a.c.foo, c.foo, foo]\n\n    Args:\n        hostname: The hostname string to widen.\n\n    Yields:\n        The hostname and its parent domains.\n    \"\"\"\n    if not hostname:\n        return\n    while hostname:\n        yield hostname\n        hostname = hostname.partition(\".\")[-1]\n\n\ndef _guess_zip_filename(zf: zipfile.ZipFile) -> str:"
            },
            "output": "Edit applied successfully.\n\nLSP errors detected in this file, please fix:\n<diagnostics file=\"/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/hostblock.py\">\nERROR [114:70] Expression of type \"None\" cannot be assigned to parameter of type \"QUrl\"\n\"None\" is not assignable to \"QUrl\"\nERROR [120:31] Type \"None\" is not assignable to declared type \"QUrl\"\n\"None\" is not assignable to \"QUrl\"\nERROR [135:59] Argument of type \"Unknown | None\" cannot be assigned to parameter \"first_party_url\" of type \"QUrl\" in function \"_is_blocked\"\nType \"Unknown | None\" is not assignable to type \"QUrl\"\n\"None\" is not assignable to \"QUrl\"\n</diagnostics>",
            "title": "qutebrowser/components/hostblock.py",
            "metadata": {
              "diagnostics": {
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/components/test_hostblock.py": [],
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/utils/test_urlutils.py": [
                  {
                    "range": {
                      "start": {
                        "line": 81,
                        "character": 40
                      },
                      "end": {
                        "line": 81,
                        "character": 55
                      }
                    },
                    "message": "Argument of type \"() -> bool\" cannot be assigned to parameter \"error\" of type \"bool\" in function \"__init__\"\n\"MethodType\" is not assignable to \"bool\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 794,
                        "character": 29
                      },
                      "end": {
                        "line": 794,
                        "character": 46
                      }
                    },
                    "message": "\"widened_hostnames\" is not a known attribute of module \"qutebrowser.utils.urlutils\"",
                    "severity": 1,
                    "code": "reportAttributeAccessIssue",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportAttributeAccessIssue"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 802,
                        "character": 40
                      },
                      "end": {
                        "line": 802,
                        "character": 57
                      }
                    },
                    "message": "\"widened_hostnames\" is not a known attribute of module \"qutebrowser.utils.urlutils\"",
                    "severity": 1,
                    "code": "reportAttributeAccessIssue",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportAttributeAccessIssue"
                    }
                  }
                ],
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/hostblock.py": [
                  {
                    "range": {
                      "start": {
                        "line": 113,
                        "character": 69
                      },
                      "end": {
                        "line": 113,
                        "character": 73
                      }
                    },
                    "message": "Expression of type \"None\" cannot be assigned to parameter of type \"QUrl\"\n\"None\" is not assignable to \"QUrl\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 119,
                        "character": 30
                      },
                      "end": {
                        "line": 119,
                        "character": 34
                      }
                    },
                    "message": "Type \"None\" is not assignable to declared type \"QUrl\"\n\"None\" is not assignable to \"QUrl\"",
                    "severity": 1,
                    "code": "reportAssignmentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportAssignmentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 134,
                        "character": 58
                      },
                      "end": {
                        "line": 134,
                        "character": 78
                      }
                    },
                    "message": "Argument of type \"Unknown | None\" cannot be assigned to parameter \"first_party_url\" of type \"QUrl\" in function \"_is_blocked\"\nType \"Unknown | None\" is not assignable to type \"QUrl\"\n\"None\" is not assignable to \"QUrl\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  }
                ],
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/utils/urlutils.py": [
                  {
                    "range": {
                      "start": {
                        "line": 193,
                        "character": 25
                      },
                      "end": {
                        "line": 193,
                        "character": 29
                      }
                    },
                    "message": "Expression of type \"None\" cannot be assigned to parameter of type \"str\"\n\"None\" is not assignable to \"str\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 349,
                        "character": 33
                      },
                      "end": {
                        "line": 349,
                        "character": 37
                      }
                    },
                    "message": "Expression of type \"None\" cannot be assigned to parameter of type \"str\"\n\"None\" is not assignable to \"str\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 396,
                        "character": 49
                      },
                      "end": {
                        "line": 396,
                        "character": 53
                      }
                    },
                    "message": "Expression of type \"None\" cannot be assigned to parameter of type \"str\"\n\"None\" is not assignable to \"str\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  }
                ],
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/tests/unit/config/test_configutils.py": [
                  {
                    "range": {
                      "start": {
                        "line": 33,
                        "character": 63
                      },
                      "end": {
                        "line": 33,
                        "character": 67
                      }
                    },
                    "message": "Argument of type \"None\" cannot be assigned to parameter \"backends\" of type \"Iterable[Backend]\" in function \"__init__\"\n\"None\" is incompatible with protocol \"Iterable[Backend]\"\n\"__iter__\" is not present",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  },
                  {
                    "range": {
                      "start": {
                        "line": 34,
                        "character": 60
                      },
                      "end": {
                        "line": 34,
                        "character": 64
                      }
                    },
                    "message": "Argument of type \"None\" cannot be assigned to parameter \"description\" of type \"str\" in function \"__init__\"\n\"None\" is not assignable to \"str\"",
                    "severity": 1,
                    "code": "reportArgumentType",
                    "source": "Pyright",
                    "codeDescription": {
                      "href": "https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType"
                    }
                  }
                ],
                "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/config/configutils.py": []
              },
              "diff": "Index: /Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/hostblock.py\n===================================================================\n--- /Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/hostblock.py\n+++ /Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/hostblock.py\n@@ -43,8 +43,26 @@\n logger = logging.getLogger(\"network\")\n host_blocker = cast(\"HostBlocker\", None)\n \n \n+def _widened_hostnames(hostname: Optional[str]) -> Iterator[str]:\n+    \"\"\"A generator that yields widening string hostnames.\n+\n+    Ex: a.c.foo -> [a.c.foo, c.foo, foo]\n+\n+    Args:\n+        hostname: The hostname string to widen.\n+\n+    Yields:\n+        The hostname and its parent domains.\n+    \"\"\"\n+    if not hostname:\n+        return\n+    while hostname:\n+        yield hostname\n+        hostname = hostname.partition(\".\")[-1]\n+\n+\n def _guess_zip_filename(zf: zipfile.ZipFile) -> str:\n     \"\"\"Guess which file to use inside a zip file.\"\"\"\n     files = zf.namelist()\n     if len(files) == 1:\n",
              "filediff": {
                "file": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896/qutebrowser/components/hostblock.py",
                "before": "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n\n# Copyright 2014-2021 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n#\n# This file is part of qutebrowser.\n#\n# qutebrowser is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# qutebrowser is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with qutebrowser.  If not, see <https://www.gnu.org/licenses/>.\n\n\"\"\"Functions related to host blocking.\"\"\"\n\nimport os.path\nimport posixpath\nimport zipfile\nimport logging\nimport pathlib\nfrom typing import cast, IO, Iterator, Optional, Set\n\nfrom PyQt5.QtCore import QUrl\n\nfrom qutebrowser.api import (\n    hook,\n    config,\n    message,\n    interceptor,\n    apitypes,\n    qtutils,\n)\nfrom qutebrowser.components.utils import blockutils\nfrom qutebrowser.utils import version  # FIXME: Move needed parts into api namespace?\n\n\nlogger = logging.getLogger(\"network\")\nhost_blocker = cast(\"HostBlocker\", None)\n\n\ndef _guess_zip_filename(zf: zipfile.ZipFile) -> str:\n    \"\"\"Guess which file to use inside a zip file.\"\"\"\n    files = zf.namelist()\n    if len(files) == 1:\n        return files[0]\n    else:\n        for e in files:\n            if posixpath.splitext(e)[0].lower() == \"hosts\":\n                return e\n    raise FileNotFoundError(\"No hosts file found in zip\")\n\n\ndef get_fileobj(byte_io: IO[bytes]) -> IO[bytes]:\n    \"\"\"Get a usable file object to read the hosts file from.\"\"\"\n    byte_io.seek(0)  # rewind downloaded file\n    if zipfile.is_zipfile(byte_io):\n        byte_io.seek(0)  # rewind what zipfile.is_zipfile did\n        zf = zipfile.ZipFile(byte_io)\n        filename = _guess_zip_filename(zf)\n        byte_io = zf.open(filename, mode=\"r\")\n    else:\n        byte_io.seek(0)  # rewind what zipfile.is_zipfile did\n    return byte_io\n\n\ndef _should_be_used() -> bool:\n    \"\"\"Whether the hostblocker should be used or not.\"\"\"\n    method = config.val.content.blocking.method\n\n    adblock_info = version.MODULE_INFO[\"adblock\"]\n    adblock_usable = adblock_info.is_usable()\n\n    logger.debug(f\"Configured adblock method {method}, adblock library usable: \"\n                 f\"{adblock_usable}\")\n    return method in (\"both\", \"hosts\") or (method == \"auto\" and not adblock_usable)\n\n\nclass HostBlocker:\n\n    \"\"\"Manage blocked hosts based from /etc/hosts-like files.\n\n    Attributes:\n        enabled: Given the current blocking method, should the host blocker be enabled?\n        _blocked_hosts: A set of blocked hosts.\n        _config_blocked_hosts: A set of blocked hosts from ~/.config.\n        _local_hosts_file: The path to the blocked-hosts file.\n        _config_hosts_file: The path to a blocked-hosts in ~/.config\n        _has_basedir: Whether a custom --basedir is set.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        data_dir: pathlib.Path,\n        config_dir: pathlib.Path,\n        has_basedir: bool = False\n    ) -> None:\n        self.enabled = _should_be_used()\n        self._has_basedir = has_basedir\n        self._blocked_hosts: Set[str] = set()\n        self._config_blocked_hosts: Set[str] = set()\n\n        self._local_hosts_file = str(data_dir / \"blocked-hosts\")\n        self.update_files()\n\n        self._config_hosts_file = str(config_dir / \"blocked-hosts\")\n\n    def _is_blocked(self, request_url: QUrl, first_party_url: QUrl = None) -> bool:\n        \"\"\"Check whether the given request is blocked.\"\"\"\n        if not self.enabled:\n            return False\n\n        if first_party_url is not None and not first_party_url.isValid():\n            first_party_url = None\n\n        qtutils.ensure_valid(request_url)\n\n        if not config.get(\"content.blocking.enabled\", url=first_party_url):\n            return False\n\n        host = request_url.host()\n        if blockutils.is_whitelisted_url(request_url):\n            return False\n\n        for hostname in _widened_hostnames(host):\n            if hostname in self._blocked_hosts or hostname in self._config_blocked_hosts:\n                return True\n        return False\n\n    def filter_request(self, info: interceptor.Request) -> None:\n        \"\"\"Block the given request if necessary.\"\"\"\n        if self._is_blocked(\n            request_url=info.request_url, first_party_url=info.first_party_url\n        ):\n            logger.debug(\n                \"Request to {} blocked by host blocker.\".format(info.request_url.host())\n            )\n            info.block()\n\n    def _read_hosts_line(self, raw_line: bytes) -> Set[str]:\n        \"\"\"Read hosts from the given line.\n\n        Args:\n            line: The bytes object to read.\n\n        Returns:\n            A set containing valid hosts found\n            in the line.\n        \"\"\"\n        if raw_line.startswith(b\"#\"):\n            # Ignoring comments early so we don't have to care about\n            # encoding errors in them\n            return set()\n\n        line = raw_line.decode(\"utf-8\")\n\n        # Remove comments\n        hash_idx = line.find(\"#\")\n        line = line if hash_idx == -1 else line[:hash_idx]\n\n        parts = line.strip().split()\n        if len(parts) == 1:\n            # \"one host per line\" format\n            hosts = parts\n        else:\n            # /etc/hosts format\n            hosts = parts[1:]\n\n        filtered_hosts = set()\n        for host in hosts:\n            if \".\" in host and not host.endswith(\".localdomain\") and host != \"0.0.0.0\":\n                filtered_hosts.update([host])\n\n        return filtered_hosts\n\n    def _read_hosts_file(self, filename: str, target: Set[str]) -> bool:\n        \"\"\"Read hosts from the given filename.\n\n        Args:\n            filename: The file to read.\n            target: The set to store the hosts in.\n\n        Return:\n            True if a read was attempted, False otherwise\n        \"\"\"\n        if not os.path.exists(filename):\n            return False\n\n        try:\n            with open(filename, \"rb\") as f:\n                for line in f:\n                    target |= self._read_hosts_line(line)\n\n        except (OSError, UnicodeDecodeError):\n            logger.exception(\"Failed to read host blocklist!\")\n\n        return True\n\n    def read_hosts(self) -> None:\n        \"\"\"Read hosts from the existing blocked-hosts file.\"\"\"\n        self._blocked_hosts = set()\n\n        self._read_hosts_file(self._config_hosts_file, self._config_blocked_hosts)\n\n        found = self._read_hosts_file(self._local_hosts_file, self._blocked_hosts)\n\n        if not found:\n            if (\n                config.val.content.blocking.hosts.lists\n                and not self._has_basedir\n                and config.val.content.blocking.enabled\n                and self.enabled\n            ):\n                message.info(\"Run :adblock-update to get adblock lists.\")\n\n    def adblock_update(self) -> blockutils.BlocklistDownloads:\n        \"\"\"Update the adblock block lists.\"\"\"\n        self._read_hosts_file(self._config_hosts_file, self._config_blocked_hosts)\n        self._blocked_hosts = set()\n\n        blocklists = config.val.content.blocking.hosts.lists\n        dl = blockutils.BlocklistDownloads(blocklists)\n        dl.single_download_finished.connect(self._merge_file)\n        dl.all_downloads_finished.connect(self._on_lists_downloaded)\n        dl.initiate()\n        return dl\n\n    def _merge_file(self, byte_io: IO[bytes]) -> None:\n        \"\"\"Read and merge host files.\n\n        Args:\n            byte_io: The BytesIO object of the completed download.\n        \"\"\"\n        error_count = 0\n        line_count = 0\n        try:\n            f = get_fileobj(byte_io)\n        except (OSError, zipfile.BadZipFile, zipfile.LargeZipFile, LookupError) as e:\n            message.error(\n                \"hostblock: Error while reading {}: {} - {}\".format(\n                    byte_io.name, e.__class__.__name__, e\n                )\n            )\n            return\n\n        for line in f:\n            line_count += 1\n            try:\n                self._blocked_hosts |= self._read_hosts_line(line)\n            except UnicodeDecodeError:\n                logger.error(\"Failed to decode: {!r}\".format(line))\n                error_count += 1\n\n        logger.debug(\"{}: read {} lines\".format(byte_io.name, line_count))\n        if error_count > 0:\n            message.error(\n                \"hostblock: {} read errors for {}\".format(error_count, byte_io.name)\n            )\n\n    def _on_lists_downloaded(self, done_count: int) -> None:\n        \"\"\"Install block lists after files have been downloaded.\"\"\"\n        try:\n            with open(self._local_hosts_file, \"w\", encoding=\"utf-8\") as f:\n                for host in sorted(self._blocked_hosts):\n                    f.write(host + \"\\n\")\n                message.info(\n                    \"hostblock: Read {} hosts from {} sources.\".format(\n                        len(self._blocked_hosts), done_count\n                    )\n                )\n        except OSError:\n            logger.exception(\"Failed to write host block list!\")\n\n    def update_files(self) -> None:\n        \"\"\"Update files when the config changed.\"\"\"\n        if not config.val.content.blocking.hosts.lists:\n            try:\n                os.remove(self._local_hosts_file)\n            except FileNotFoundError:\n                pass\n            except OSError as e:\n                logger.exception(\"Failed to delete hosts file: {}\".format(e))\n\n\n@hook.config_changed(\"content.blocking.hosts.lists\")\ndef on_lists_changed() -> None:\n    host_blocker.update_files()\n\n\n@hook.config_changed(\"content.blocking.method\")\ndef on_method_changed() -> None:\n    host_blocker.enabled = _should_be_used()\n\n\n@hook.init()\ndef init(context: apitypes.InitContext) -> None:\n    \"\"\"Initialize the host blocker.\"\"\"\n    global host_blocker\n    host_blocker = HostBlocker(\n        data_dir=context.data_dir,\n        config_dir=context.config_dir,\n        has_basedir=context.args.basedir is not None,\n    )\n    host_blocker.read_hosts()\n    interceptor.register(host_blocker.filter_request)\n",
                "after": "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n\n# Copyright 2014-2021 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n#\n# This file is part of qutebrowser.\n#\n# qutebrowser is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# qutebrowser is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with qutebrowser.  If not, see <https://www.gnu.org/licenses/>.\n\n\"\"\"Functions related to host blocking.\"\"\"\n\nimport os.path\nimport posixpath\nimport zipfile\nimport logging\nimport pathlib\nfrom typing import cast, IO, Iterator, Optional, Set\n\nfrom PyQt5.QtCore import QUrl\n\nfrom qutebrowser.api import (\n    hook,\n    config,\n    message,\n    interceptor,\n    apitypes,\n    qtutils,\n)\nfrom qutebrowser.components.utils import blockutils\nfrom qutebrowser.utils import version  # FIXME: Move needed parts into api namespace?\n\n\nlogger = logging.getLogger(\"network\")\nhost_blocker = cast(\"HostBlocker\", None)\n\n\ndef _widened_hostnames(hostname: Optional[str]) -> Iterator[str]:\n    \"\"\"A generator that yields widening string hostnames.\n\n    Ex: a.c.foo -> [a.c.foo, c.foo, foo]\n\n    Args:\n        hostname: The hostname string to widen.\n\n    Yields:\n        The hostname and its parent domains.\n    \"\"\"\n    if not hostname:\n        return\n    while hostname:\n        yield hostname\n        hostname = hostname.partition(\".\")[-1]\n\n\ndef _guess_zip_filename(zf: zipfile.ZipFile) -> str:\n    \"\"\"Guess which file to use inside a zip file.\"\"\"\n    files = zf.namelist()\n    if len(files) == 1:\n        return files[0]\n    else:\n        for e in files:\n            if posixpath.splitext(e)[0].lower() == \"hosts\":\n                return e\n    raise FileNotFoundError(\"No hosts file found in zip\")\n\n\ndef get_fileobj(byte_io: IO[bytes]) -> IO[bytes]:\n    \"\"\"Get a usable file object to read the hosts file from.\"\"\"\n    byte_io.seek(0)  # rewind downloaded file\n    if zipfile.is_zipfile(byte_io):\n        byte_io.seek(0)  # rewind what zipfile.is_zipfile did\n        zf = zipfile.ZipFile(byte_io)\n        filename = _guess_zip_filename(zf)\n        byte_io = zf.open(filename, mode=\"r\")\n    else:\n        byte_io.seek(0)  # rewind what zipfile.is_zipfile did\n    return byte_io\n\n\ndef _should_be_used() -> bool:\n    \"\"\"Whether the hostblocker should be used or not.\"\"\"\n    method = config.val.content.blocking.method\n\n    adblock_info = version.MODULE_INFO[\"adblock\"]\n    adblock_usable = adblock_info.is_usable()\n\n    logger.debug(f\"Configured adblock method {method}, adblock library usable: \"\n                 f\"{adblock_usable}\")\n    return method in (\"both\", \"hosts\") or (method == \"auto\" and not adblock_usable)\n\n\nclass HostBlocker:\n\n    \"\"\"Manage blocked hosts based from /etc/hosts-like files.\n\n    Attributes:\n        enabled: Given the current blocking method, should the host blocker be enabled?\n        _blocked_hosts: A set of blocked hosts.\n        _config_blocked_hosts: A set of blocked hosts from ~/.config.\n        _local_hosts_file: The path to the blocked-hosts file.\n        _config_hosts_file: The path to a blocked-hosts in ~/.config\n        _has_basedir: Whether a custom --basedir is set.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        data_dir: pathlib.Path,\n        config_dir: pathlib.Path,\n        has_basedir: bool = False\n    ) -> None:\n        self.enabled = _should_be_used()\n        self._has_basedir = has_basedir\n        self._blocked_hosts: Set[str] = set()\n        self._config_blocked_hosts: Set[str] = set()\n\n        self._local_hosts_file = str(data_dir / \"blocked-hosts\")\n        self.update_files()\n\n        self._config_hosts_file = str(config_dir / \"blocked-hosts\")\n\n    def _is_blocked(self, request_url: QUrl, first_party_url: QUrl = None) -> bool:\n        \"\"\"Check whether the given request is blocked.\"\"\"\n        if not self.enabled:\n            return False\n\n        if first_party_url is not None and not first_party_url.isValid():\n            first_party_url = None\n\n        qtutils.ensure_valid(request_url)\n\n        if not config.get(\"content.blocking.enabled\", url=first_party_url):\n            return False\n\n        host = request_url.host()\n        if blockutils.is_whitelisted_url(request_url):\n            return False\n\n        for hostname in _widened_hostnames(host):\n            if hostname in self._blocked_hosts or hostname in self._config_blocked_hosts:\n                return True\n        return False\n\n    def filter_request(self, info: interceptor.Request) -> None:\n        \"\"\"Block the given request if necessary.\"\"\"\n        if self._is_blocked(\n            request_url=info.request_url, first_party_url=info.first_party_url\n        ):\n            logger.debug(\n                \"Request to {} blocked by host blocker.\".format(info.request_url.host())\n            )\n            info.block()\n\n    def _read_hosts_line(self, raw_line: bytes) -> Set[str]:\n        \"\"\"Read hosts from the given line.\n\n        Args:\n            line: The bytes object to read.\n\n        Returns:\n            A set containing valid hosts found\n            in the line.\n        \"\"\"\n        if raw_line.startswith(b\"#\"):\n            # Ignoring comments early so we don't have to care about\n            # encoding errors in them\n            return set()\n\n        line = raw_line.decode(\"utf-8\")\n\n        # Remove comments\n        hash_idx = line.find(\"#\")\n        line = line if hash_idx == -1 else line[:hash_idx]\n\n        parts = line.strip().split()\n        if len(parts) == 1:\n            # \"one host per line\" format\n            hosts = parts\n        else:\n            # /etc/hosts format\n            hosts = parts[1:]\n\n        filtered_hosts = set()\n        for host in hosts:\n            if \".\" in host and not host.endswith(\".localdomain\") and host != \"0.0.0.0\":\n                filtered_hosts.update([host])\n\n        return filtered_hosts\n\n    def _read_hosts_file(self, filename: str, target: Set[str]) -> bool:\n        \"\"\"Read hosts from the given filename.\n\n        Args:\n            filename: The file to read.\n            target: The set to store the hosts in.\n\n        Return:\n            True if a read was attempted, False otherwise\n        \"\"\"\n        if not os.path.exists(filename):\n            return False\n\n        try:\n            with open(filename, \"rb\") as f:\n                for line in f:\n                    target |= self._read_hosts_line(line)\n\n        except (OSError, UnicodeDecodeError):\n            logger.exception(\"Failed to read host blocklist!\")\n\n        return True\n\n    def read_hosts(self) -> None:\n        \"\"\"Read hosts from the existing blocked-hosts file.\"\"\"\n        self._blocked_hosts = set()\n\n        self._read_hosts_file(self._config_hosts_file, self._config_blocked_hosts)\n\n        found = self._read_hosts_file(self._local_hosts_file, self._blocked_hosts)\n\n        if not found:\n            if (\n                config.val.content.blocking.hosts.lists\n                and not self._has_basedir\n                and config.val.content.blocking.enabled\n                and self.enabled\n            ):\n                message.info(\"Run :adblock-update to get adblock lists.\")\n\n    def adblock_update(self) -> blockutils.BlocklistDownloads:\n        \"\"\"Update the adblock block lists.\"\"\"\n        self._read_hosts_file(self._config_hosts_file, self._config_blocked_hosts)\n        self._blocked_hosts = set()\n\n        blocklists = config.val.content.blocking.hosts.lists\n        dl = blockutils.BlocklistDownloads(blocklists)\n        dl.single_download_finished.connect(self._merge_file)\n        dl.all_downloads_finished.connect(self._on_lists_downloaded)\n        dl.initiate()\n        return dl\n\n    def _merge_file(self, byte_io: IO[bytes]) -> None:\n        \"\"\"Read and merge host files.\n\n        Args:\n            byte_io: The BytesIO object of the completed download.\n        \"\"\"\n        error_count = 0\n        line_count = 0\n        try:\n            f = get_fileobj(byte_io)\n        except (OSError, zipfile.BadZipFile, zipfile.LargeZipFile, LookupError) as e:\n            message.error(\n                \"hostblock: Error while reading {}: {} - {}\".format(\n                    byte_io.name, e.__class__.__name__, e\n                )\n            )\n            return\n\n        for line in f:\n            line_count += 1\n            try:\n                self._blocked_hosts |= self._read_hosts_line(line)\n            except UnicodeDecodeError:\n                logger.error(\"Failed to decode: {!r}\".format(line))\n                error_count += 1\n\n        logger.debug(\"{}: read {} lines\".format(byte_io.name, line_count))\n        if error_count > 0:\n            message.error(\n                \"hostblock: {} read errors for {}\".format(error_count, byte_io.name)\n            )\n\n    def _on_lists_downloaded(self, done_count: int) -> None:\n        \"\"\"Install block lists after files have been downloaded.\"\"\"\n        try:\n            with open(self._local_hosts_file, \"w\", encoding=\"utf-8\") as f:\n                for host in sorted(self._blocked_hosts):\n                    f.write(host + \"\\n\")\n                message.info(\n                    \"hostblock: Read {} hosts from {} sources.\".format(\n                        len(self._blocked_hosts), done_count\n                    )\n                )\n        except OSError:\n            logger.exception(\"Failed to write host block list!\")\n\n    def update_files(self) -> None:\n        \"\"\"Update files when the config changed.\"\"\"\n        if not config.val.content.blocking.hosts.lists:\n            try:\n                os.remove(self._local_hosts_file)\n            except FileNotFoundError:\n                pass\n            except OSError as e:\n                logger.exception(\"Failed to delete hosts file: {}\".format(e))\n\n\n@hook.config_changed(\"content.blocking.hosts.lists\")\ndef on_lists_changed() -> None:\n    host_blocker.update_files()\n\n\n@hook.config_changed(\"content.blocking.method\")\ndef on_method_changed() -> None:\n    host_blocker.enabled = _should_be_used()\n\n\n@hook.init()\ndef init(context: apitypes.InitContext) -> None:\n    \"\"\"Initialize the host blocker.\"\"\"\n    global host_blocker\n    host_blocker = HostBlocker(\n        data_dir=context.data_dir,\n        config_dir=context.config_dir,\n        has_basedir=context.args.basedir is not None,\n    )\n    host_blocker.read_hosts()\n    interceptor.register(host_blocker.filter_request)\n",
                "additions": 18,
                "deletions": 0
              },
              "truncated": false
            },
            "time": {
              "start": 1769437581937,
              "end": 1769437585135
            }
          }
        },
        {
          "id": "prt_bfab2df03001clQlhfCYV6mp9x",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab2bf71001YfsQrofJkPZK3i",
          "type": "step-finish",
          "reason": "tool-calls",
          "snapshot": "b1c3d9be793ca323a18fc0864ec266bec6ead8d8",
          "cost": 0,
          "tokens": {
            "input": 0,
            "output": 362,
            "reasoning": 0,
            "cache": {
              "read": 65575,
              "write": 453
            }
          }
        }
      ]
    },
    {
      "info": {
        "id": "msg_bfab2e28800115nc3JFU3OPmaf",
        "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
        "role": "assistant",
        "time": {
          "created": 1769437586056,
          "completed": 1769437726637
        },
        "parentID": "msg_bfaaf7dfd001wtLwIM1eGC5XRs",
        "modelID": "claude-opus-4-5",
        "providerID": "anthropic",
        "mode": "opus-codex",
        "agent": "opus-codex",
        "path": {
          "cwd": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896",
          "root": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896"
        },
        "cost": 0,
        "tokens": {
          "input": 0,
          "output": 264,
          "reasoning": 0,
          "cache": {
            "read": 66028,
            "write": 613
          }
        },
        "finish": "tool-calls"
      },
      "parts": [
        {
          "id": "prt_bfab2ec0a001DpcWjTF6nAvOcc",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab2e28800115nc3JFU3OPmaf",
          "type": "step-start",
          "snapshot": ""
        },
        {
          "id": "prt_bfab2ec21001PTUTxbnR3lMV53",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab2e28800115nc3JFU3OPmaf",
          "type": "text",
          "text": "The LSP errors are pre-existing type annotation issues, not related to my changes. Now let me run the tests to see if they pass:",
          "time": {
            "start": 1769437588795,
            "end": 1769437588795
          }
        },
        {
          "id": "prt_bfab2ee84001otDhXP4aCSYw5H",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab2e28800115nc3JFU3OPmaf",
          "type": "tool",
          "callID": "toolu_01A3kaVd77xmZeGnSnSfUeXG",
          "tool": "bash",
          "state": {
            "status": "completed",
            "input": {
              "command": "cd /Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896 && source .venv/bin/activate && PYTHONPATH=\"$PWD:$PWD/tests\" QT_QPA_PLATFORM=offscreen pytest tests/unit/components/test_hostblock.py tests/unit/utils/test_urlutils.py tests/unit/config/test_configutils.py -v 2>&1 | tail -50",
              "description": "Run tests to verify the fix",
              "timeout": 300000
            },
            "output": "tests/unit/config/test_configutils.py::test_get_equivalent_patterns PASSED [ 92%]\ntests/unit/config/test_configutils.py::test_get_trailing_dot PASSED      [ 93%]\ntests/unit/config/test_configutils.py::test_no_pattern_support[add] PASSED [ 93%]\ntests/unit/config/test_configutils.py::test_no_pattern_support[remove] PASSED [ 93%]\ntests/unit/config/test_configutils.py::test_no_pattern_support[get_for_url] PASSED [ 93%]\ntests/unit/config/test_configutils.py::test_no_pattern_support[get_for_pattern] PASSED [ 94%]\ntests/unit/config/test_configutils.py::test_add_url_benchmark PASSED     [ 94%]\ntests/unit/config/test_configutils.py::test_domain_lookup_sparse_benchmark[http://www.qutebrowser.com/] PASSED [ 94%]\ntests/unit/config/test_configutils.py::test_domain_lookup_sparse_benchmark[http://foo.bar.baz/] PASSED [ 94%]\ntests/unit/config/test_configutils.py::test_domain_lookup_sparse_benchmark[http://bop.foo.bar.baz/] PASSED [ 94%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_from_str[foo, bar-expected0] PASSED [ 95%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_from_str[foo,   spaces -expected1] PASSED [ 95%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_from_str[-expected2] PASSED [ 95%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_from_str[foo, -expected3] PASSED [ 95%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_from_str[\"One Font\", Two-expected4] PASSED [ 96%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_from_str[One, 'Two Fonts'-expected5] PASSED [ 96%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_from_str[One, 'Two Fonts', 'Three'-expected6] PASSED [ 96%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_from_str[\"Weird font name: '\"-expected7] PASSED [ 96%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_to_str[families0-True-family] PASSED [ 97%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_to_str[families1-True-family1, family2] PASSED [ 97%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_to_str[families2-True-family] PASSED [ 97%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_to_str[families3-True-\"space family\", alien] PASSED [ 97%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_to_str[families4-True-\"comma,family\", period] PASSED [ 98%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_to_str[families5-False-family] PASSED [ 98%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_to_str[families6-False-family1, family2] PASSED [ 98%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_to_str[families7-False-family] PASSED [ 98%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_to_str[families8-False-space family, alien] PASSED [ 99%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_to_str[families9-False-comma,family, period] PASSED [ 99%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_from_str_hypothesis PASSED [ 99%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_system_default_basics PASSED [ 99%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_system_default_rendering PASSED [100%]\n\n\n------------------------------------------------------------------------------------ benchmark: 8 tests -----------------------------------------------------------------------------------\nName (time in ns)                                                                                                 Min                           Max                        Median          \n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\ntest_adblock_benchmark                                                                                       166.0082 (1.0)              8,917.0062 (1.0)                250.0019 (1.0)    \ntest_bench_widen_hostnames[qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq.c]               499.9456 (3.01)        41,118,666.9953 (>1000.0)            625.0339 (2.50)   \ntest_bench_widen_hostnames[test.qutebrowser.org]                                                             624.9757 (3.76)        44,223,000.0044 (>1000.0)            792.0316 (3.17)   \ntest_domain_lookup_sparse_benchmark[http://www.qutebrowser.com/]                                           2,124.9871 (12.80)          204,417.0396 (22.92)            2,291.9849 (9.17)   \ntest_bench_widen_hostnames[a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.z.y.z]                            3,458.0007 (20.83)       87,505,584.0006 (>1000.0)          3,916.9681 (15.67)  \ntest_domain_lookup_sparse_benchmark[http://foo.bar.baz/]                                                   4,291.0106 (25.85)        2,866,625.0291 (321.48)          12,250.0351 (49.00)  \ntest_domain_lookup_sparse_benchmark[http://bop.foo.bar.baz/]                                               9,083.0144 (54.71)        2,774,790.9771 (311.18)           9,750.0160 (39.00)  \ntest_add_url_benchmark                                                                             5,133,970,165.9745 (>1000.0)  6,732,140,959.0077 (>1000.0)  6,338,985,375.0123 (>1000.0)\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nLegend:\n  Outliers: 1 Standard Deviation from Mean; 1.5 IQR (InterQuartile Range) from 1st Quartile and 3rd Quartile.\n  OPS: Operations Per Second, computed as 1 / Mean\n======================= 418 passed in 124.22s (0:02:04) ========================\n",
            "title": "Run tests to verify the fix",
            "metadata": {
              "output": "tests/unit/config/test_configutils.py::test_get_equivalent_patterns PASSED [ 92%]\ntests/unit/config/test_configutils.py::test_get_trailing_dot PASSED      [ 93%]\ntests/unit/config/test_configutils.py::test_no_pattern_support[add] PASSED [ 93%]\ntests/unit/config/test_configutils.py::test_no_pattern_support[remove] PASSED [ 93%]\ntests/unit/config/test_configutils.py::test_no_pattern_support[get_for_url] PASSED [ 93%]\ntests/unit/config/test_configutils.py::test_no_pattern_support[get_for_pattern] PASSED [ 94%]\ntests/unit/config/test_configutils.py::test_add_url_benchmark PASSED     [ 94%]\ntests/unit/config/test_configutils.py::test_domain_lookup_sparse_benchmark[http://www.qutebrowser.com/] PASSED [ 94%]\ntests/unit/config/test_configutils.py::test_domain_lookup_sparse_benchmark[http://foo.bar.baz/] PASSED [ 94%]\ntests/unit/config/test_configutils.py::test_domain_lookup_sparse_benchmark[http://bop.foo.bar.baz/] PASSED [ 94%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_from_str[foo, bar-expected0] PASSED [ 95%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_from_str[foo,   spaces -expected1] PASSED [ 95%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_from_str[-expected2] PASSED [ 95%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_from_str[foo, -expected3] PASSED [ 95%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_from_str[\"One Font\", Two-expected4] PASSED [ 96%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_from_str[One, 'Two Fonts'-expected5] PASSED [ 96%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_from_str[One, 'Two Fonts', 'Three'-expected6] PASSED [ 96%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_from_str[\"Weird font name: '\"-expected7] PASSED [ 96%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_to_str[families0-True-family] PASSED [ 97%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_to_str[families1-True-family1, family2] PASSED [ 97%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_to_str[families2-True-family] PASSED [ 97%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_to_str[families3-True-\"space family\", alien] PASSED [ 97%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_to_str[families4-True-\"comma,family\", period] PASSED [ 98%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_to_str[families5-False-family] PASSED [ 98%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_to_str[families6-False-family1, family2] PASSED [ 98%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_to_str[families7-False-family] PASSED [ 98%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_to_str[families8-False-space family, alien] PASSED [ 99%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_to_str[families9-False-comma,family, period] PASSED [ 99%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_from_str_hypothesis PASSED [ 99%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_system_default_basics PASSED [ 99%]\ntests/unit/config/test_configutils.py::TestFontFamilies::test_system_default_rendering PASSED [100%]\n\n\n------------------------------------------------------------------------------------ benchmark: 8 tests -----------------------------------------------------------------------------------\nName (time in ns)                                                                                                 Min                           Max                        Median          \n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\ntest_adblock_benchmark                                                                                       166.0082 (1.0)              8,917.0062 (1.0)                250.0019 (1.0)    \ntest_bench_widen_hostnames[qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq.c]               499.9456 (3.01)        41,118,666.9953 (>1000.0)            625.0339 (2.50)   \ntest_bench_widen_hostnames[test.qutebrowser.org]                                                             624.9757 (3.76)        44,223,000.0044 (>1000.0)            792.0316 (3.17)   \ntest_domain_lookup_sparse_benchmark[http://www.qutebrowser.com/]                                           2,124.9871 (12.80)          204,417.0396 (22.92)            2,291.9849 (9.17)   \ntest_bench_widen_hostnames[a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.z.y.z]                            3,458.0007 (20.83)       87,505,584.0006 (>1000.0)          3,916.9681 (15.67)  \ntest_domain_lookup_sparse_benchmark[http://foo.bar.baz/]                                                   4,291.0106 (25.85)        2,866,625.0291 (321.48)          12,250.0351 (49.00)  \ntest_domain_lookup_sparse_benchmark[http://bop.foo.bar.baz/]                                               9,083.0144 (54.71)        2,774,790.9771 (311.18)           9,750.0160 (39.00)  \ntest_add_url_benchmark                                                                             5,133,970,165.9745 (>1000.0)  6,732,140,959.0077 (>1000.0)  6,338,985,375.0123 (>1000.0)\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nLegend:\n  Outliers: 1 Standard Deviation from Mean; 1.5 IQR (InterQuartile Range) from 1st Quartile and 3rd Quartile.\n  OPS: Operations Per Second, computed as 1 / Mean\n======================= 418 passed in 124.22s (0:02:04) ========================\n",
              "exit": 0,
              "description": "Run tests to verify the fix",
              "truncated": false
            },
            "time": {
              "start": 1769437591477,
              "end": 1769437725796
            }
          }
        },
        {
          "id": "prt_bfab50485001IyTr7wKUbUXTY5",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab2e28800115nc3JFU3OPmaf",
          "type": "step-finish",
          "reason": "tool-calls",
          "snapshot": "b1c3d9be793ca323a18fc0864ec266bec6ead8d8",
          "cost": 0,
          "tokens": {
            "input": 0,
            "output": 264,
            "reasoning": 0,
            "cache": {
              "read": 66028,
              "write": 613
            }
          }
        }
      ]
    },
    {
      "info": {
        "id": "msg_bfab508970016nPhsfa4vBa0Sr",
        "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
        "role": "assistant",
        "time": {
          "created": 1769437726872,
          "completed": 1769437752078
        },
        "parentID": "msg_bfaaf7dfd001wtLwIM1eGC5XRs",
        "modelID": "claude-opus-4-5",
        "providerID": "anthropic",
        "mode": "opus-codex",
        "agent": "opus-codex",
        "path": {
          "cwd": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896",
          "root": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896"
        },
        "cost": 0,
        "tokens": {
          "input": 0,
          "output": 250,
          "reasoning": 0,
          "cache": {
            "read": 66641,
            "write": 2206
          }
        },
        "finish": "tool-calls"
      },
      "parts": [
        {
          "id": "prt_bfab512d9001xVS9CSiJwq799F",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab508970016nPhsfa4vBa0Sr",
          "type": "step-start",
          "snapshot": "b1c3d9be793ca323a18fc0864ec266bec6ead8d8"
        },
        {
          "id": "prt_bfab512e8001mkSh91JRYlsBD7",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab508970016nPhsfa4vBa0Sr",
          "type": "text",
          "text": "All 418 tests passed. Let me verify that the specific tests mentioned in TASK.md are passing:",
          "time": {
            "start": 1769437730014,
            "end": 1769437730015
          }
        },
        {
          "id": "prt_bfab514e3001qBn3VYqezyVsrN",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab508970016nPhsfa4vBa0Sr",
          "type": "tool",
          "callID": "toolu_01FMHduDZtUUEGRRBddRZ4t9",
          "tool": "bash",
          "state": {
            "status": "completed",
            "input": {
              "command": "cd /Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896 && source .venv/bin/activate && PYTHONPATH=\"$PWD:$PWD/tests\" QT_QPA_PLATFORM=offscreen pytest tests/unit/components/test_hostblock.py::test_subdomain_blocking tests/unit/utils/test_urlutils.py::TestWiden -v 2>&1",
              "description": "Run specific subdomain tests",
              "timeout": 60000
            },
            "output": "============================= test session starts ==============================\nplatform darwin -- Python 3.10.15, pytest-7.4.4, pluggy-1.6.0 -- /Users/srihari/work/nilenso/swe-bench-pro-task-setup/qutebrowser/.venv/bin/python3.10\ncachedir: .pytest_cache\nPyQt5 5.15.11 -- Qt runtime 5.15.18 -- Qt compiled 5.15.14\nhypothesis profile 'default' -> deadline=timedelta(milliseconds=600), suppress_health_check=(HealthCheck.function_scoped_fixture,)\nbenchmark: 4.0.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)\nrootdir: /Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896\nconfigfile: pytest.ini\nplugins: mock-3.15.1, instafail-0.5.0, qt-4.5.0, xvfb-3.1.1, hypothesis-6.150.1, bdd-8.1.0, benchmark-4.0.0, rerunfailures-16.1\ncollecting ... collected 11 items\n\ntests/unit/components/test_hostblock.py::test_subdomain_blocking PASSED  [  9%]\ntests/unit/utils/test_urlutils.py::TestWiden::test_widen_hostnames[a.b.c-expected0] PASSED [ 18%]\ntests/unit/utils/test_urlutils.py::TestWiden::test_widen_hostnames[foobarbaz-expected1] PASSED [ 27%]\ntests/unit/utils/test_urlutils.py::TestWiden::test_widen_hostnames[-expected2] PASSED [ 36%]\ntests/unit/utils/test_urlutils.py::TestWiden::test_widen_hostnames[.c-expected3] PASSED [ 45%]\ntests/unit/utils/test_urlutils.py::TestWiden::test_widen_hostnames[c.-expected4] PASSED [ 54%]\ntests/unit/utils/test_urlutils.py::TestWiden::test_widen_hostnames[.c.-expected5] PASSED [ 63%]\ntests/unit/utils/test_urlutils.py::TestWiden::test_widen_hostnames[None-expected6] PASSED [ 72%]\ntests/unit/utils/test_urlutils.py::TestWiden::test_bench_widen_hostnames[test.qutebrowser.org] PASSED [ 81%]\ntests/unit/utils/test_urlutils.py::TestWiden::test_bench_widen_hostnames[a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.z.y.z] PASSED [ 90%]\ntests/unit/utils/test_urlutils.py::TestWiden::test_bench_widen_hostnames[qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq.c] PASSED [100%]\n\n\n-------------------------------------------------------------------------- benchmark: 3 tests --------------------------------------------------------------------------\nName (time in ns)                                                                                         Min                        Max                Median          \n------------------------------------------------------------------------------------------------------------------------------------------------------------------------\ntest_bench_widen_hostnames[qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq.c]       520.4929 (1.0)      34,727,021.0041 (186.33)     625.0048 (1.0)    \ntest_bench_widen_hostnames[test.qutebrowser.org]                                                     707.9798 (1.36)        186,374.9931 (1.0)        833.0098 (1.33)   \ntest_bench_widen_hostnames[a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.z.y.z]                    3,624.9985 (6.96)     76,106,958.0331 (408.35)   4,208.0064 (6.73)   \n------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nLegend:\n  Outliers: 1 Standard Deviation from Mean; 1.5 IQR (InterQuartile Range) from 1st Quartile and 3rd Quartile.\n  OPS: Operations Per Second, computed as 1 / Mean\n============================= 11 passed in 11.13s ==============================\n",
            "title": "Run specific subdomain tests",
            "metadata": {
              "output": "============================= test session starts ==============================\nplatform darwin -- Python 3.10.15, pytest-7.4.4, pluggy-1.6.0 -- /Users/srihari/work/nilenso/swe-bench-pro-task-setup/qutebrowser/.venv/bin/python3.10\ncachedir: .pytest_cache\nPyQt5 5.15.11 -- Qt runtime 5.15.18 -- Qt compiled 5.15.14\nhypothesis profile 'default' -> deadline=timedelta(milliseconds=600), suppress_health_check=(HealthCheck.function_scoped_fixture,)\nbenchmark: 4.0.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)\nrootdir: /Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896\nconfigfile: pytest.ini\nplugins: mock-3.15.1, instafail-0.5.0, qt-4.5.0, xvfb-3.1.1, hypothesis-6.150.1, bdd-8.1.0, benchmark-4.0.0, rerunfailures-16.1\ncollecting ... collected 11 items\n\ntests/unit/components/test_hostblock.py::test_subdomain_blocking PASSED  [  9%]\ntests/unit/utils/test_urlutils.py::TestWiden::test_widen_hostnames[a.b.c-expected0] PASSED [ 18%]\ntests/unit/utils/test_urlutils.py::TestWiden::test_widen_hostnames[foobarbaz-expected1] PASSED [ 27%]\ntests/unit/utils/test_urlutils.py::TestWiden::test_widen_hostnames[-expected2] PASSED [ 36%]\ntests/unit/utils/test_urlutils.py::TestWiden::test_widen_hostnames[.c-expected3] PASSED [ 45%]\ntests/unit/utils/test_urlutils.py::TestWiden::test_widen_hostnames[c.-expected4] PASSED [ 54%]\ntests/unit/utils/test_urlutils.py::TestWiden::test_widen_hostnames[.c.-expected5] PASSED [ 63%]\ntests/unit/utils/test_urlutils.py::TestWiden::test_widen_hostnames[None-expected6] PASSED [ 72%]\ntests/unit/utils/test_urlutils.py::TestWiden::test_bench_widen_hostnames[test.qutebrowser.org] PASSED [ 81%]\ntests/unit/utils/test_urlutils.py::TestWiden::test_bench_widen_hostnames[a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.z.y.z] PASSED [ 90%]\ntests/unit/utils/test_urlutils.py::TestWiden::test_bench_widen_hostnames[qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq.c] PASSED [100%]\n\n\n-------------------------------------------------------------------------- benchmark: 3 tests --------------------------------------------------------------------------\nName (time in ns)                                                                                         Min                        Max                Median          \n------------------------------------------------------------------------------------------------------------------------------------------------------------------------\ntest_bench_widen_hostnames[qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq.c]       520.4929 (1.0)      34,727,021.0041 (186.33)     625.0048 (1.0)    \ntest_bench_widen_hostnames[test.qutebrowser.org]                                                     707.9798 (1.36)        186,374.9931 (1.0)        833.0098 (1.33)   \ntest_bench_widen_hostnames[a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.z.y.z]                    3,624.9985 (6.96)     76,106,958.0331 (408.35)   4,208.0064 (6.73)   \n------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nLegend:\n  Outliers: 1 Standard Deviation from Mean; 1.5 IQR (InterQuartile Range) from 1st Quartile and 3rd Quartile.\n  OPS: Operations Per Second, computed as 1 / Mean\n============================= 11 passed in 11.13s ==============================\n",
              "exit": 0,
              "description": "Run specific subdomain tests",
              "truncated": false
            },
            "time": {
              "start": 1769437731827,
              "end": 1769437751104
            }
          }
        },
        {
          "id": "prt_bfab56749001G506JzrkY0iGWd",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab508970016nPhsfa4vBa0Sr",
          "type": "step-finish",
          "reason": "tool-calls",
          "snapshot": "",
          "cost": 0,
          "tokens": {
            "input": 0,
            "output": 250,
            "reasoning": 0,
            "cache": {
              "read": 66641,
              "write": 2206
            }
          }
        }
      ]
    },
    {
      "info": {
        "id": "msg_bfab56bcc001hYuEQluKXvjqVt",
        "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
        "role": "assistant",
        "time": {
          "created": 1769437752269,
          "completed": 1769437760135
        },
        "parentID": "msg_bfaaf7dfd001wtLwIM1eGC5XRs",
        "modelID": "claude-opus-4-5",
        "providerID": "anthropic",
        "mode": "opus-codex",
        "agent": "opus-codex",
        "path": {
          "cwd": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896",
          "root": "/Users/srihari/work/nilenso/swe-bench-pro-task-setup/worktrees/c580ebf0_subdomain_blocking_opus-codex_20260126_092238_32835896"
        },
        "cost": 0,
        "tokens": {
          "input": 0,
          "output": 306,
          "reasoning": 0,
          "cache": {
            "read": 68847,
            "write": 1503
          }
        },
        "finish": "stop"
      },
      "parts": [
        {
          "id": "prt_bfab5733c001S8g0gtNy5UyaLR",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab56bcc001hYuEQluKXvjqVt",
          "type": "step-start",
          "snapshot": "b1c3d9be793ca323a18fc0864ec266bec6ead8d8"
        },
        {
          "id": "prt_bfab57340001JE2M6JG35tgnie",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab56bcc001hYuEQluKXvjqVt",
          "type": "text",
          "text": "All the specific subdomain-related tests pass. Let me summarize what I did to fix the issue:\n\n**Changes Made:**\n\n1. **qutebrowser/utils/urlutils.py** - Added `widened_hostnames()` function that generates a sequence of hostnames starting from the full hostname and progressively removing subdomain prefixes (e.g., `a.b.c` -> `['a.b.c', 'b.c', 'c']`). Also added `Iterator` to the typing imports.\n\n2. **qutebrowser/components/hostblock.py** - \n   - Added `_widened_hostnames()` helper function with the same logic\n   - Modified `_is_blocked()` method to check not just for exact hostname matches, but also for any parent domain in the blocked hosts sets. This ensures that blocking `example.com` also blocks `subdomain.example.com`, `a.b.example.com`, etc.\n   - Added `Iterator` and `Optional` to the typing imports\n\nThe fix ensures that:\n- When a parent domain is blocked (e.g., `example.com`), all its subdomains are also blocked\n- Whitelist rules still take precedence (checked first before any blocking)\n- The implementation is efficient by iterating through the widened hostnames rather than checking all blocked hosts",
          "time": {
            "start": 1769437759752,
            "end": 1769437759752
          }
        },
        {
          "id": "prt_bfab58947001ZsuSIu32Le87F2",
          "sessionID": "ses_40550820cffe07XYg3whlmkgzW",
          "messageID": "msg_bfab56bcc001hYuEQluKXvjqVt",
          "type": "step-finish",
          "reason": "stop",
          "snapshot": "b1c3d9be793ca323a18fc0864ec266bec6ead8d8",
          "cost": 0,
          "tokens": {
            "input": 0,
            "output": 306,
            "reasoning": 0,
            "cache": {
              "read": 68847,
              "write": 1503
            }
          }
        }
      ]
    }
  ]
}
